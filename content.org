#+TODO: TODO(t) | DONE(o)
#+HUGO_BASE_DIR: ./
#+HUGO_SECTION: ./
#+title: 麦汁三昧
#+author: mugijiru
#+MACRO: youtube @@html:<div class="org-youtube"><iframe width="600" height="337" src="https://www.youtube.com/embed/$1" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe></div>@@
* 麦汁三昧
** DONE About
   CLOSED: [2020-12-20 日 11:59]
   :PROPERTIES:
   :EXPORT_FILE_NAME: about
   :END:

   この Web サイトは Web プログラマである麦汁の個人サイトです。

   気が向いたらブログ記事を更新したりするはず。

** DONE Profile
   CLOSED: [2020-12-20 日 12:15]
   :PROPERTIES:
   :EXPORT_FILE_NAME: profile
   :END:

   都内で Ruby on Rails と Vue.js や Ember.js などを使った Web アプリケーションを開発している Web プログラマ。
   一部インフラ(AWS)もかじっている。

   最近は実装よりも、仕様策定や全体の進捗管理、調査、その他雑用をしていることが多い。

   好きなエディタは Emacs。サブで Vim も使っている。

   1983年生まれ。沖縄出身。

*** 経歴
    - 2009年 :: 沖縄の IT ベンチャー企業に就職しWebプログラマとして活動
    - 2012年 :: 別の沖縄の IT ベンチャー企業に転職し引き続きWebプログラマとして活動
    - 2016年 :: 都内 IT ベンチャー企業に転職しWebプログラマとして活動
    - 2019年 :: 同社でリードエンジニアというポジションになり開発以外の作業が増えた
    - 2022年 :: 別の都内 IT ベンチャー企業に転職しWebプログラマとして活動
*** SNSなど
    - Twitter :: [[https://twitter.com/mugijiru][@mugijiru]]
    - GitHub :: [[https://github.com/mugijiru][mugijiru]]
    - 旧Blog :: [[http://mugijiru.seesaa.net][麦汁三昧]]
** Projects
   :PROPERTIES:
   :EXPORT_FILE_NAME: projects
   :END:

   - [[https://mugijiru.github.io/.emacs.d/][Emacs Config]] :: Emacs の設定についてのドキュメント
   - [[https://github.com/mugijiru/ember-rails-todo-app][Ember rails TODO App]] :: Ember.js 関連の検証用プロジェクト。ember-rails から ember-cli-rails に乗り換えて最新の Ember.js にアップグレードしたりしている
   - [[https://github.com/mugijiru/ember-components][Ember Components]] :: Ember.js 検証関連プロジェクト。ember-rails と ember-cli-rails の両方で使える Addon を作ったりしている
** Privacy Policy
   :PROPERTIES:
   :EXPORT_FILE_NAME: privacy_policy
   :END:

*** アクセス情報の収集
    当サイトでは Google Analytics によるアクセス情報の収集を行っています。

    Google Analytics ではデータの収集のためにお使いのウェブブラウザから
    Google にアクセスしたページの URL やユーザーの IP アドレスなどの情報が自動的に送信されます。
    また、Google がお使いのブラウザに Cookie を設定したり、既存の Cookie を読み取ったりする場合もあります。

    詳細は以下をご確認ください。
    https://policies.google.com/technologies/partner-sites

*** 広告の配信
    当サイトでは Google AdSense による広告配信を行っています。

    - Google などの第三者配信事業者が Cookie を使用して
      ユーザーがそのウェブサイトや他のウェブサイトに過去にアクセスした際の情報に基づいて広告が配信されます
    - Google が広告 Cookie を使用することにより、
      ユーザーがそのサイトや他のサイトにアクセスした際の情報に基づいて、
      Google やそのパートナーが適切な広告をユーザーに表示できます。
    - ユーザーは、[[https://www.google.com/settings/ads][広告設定]] でパーソナライズ広告を無効にできます。
      または、[[http://www.aboutads.info/choices/]] にアクセスすれば、パーソナライズ広告に使われる第三者配信事業者の Cookie を無効にできます。

** Blog
   :PROPERTIES:
   :EXPORT_HUGO_SECTION: posts
   :END:
*** DONE org-todo を ivy で設定できるようにした                      :@Emacs:
    CLOSED: [2020-05-31 日 01:32]
    :PROPERTIES:
    :EXPORT_FILE_NAME: set-org-todo-from-ivy
    :END:

    posframe っていいですよね。
    いきなりタイトルと関係なさそうな単語出したけど。
    まあ ivy-posframe を使ってるので ivy を使うと posframe が使えて便利って話なんだけど。

    ところで話は若干変わって、
    org-todo って実行するとウインドウが分割されてバッファが表示されてそこから選ぶ形になるじゃないですか。
    もしかしたら設定がちゃんとしてたりしたらならないのかもしれませんけど、
    とりあえず私の環境だとなるんですよ。

    で、それだと何が問題かというと
    ウインドウ分割される時に元々見ていたバッファがガチャガチャと移動しちゃってつらいんですよ。
    posframe を使えるとそれが起きなくて便利なんですよ。

    というわけで、org-todo でキーワード選ぶ時にも
    posframe が使えるといいなって思ったんですよ。

    で、色々調べた結果、自分にはそういうのを提供してくれる設定とか拡張とか見つけられなかったんですよ。

    じゃあ作るしかないじゃん?
    というわけで、そういう関数作った

    #+begin_src emacs-lisp
    (defun my/org-todo ()
      (interactive)
      (ivy-read "Org todo: "
                org-todo-keywords-for-agenda
                :require-match t
                :sort nil
                :action (lambda (keyword)
                          (org-todo keyword))))
    #+end_src

    org-todo の代わりにこの関数を呼ぶと
    ivy で TODO のキーワードが設定できる。
    ivy は ivy-posframe を使ってるから、画面がガチャガチャ動かなくなる。便利。

    この変更に関する Emacs の設定ファイルへの Pull request は
    https://github.com/mugijiru/.emacs.d/pull/74
    に置いてるので興味があれば見てもらえると。

    ところで ivy でこういう選択するインターフェース書いたの初めて。
    とりあえず書いてみたらできたので、また別のやつも ivy を使って書いてみたい。
*** DONE Hugo 始めました                                              :@雑記:
    CLOSED: [2020-12-20 日 15:22]
    :PROPERTIES:
    :EXPORT_FILE_NAME: starting-hugo
    :END:

    Hugo はなんか Emacs 界隈で流行ってるし、
    自分のサイトだっせーなーって思ってたので
    Hugo を使って、公開されてるテンプレートを適用して
    Web サイトを再構築してみることにした。

    <!--more-->

    他の静的サイトジェネレータもちょっと検討したけど
    機能面とかも考慮した上で Hugo がいいかなって。
    主な理由は「流行ってるから」ですが。
    ほら、流行りに乗りたいじゃん。ちょっと乗り遅れてる気もするけど。

    今、とりあえず作ってる最中なんだけど、
    つい BBS とかチャットとかリンク集とか置きたくなる。
    90年代または2000年代脳である。
    お絵描き BBS も置いたろうかって気持ちになる。
*** DONE 新年明けましておめでとうございます                           :@雑記:
    CLOSED: [2021-01-02 土 20:31]
    :PROPERTIES:
    :EXPORT_FILE_NAME: happy-new-year-2021
    :END:

    新年明けましておめでとうございます。麦汁です。
    昨年の終わり頃、世間では AdventCalendar で賑ってる頃に、
    ふと「サイトのリニューアルしたいなあ」なんてことを思って、
    リニューアルに着手しましたが、ようやくそれが実りそうです。

    <!--more-->

    なんでそんなことをしてるかというと
    前の記事 [[*Hugo 始めました][Hugo 始めました]] でも書いたように
    「自分が作ったサイトだっせー」ってのが1つあります。

    それを構築した時には
    「デザインとかも全部自分でやっちまおう」ということで全部やろうとしていたのですが
    デザインセンスが壊滅的だったとか時間がろくに取れないとかやる気が他に吸われていったとかで
    イマイチなまま放置していました。よくないですねえ。

    あと、そことは別にブログサービスを借りて使ってるのですが
    そっちはそっちで更新がだるいなってのもあって
    リニューアルと同時に今後のブログ更新はこっちにしてしまおう、というのもあったりします。

    Hugo でブログもやってしまう方が [[https://ox-hugo.scripter.co/][ox-hugo]] も使って記事を書き出せるので
    org-mode 使い的には幸せになれそうですし。

    あとは折角リニューアルしたんだからモチベーションが続くことを願っています。

    というわけで 2021 年の抱負は「月に2回はブログを更新する」とします。

    結構、緩めな抱負ですが、仕事じゃないのでこのぐらいの方が良かろう……。
*** DONE browse-at-remote を導入した                                 :@Emacs:
    CLOSED: [2021-01-23 土 23:18]
    :PROPERTIES:
    :EXPORT_FILE_NAME: add-browse-at-remote
    :END:

    仕事中、プルリクのレビューをする際に、
    「ここのコードがこんな感じになってるから〜」みたいな感じで
    既存コードへのリンクを張ることがちょくちょくある。

    そういうことをする時、まずそもそも差し示したいコードを確認するんだけど
    その時は Emacs の中で探す方が早い。
    で、探して確認するまではいいんだけど、そこから GitHub 上のコードへのリンクを取得しようとするとちょっと面倒。

    これまでは、GitHub のリポジトリのトップからディレクトリを辿って行って
    当該コードを再度探していました。めんどくさいねっ。

    というわけで解決する手段を探していて
    最近導入したのが [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] というやつ。

    こいつを入れてる状態で、GitHub のリポジトリに突っ込んであるコードの上で
    ~M-x browse-at-remote~ を実行すると
    GitHub でのリポジトリでのコードの位置でブラウザを開いてくれる。

    コードの上でと書いたけど、リージョンを選択していればその範囲が選択された状態で実行すると
    選択した行がハイライトされた状態で開いて便利。

    その状態から GitHub 上で ~Copy permalink~ をしておいて
    PR のコメントにコピーしたリンクを貼り付けるとコードも表示されて便利。

    で、結構よく使うコマンドとなったので
    Hydra から即呼び出せるようにしてある。

    Global に使うコマンドを突っ込んでる Hydra は key-chord で ~jk~ を叩くと呼べるようにしていて
    その中で ~B~ を叩けば browse-at-point が呼ばれるようにしてある。

    というわけで、導入と Hydra の設定を追加しているプルリクが以下になります。
    https://github.com/mugijiru/.emacs.d/pull/205

    という使い方をしているけど、
    実は似た機能を提供している [[https://github.com/sshaw/git-link][git-link]] で ~git-link-use-commit~ のフラグを立てておいて
    他にもいくつか設定を入れたりしたらもっといい感じのことができるのかもしれない。
    今度試すか……。

*** DONE 2021年にもなって ember-rails で新規アプリを書いてみてる :@Rails:@Ember_js:
    CLOSED: [2021-02-13 土 01:15]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-in-2021
    :END:

    少し思うところがあって、
    2021 年になったというのに [[https://github.com/emberjs/ember-rails][ember-rails]] を使って新規で Web アプリを書いている。

**** ember-rails とは?

     ember-rails は
     Ember.js という Web フロントエンド MVC なフレームワークを
     Rails といい感じに連携してくれて快適な Web アプリケーション開発体験を提供してくれるものであった。

     過去形なのは、ember-rails は Rails3 とか 4 とかの時代に主に使われていて
     既にメンテナンスされてないのと、
     今はそれよりも良い [[https://github.com/thoughtbot/ember-cli-rails][ember-cli-rails]] というのがあるから。

**** 今 ember-rails を使うと何がつらいか

     色々つらい。

***** まずメンテナンスが止まってる
      なので Rails 6 で動くかがわからない。
      多分、試している人はいないし、自分もそこまで試す気力はない。

***** Ember.js のサポートが 2.18.2 までとなっている。
      より詳細に話すと
      ember-rails が依存している Gem である ember-source で
      本当は 3.0.0.beta.2 まで出てるんだけど、β版のことは無視する。
      https://rubygems.org/gems/ember-source/versions/2.18.2

      で、その 2.18.2 は既にサポートされてないバージョンである。

      サポートされてないバージョンを使うのはセキュリティ面でもまずいし
      もはや情報もあまり落ちてないので苦行である。

      Ember.js 公式サイトのドキュメントが
      過去のバージョンのものも残されているのでそれを頼りにするしかない。
      というか公式で残しててくれてありがとう。それがないと何もできないよ。

***** ember-rails だと Ember.js の addon が導入できない
      例えば Handlebars でロジックを書く上で
      とても基本的な比較用のヘルパーを提供してくれる [[https://github.com/jmurphyau/ember-truth-helpers][ember-truth-helper]] が使えない。
      これが使えないはめっちゃ不便で、
      それをなんとかするために同じようなコードを自前で用意するハメになる。

      他にも [[https://github.com/ember-community-russia/awesome-ember][ember-community-russia/awesome-ember]] に載っている色々なものが使えないわけだ。
      つらいどころか悲しくなってくる。

***** 自動テストが書けない
      Ember.js は QUnit で自動テストができるようになっているのだが
      ember-rails だとそれも使えない。
      すなわちフロントエンドのコンポーネントの単体テストが書けないのである。

**** それでも ember-rails を使いたい方には

     どうして素直に ember-cli-rails や ember-cli そのものを使おうとしないのかはわからないけど
     どうしても ember-rails の世界に住みたいのであれば
     [[https://github.com/discourse/discourse][discourse]] のソースを参考にしたら良いと思う。

     どうやら [[https://github.com/discourse/discourse/pull/11932][ember-cli に乗り換える方針で動いているよう]] だが
     今日時点の Gemfile には未だに discourse-ember-source などの記述が残っている状態であり、
     まだ完全移行はできてない様子。

     [[https://rubygems.org/gems/discourse-ember-source/versions/3.12.2.2][discourse-ember-source]] は 3.12 系まで追従していたようなので
     そこまでは discourse の真似をすれば使えるだろう。

     また彼らは ember-rails を使いながら qunit でのテストもできるようにしているようである。
     正直マジか頑張ったなって気持ち。
     ちょっとどうやって動かしているのかはわからない。
     あんまり調べる気力もない。
     なんとなくわかったことは ES6 の module システムを活用して頑張ってる雰囲気があることである。

     他にも addon も使えるようにしている様子でもあるが、
     これもちょっとよくわかってない。
     あまり adoon が使われてる気もしないが……。

     ともかく ember-rails を独自に拡張した上で色々頑張っているようである。すごい。
     それでももう ember-cli-rails に乗り換えようとしているようなので
     今から ember-rails の世界に住もうとするのはやめた方がいいはず。

     あ、よく見ると Rails は 6.0 系だ。
     ってことは少なくとも discourse-ember-rails なら Rails 6.0 でも動くわけか。なるほど。

**** で、なぜ自分は ember-rails で新規アプリを書いているか

     マゾなので、敢えてその環境で新規アプリを用意しておいて
     そこから ember-cli-rails に移行する、みたいなことをしてみたいから。

     本当は自分で ember-rails なアプリを書くつもりはなかったんだけど
     サンプルになるようなアプリが探せなかったってのもある。
     これが Yak Shaving か〜と思いながら粛々と小さなアプリを書いていくのであった

     できたらまた記事にする。
     アプリ自体は公開しないけど、ソースは GitHub に上げるつもり。

*** DONE ember-rails で書いた Web アプリを GitHub で公開した :@Rails:@Ember_js:
    CLOSED: [2021-02-21 日 15:40]
    :PROPERTIES:
    :EXPORT_FILE_NAME: publish-ember-rails-app
    :END:

    [[*2021年にもなって ember-rails で新規アプリを書いてみてる][この間の記事]] で書いたように
    ember-rails で簡単なアプリケーションを作ってた。
    よくある TODO アプリである。

    [[file:images/screenshot-ember-rails-todo-app.png]]

    先週時点では「テストとかなくてもいいから動けばいいだろ」って気持ちだったけど
    なんとなーくテストを追加したくなったり
    あんまり慣れてない docker-compose 対応してみたりしていたのと
    平日はこのプログラムに触れてなかったので、結構日が空いてしまった。

    まあ、それはともかくとして、
    とりあえず [[https://github.com/mugijiru/ember-rails-todo-app/]] に置いておいた
    現時点の最新コミットで [[https://github.com/mugijiru/ember-rails-todo-app/tree/v1.1.1][v1.1.1]] のタグを振ってるやつは
    自分の知ってる一番古いスタイルで書かれてる状態にしてある。

**** 使ってる Gem

     - Ember.js 関係
       - ember-rails
       - ember-source
       - jquery-rails
         - Ember.js は 2 系まで jquery に依存しているので
           - よく見ると ember-rails の依存に入ってるから書かなくて良かったな……
       - active_model_serializers 0.9
         - 0.9 系じゃないとうまく動かないっぽい
     - CSS framework
       - bootstrap-sass
         - レガシー感の演出のため敢えてこれにしている
     - テスト関係
       - rspec-rails
       - factory_bot_rails
       - database_rewinder
       - capybara
       - selenium-webdriver

     あたり。

**** レガシー感の演出

     レガシー感を出すために bootstrap-sass(Bootstrap3系になる)を使ったりはしているが
     あまり特別なものは使ってない。

     また ember-rails で ember アプリのソースコードを generate すると
     es6 module を使ったようなコードが出力されるけど、
     これも敢えてレガシー感を出すために module を使わない形式に書き直している。

     よりレガシー感を出すために CoffeeScript にするという手もあったけど、
     さすがにそこまでは頑張りたくないw
     もう何年も触ってないよ CoffeeScript...

     そしてページ全体を Ember.js にはしないで
     ページの一部を Ember.js にする [[https://guides.emberjs.com/v2.18.0/configuring-ember/embedding-applications/][埋め込み]] 形式を採用している。
     既存のアプリに Ember.js を後乗せした感の演出である。
     実際、構築時には一時的に普通の Rails App として動くようにしていた。

     他にこだわったところは、今回は単一のアプリケーションしか動かしてないけど
     [[https://github.com/emberjs/ember-rails#multiple-ember-application][Multiple Ember Application]]
     の作法に則って、Ember アプリケーションを追加で乗せられるようにしている。
     これにより「この画面も Ember 化しようず」という流れで
     Ember アプリが複数動いてる状態により近くなったんじゃないかなと。
     実際今回動いてるのは1つだから、ちょっと違うけどね。。。

**** 最後に

     ここから段々と最新の Ember.js を使えるように寄せていくつもり。

*** DONE 古い ember-rails App で一部ファイルを ES6 Module 化 :@Rails:@Ember_js:
    CLOSED: [2021-02-21 日 22:41]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-partial-modulize
    :END:
**** これは何?
     ember-rails を古いスタイルで書いておいて
     それをモダン化していく企画の第一弾の記事。

**** 何をしたのか
     今回は ES6 module を使ってない ember-rails アプリケーションで
     一部のファイルだけ ES6 Module にしてみた。

**** 何が嬉しい?
     今回扱ってるアプリケーションのサイズはとても小さいので
     まとめて置き換えることも可能というか、
     ぶっちゃけ [[https://github.com/mugijiru/ember-rails-todo-app/pull/7][古いスタイルに書き換えた PR]] を revert するだけで
     ES6 Module 化できたりする。

     しかし、世の中に潜んでいる、レガシー化した ember-rails のプロジェクトでは
     全部まとめて ES6 Module にするのはファイル数が多過ぎて困難かと考え、
     敢えて一部のファイルだけ ES6 Module 化する方法を探してみた。

**** どうやったらできるの?

     簡単に言うと
     ES6 Module 形式で書いたやつを import して
     Ember.js Application の Namespace に放り込めばいいだけ。

***** Example
      まずはコンポーネントなどを
      ~app/assets/javascripts/ember-app/components/foo.module.es6~ ってファイル名で

      #+begin_src js
      import Ember from 'ember';

      export default Ember.Component.extend({});
      #+end_src

      のように書いておく。
      拡張子が ~.module.es6~ というのがポイントで、
      そうしておくと
      [[https://github.com/tricknotes/ember-es6_template][ember-es6_template]] という Gem が
      自動的に ES6 の module として判定してくれるようになっている
      https://github.com/tricknotes/ember-es6_template/blob/c1c7b8d23be7669a0aa6c5f9c71b916a3799f9a6/lib/ember/es6_template/sprockets.rb#L10

      そして ~app/assets/javascripts/ember-app/application.js.es6~ の末尾にでも

      #+begin_src js
      import FooComponent from 'ember-app/components/foo';

      EmberApp.FooComponent = FooComponent;
      #+end_src

      のように書いたら、
      一応 module 形式で書けるし、
      それを window.EmberApp で用意した Ember.js Application で使えるって感じ。

**** ファイルの数と同じ量の import 書くの?

     だるいよね。
     なので import 処理は
     ~app/assets/javascripts/ember-app/import-modules.js.es6.erb~
     という erb template でも分離して

     #+begin_src erb
     <% module_dir = Rails.root.join('app/assets/javascripts/ember-app/modules') %>
     <% Dir.each_child(module_dir) do |dir| %>
       <% next unless FileTest.directory?("#{module_dir}/#{dir}") %>
       <% Dir.glob('*.module.es6', base: "#{module_dir}/#{dir}") do |module_file| %>
         <% module_name = File.basename(module_file, '.module.es6') %>
         <% klass_name = "#{module_name.underscore.camelize}#{dir.underscore.singularize.camelize}" %>
     import <%= klass_name %> from 'ember-app/modules/<%= dir %>/<%= module_name %>';
     EmberApp.<%= klass_name %> = <%= klass_name %>;
       <% end %>
     <% end %>
     #+end_src

     とでも書いておけば全部いい感じに読んでくれる。

**** 関連 PR

     実際に動くコードは以下の PR で用意した。
     https://github.com/mugijiru/ember-rails-todo-app/pull/8
     https://github.com/mugijiru/ember-rails-todo-app/pull/9

     最初の PR で ~modules~ フォルダにさらに components フォルダを掘って
     その中にファイルを配置している。

     その方が全部移行できた後にまるっと置き換えするのに楽そうだからだ。

     また import して Namespace に放り込む処理も別ファイルに追い出している。
     これも、完全移行が済んだら不要になるファイルなので
     消しやすさを重視して分割しておいた。

     さらに後続の PR で、
     複数のタイプが来ても対応できるように書き換えている。
     Model は対応できてないけど、ま、Model は移行してないのでとりあえず放置。

     CI でテストも通しているしバッチリだと思う。
     デプロイできるようにはしてないからサーバで動くかは確認してないけど、ま、大丈夫だろ

*** DONE 古い ember-rails App で ES6 Module 化を完了した   :@Rails:@Ember_js:
    CLOSED: [2021-02-23 火 20:45]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-complete-modulize
    :END:

    - [[https://github.com/mugijiru/ember-rails-todo-app/pull/10][#10 サブフォルダのファイルを全て module に移行した]]
    - [[https://github.com/mugijiru/ember-rails-todo-app/pull/11][#11 残りのファイルも module 化した]]

    でやってることで全てだけど
    [[*古い ember-rails App で一部ファイルを ES6 Module 化][前回の記事]] でやってた内容を完了まで持って行った。

**** サブフォルダ以下の ES6 Module 化
     https://github.com/mugijiru/ember-rails-todo-app/pull/10 でやったこと。

     これは基本的に単純で、
     ほぼ前回の記事でやってることを全部のフォルダに適用しただけ。

     Model だけ命名規則が他と違うので
     import 関連の処理をそこだけ分岐している

     #+begin_src erb
     <% if dir == 'models' %>
       <% klass_name = module_name.underscore.camelize %>
     <% else %>
       <% klass_name = "#{module_name.underscore.camelize}#{dir.underscore.singularize.camelize}" %>
     <% end %>
     import <%= klass_name %> from 'todo-app/modules/<%= dir %>/<%= module_name %>';
     TodoApp.<%= klass_name %> = <%= klass_name %>;
     #+end_src

     Model は ~models/hoge.module.es6~ とあったら ~Hoge~ として使われるようにして、
     他は例えば Component だと ~components/fuga.module.es6~ とあったら ~FugaComponent~ として使われるようにしているだけ。

     あとはそれぞれのファイルを ~*.js.es6~ から ~*.module.es6~ に rename して import, export に書き換えるだけ。
     とても簡単だし、全部まとめて変更する必要もないので楽。

     ただこれをやってる時に気付いたのが
     ~import-modules.js.es6.erb~ が cache されてるおかげで
     module 化対象のファイルだけ変更・移動しても import 文が変更されなくて
     うまく読み込まれない問題があるということ。
     何故か rspec は通ったりするけど。

     まあその時は ~rails tmp:cache:clear~ して cache を消すか
     ~import-modules.js.es6.erb~ に適当に空行でも加えて cache を使われないようにしたら解決する。

**** router.js.es6, <APP_NAME>.js.es6, environment.js.es6 の ES6 Module 化
     https://github.com/mugijiru/ember-rails-todo-app/pull/11 でやったこと。

     サブフォルダのファイルを全部 module にしたら
     後は変更しないといけないファイルはこれぐらい。

     変更の流れは大体以下の感じ

     1. router.js.es6 をこれまでのファイルと同じように module 化
     2. environment.js.es6 も同様に module 化
     3. <APP_NAME>.js.es6 の module 化とそれに伴うファイル移動等

***** router.js.es6 をこれまでのファイルと同じように module 化
      https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/359520f6656920ac8ef3fe623d15f2368cc66a78

      この commit でやってることそのもの。

      拡張子を module.es6 に変更して中身を module っぽく書いて
      require される順番を最後に移動し、最後に他のファイルみたいに import してあげるだけ。

***** environment.js.es6 も同様に module 化
      実はこのファイルをまともに使ってなかったので PR では後ろに回したんだけど、
      多分ちゃんとやるならこのタイミングかなって。

      これもさっきの手順と同じ感じだと思う。
      require するタイミングは ~//= require ./todo-app~ の直前になる。
      そのタイミングになる理由はよく知らんけど
      ember-rails で generate したらそこに来るからそこでいいんだろ(適当)

      実際 import して使われるタイミングは application.js.es6 の中で明示的に import することになるので
      require_self するより前ならどこでも良さそうな気はする。

      あと、多分、古いスタイルに書き換える時に適当にやってたので
      そもそも古いスタイルでの environment の置き方が正しくなさそうな気もする。

      一応 https://guides.emberjs.com/v1.10.0/configuring-ember/ に

      #+begin_quote
      Note that the above code must be evaluated before Ember.js loads.
      #+end_quote
      と書いてるのでそれに従って対応してたつもりだけどね。

      ま、古いスタイルの正しいやりかたを必要としている人はいないだろうし
      新しい形式でちゃんと動けば良かろう。ちゃんと動くか知らんけど。

***** <APP_NAME>.js.es6 の module 化とそれに伴うファイル移動等

      https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/d3673bfa455906abd0ff6d31d1d3f4f083bd4a71
      の commit でやってることだけど、ここが結構まとめて色々やらないといけなさそう。

      <APP_NAME>.js.es6 を ES6 Module 化をするんだけど
      ここが一番色々書き変わるところ。

      事前に Namespace を用意する必要がなくなったので require_self を一番最後にしたり、
      ~import Application from 'ember-rails/application~ しておいて
      そこから extend して export して、みたいな。
      まあ [[https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/d3673bfa455906abd0ff6d31d1d3f4f083bd4a71#diff-7aa5fb21bec5b1e11d78f1b7c34b3b92f05b293d97a99ed2af713f81ea5dab82][ファイル]] を見た方が早いか。

      で、こいつを ES6 Module にすると ember-rails での自動 import が動くようになる。
      なので、事前に module 化していたファイルを全部本来の位置に戻した上で
      これまでお世話になってきた ~import-modules.js.es6.erb~ にさよならすることになる。
      ま、そいつは消しやすいように別ファイルに分離していたんだけども。

      あと当然 application.js.es6 も、
      他のファイルが全部 module 化された前提で書き換える必要がある。
      まあほとんど <APP_NAME>.js.es6 を import して create するだけなんだけど。

      以上でほぼ終わりだけど、
      不要になった modules フォルダを消して require_tree する処理を消すのを忘れずに。
      麦汁さんはそれを忘れて [[https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/0f90fda419f9c23f844ba2e53dc1c2fa2e9b5d51][commit を積むことになった]]

**** ここまでやると何ができるようになるか

     ember-rails で書いた上で最も最新の記述に変更できた状態となる。
     というわけで、これでようやく ember-cli-rails 移行する準備ができました! やったね!

     まあぶっちゃけ ember-cli-rails 移行と module 化を同時にやっちゃうという手もあるけど、
     1回1回の変更差分を小さくするには、バラバラがいいかなってことで分けてやっている。

     だって、そうじゃないと「はい変更の多い PR はリジェクト〜wwww」ってされかねない^^

*** DONE ember-rails でコンポーネントを共通ライブラリとして切り出す :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 10:45]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-extract-common-libs
    :END:

    ember-rails を使って1つの Rails アプリの上に
    複数の Ember.js アプリケーションを動かしていると
    各アプリで同じようなコンポーネントを使っていたり、
    あるいは同じようなコンポーネントが必要だというのに気付いて
    共通ライブラリとして実装したくなることがある。あるんだよ。

    というわけで、その共通化を2パターンでやってみた。
    2パターンというのは 旧来の書き方の場合と
    ES6 Module 対応版の場合とである。

    なおいずれのパターンもサーバへのデプロイはやってないので
    もしかしたらサーバ環境では動かないかもしれないがご容赦を。

**** 旧来版
     先に答えを出すと
     https://github.com/mugijiru/ember-rails-todo-app/pull/13
     に実装した通りである。

***** template からの呼び出し
      template で ~{{ember-libs/button}}~ と書いた場合に
      Resolver には ~component:ember-libs/button~ として解釈するように要求されるっぽい。
      これはソースからではなく、挙動的に確かめただけ。

***** コンポーネントの探索
      旧来の書き方の場合に探索に使われるのが GlobalsResolver というやつ。

      この GlobalsResolver というやつは [[https://github.com/emberjs/ember.js/blob/e2007b6ecb046fd06f6b43c381e8a1128914ad43/packages/%40ember/application/globals-resolver.js#L59-L76][コメント]] にも書かれてるように
      ~component:ember-libs/button~ と渡されたら、
      GlobalsResolver は ~EmberLibs.ButtonComponent~ として解釈するようになっている。
      つまり EmberLibs という名前空間の ButtonComponent を探しに行くようになっている。

***** 名前空間の定義
      というわけで、まずは [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-e1803bb0635866bc90975a1321dbfa6d20be59e76ec3d7b80c8acc4656f8af9fR6][ember-libs/ember-libs.js.es6]] に書いてるように

      #+begin_src js
      window.EmberLibs = Ember.Namespace.create()
      #+end_src
      と書くことで
      EmberLibs という名前空間を定義してやる。

      一応 ~ember-libs/ember-libs.js.es6~ では require の順番として
      ember はそこで定義している実装を使うので先に require して
      そのファイルで定義している名前空間を components で使うので components を require するより前に
      require_self をしている。

***** 共通コンポーネントの記述
      各コンポーネントはその名前空間の下に入るように書けばいい。
      例えば [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-9f9be147342dc470d8f0cba8a06a55a210550e01b22502bd6e0aff0d029ae38cR1][ember-libs/components/button.js.es6]] に書いてるように

      #+begin_src js
      EmberLibs.ButtonComponent = Ember.Component.extend()
      #+end_src

      というように書いてやれば動く。

***** config.handlerbars.templates_root の設定

      templates を ember-libs/templates に入れるので
      Rails 側の設定で ~config.handlebars.templates_root~ に ~ember-libs/templates~ を追加するのを忘れずに。
      ember-rails の設定例に従っていれば [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-c1fd91cb1911a0512578b99f657554526f3e1421decdb9e908712beab57e10f9R34][config/application.rb]] に設定があるはず。

***** 利用側の設定
      あとは [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-2cb7f9d0c761533d0e2b01e0b7e6f4a34529c7b52f9a13c7493b2629251bccd8R9][todo-app/application.js.es6]] に書いてるように
      この共通コンポーネントを使いたいアプリ側で

      #+begin_src js
      //= require ember-libs/ember-libs
      #+end_src

      としてやるだけでさくっと使えるようになる。

***** 他の type について
      試してないけど mixin や service ぐらいなら同じノリでいけるんじゃないかなと思ってる。
      model もいけそう。
      名前空間が変わるだけだし、その呼び出しも難しくないし、大体なんとかなりそう。

***** 余談: 名前空間を分けない場合

      上のようなやりかたをしているのは、名前空間を分けたいってのが先だったので、
      各アプリで名前空間を分ける必要がなければ、全部のアプリで

      #+begin_src js
      window App = Ember.Application.create()
      #+end_src

      とかしちゃって

      ~ember-libs/components/button.js.es6~ では普通に書く場合と同じように

      #+begin_src js
      App.ButtonComponent = Ember.Component.extend()
      #+end_src

      みたいにしておいて require したら ~{{button}}~ で使える。
      個人的には、名前空間が混ざるとどっちかが上書きされたりしそうで怖くて嫌だけど。

**** ES6 Module 対応版の場合
     最初に答えを出すと
     https://github.com/mugijiru/ember-rails-todo-app/pull/12
     で実装したやつ。

***** コンポーネントの探索
      ES6 Module で書かれている Ember Application では
      基本的に単一の名前空間しか持たないようである。
      また、使用される Resolver が [[https://github.com/ember-cli/ember-resolver/tree/v0.1.21][ember-resolver@0.1.21]] となっている。

      こいつは ~component:ember-libs/button~ と渡って来た時の解釈が GlobalsResolver と異なっている。
      この ember-resolver の場合は、アプリケーションの下の ~components/ember-libs/button~ を探しに行く。

      なのだけど今回はそんなところを探しに行って欲しくないので、
      regsiter を Ember.js で自動的に解決して対応してもらうのではなく
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-029812c538a995224fcf19bfa24f65558246c054aea77c95ec1f4a404b4f5256R1][ember-libs/ember-libs.module.es6]] に書いているように、
      自前で

      #+begin_src js
      application.register()
      #+end_src

      して対応することにした。

***** コンポーネントの register
      基本的には以下のように書いておけば Button コンポーネントは動くようになる。

      #+begin_src js
      import Button from './components/button';

      application.register('component:ember-libs/button', Button);
      #+end_src

      が、コンポーネントが増えていった際に全部そうやって書くのはアホらしい。
      というわけで、自動的に解決するようにした。

***** コンポーネントの auto register

      ES6 Module 対応して import している場合に ember-rails では実際はどんな形に transpile されるかというと
      どうやら requirejs の機能で読み込んだりしているらしい。

      で export されているファイルは ~requirejs.entries~ に含まれているので
      そこから必要なものを探し出して
      ~application.register~ に対し、解釈してほしい名前で渡してクラスを渡しておけば
      template で ~{{ember-libs/button}}~ とした時に require したクラスのインスタンスとして動いてもらえる。

      という感じで自動的に register する処理を [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-029812c538a995224fcf19bfa24f65558246c054aea77c95ec1f4a404b4f5256R4][メソッドにして]] おけば、
      利用側はそれを呼び出すだけでセットアップが済む

***** config.handlebars.templates_root の設定
      やはりこちらの場合も templates を ~ember-libs/templates~ に入れるので
      Rails 側の設定で ~config.handlebars.templates_root~ に ~ember-libs/templates~ を追加するのを忘れずに。
      ember-rails の設定例に従っていれば [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-c1fd91cb1911a0512578b99f657554526f3e1421decdb9e908712beab57e10f9R34][config/application.rb]] に設定があるはず。

***** 利用側の設定
      アプリ側では [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-97468a821d4c12c1b223617fba29257a5b1e00553a1b8e8f403ee99864756ebaR4][initializers/resolve-common-libs に書いている]] ように
      initializer で

      #+begin_src js
      EmberLibs.registerAll()
      #+end_src

      を叩くだけでいい感じに使えるようになる。

***** 他の type について
      試してないけど、component でやってみた所感。

      mixin はどうせ明示的に import して使うので関係なさそう。
      service は、component と同じやりかたでいけそうな気がする。
      model もいけそうなので user model を共通化するような用途がありそう。

      controller もいけそうだけどそれに付随する route からどう呼ばれるかが難しそう。

***** 余談: 他の方法について
      多分 EmberEngine とか EmberAddon の仕組みを使って
      似たようなことはできそうな気はする。

      だけど ember-rails で Engine や Addon を使うというのは
      それはそれでかなり大変かと思われるので今回はそれを動かすようなことはしてない。

      より正確にいうと、
      それしか方法がないかもと思って途中まで調べたけど、
      厳しそうだったので今回は上述の方法にしておいた。

**** 最後に

     旧来版と ES6 Module 対応版とで実装方法は異なるが
     どちらでも同じような使い勝手でコンポーネントを共通ライブラリとすることができることがわかった。

     両方のパターンが使えることがわかったので、
     ES6 Module 対応版への移行がまだでも躊躇せずライブラリを分割できそう。

*** DONE ember-rails でコンポーネントをサブフォルダに配置する :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 11:19]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-component-in-subfolder
    :END:
    Ember.js に限らずコンポーネントは増えてくると
    サブフォルダに分割して管理したくなるよね。
    ということでそのあたりの記事。

    これも、ES6 Module 対応版と旧来版の両方を書く。
    ES6 Module 対応版は何も考えることがないので、
    この記事は旧来版のためにあるようなものだけど。

**** ES6 Module 対応版の場合
     上に書いたように
     これは https://github.com/mugijiru/ember-rails-todo-app/pull/14 に実装してあるけど
     とっても簡単

***** component をサブフォルダに移動
      ~components~ の下に適当なフォルダを掘って
      その中に移動するだけ。

***** template をサブフォルダに移動
      ~templates/components~ の下に適当なフォルダを掘って
      その中に移動するだけ。

***** template からの呼び出し
      template, component をそれぞれ

      - template :: ~templates/components/hoge/fuga.hbs~
      - component :: ~components/hoge/fuga.module.es6~

      と配置した場合は
      ~{{hoge/fuga}}~ と書いて呼び出せばいい感じに動く。以上。

      こういう感じで動くように [[https://github.com/ember-cli/ember-resolver/tree/v0.1.21][ember-resolver@0.1.21]] が作られてるっぽいのでとても楽。

      Ember.js のドキュメントなどを見ている感じだと
      多分もっと新しいバージョンでも同じ感じで動くっぽい。
      というわけで Ember.js@3 にしても多分動きそうなので安心感がある。

**** 旧来版の場合
     これは GlobalsResolver の挙動のおかげでちょっと大変。

     と言っても
     https://github.com/mugijiru/ember-rails-todo-app/pull/15
     で実装してある。

     今回やりたかったことは、
     テンプレートとコンポーネントをサブフォルダに移動して扱えるようにすることなので、
     その実現方法を書いておく

***** template からの呼び出し
      ~{{hoge/fuga}}~ と呼び出した際に [[https://github.com/emberjs/ember.js/tree/v2.18.2/packages/ember-application/lib/system/resolver.js#L34][GlobalsResolver]] でどう解釈されるとかというと
      [[*ember-rails でコンポーネントを共通ライブラリとして切り出す][前の記事]] にも書いたように
      Hoge という名前空間の FugaComponent を探しに行くようになってるというのが前提。

***** component をサブフォルダに移動

      GlobalsRegister の解釈に合わせて
      FugaCompnent を Hoge 名前空間に所属させればいいので

      #+begin_src js
      Hoge.FugaComponent = Ember.Compnent.extend()
      #+end_src

      という形で定義しておけばいい。

      旧来方式だとファイル自体は components の中にあればファイル名も位置も何でもいいはずなので
      人間がわかりやすいように ~components/hoge/fuga.js.es6~ として配置したら良い。

      また、事前に Hoge という名前空間は必要なので
      ~components/hoge.js.es6~ とファイルで

      #+begin_src js
      window.Hoge = Ember.Namespace.create()
      #+end_src

      としておく。

      前回の共通ライブラリ切り出しと大体似たお話ですね。

***** template をサブフォルダに移動
      これは難しいことは何もなくて
      ~templates/components/<名前空間>/<コンポーネント名>.hbs~
      みたいに配置したら良い。

      つまり ~Hoge.FugaComponent~ の場合は
      ~templates/components/hoge/fuga.hbs~
      と置けばいい。

***** さらにネストさせたい場合
      試してないけど、
      [[https://github.com/emberjs/ember.js/blob/e2007b6ecb046fd06f6b43c381e8a1128914ad43/packages/%40ember/application/globals-resolver.js#L221][GlobalsRegister の実装]] を見ている感じだと、多分

      #+begin_src js
      window.Hoge = Ember.Namesupace.create()
      #+end_src

      #+begin_src js
      Hoge.Fuga = Ember.Namesupace.create()
      #+end_src

      #+begin_src js
      Hoge.Fuga.PiyoComponent = Ember.Component.extend()
      #+end_src

      にみたいな感じに名前空間をネストさせれば大丈夫そう。

**** 最後に
     前回の共通ライブラリ切り出しよりは簡単でしたね。

     ES6 Module 対応版では直感的にやるだけで終わるし、
     旧来版でも共通ライブラリと大体やること一緒というか、
     それよりも手順が少ないので、サブフォルダへの移動を先にやった方が良かったかも。

     あと、今回も両パターンでやってるので、
     ES6 Module 移行前にこちらを実施しても簡単な修正で対応できることがわかりました。やったね。

*** DONE ember-rails でユーザー情報を Rails から inject    :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 13:10]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-inject-from-rails
    :END:

    フロントエンドのフレームワークを使っていて、
    そのフレームワークで Server Side Rendering をしてない時に
    API 経由でデータ渡すよりも表示用の HTML 経由で直接データを渡したい時がある。

    ember-rails を使ってる時もそれはあって、
    今回は Haml 経由で Ember.js に情報を渡して表示する方法を書いてみた。
    もちろん旧来版と ES6 Module 対応版の両方で実装している。

**** 旧来版
     https://github.com/mugijiru/ember-rails-todo-app/pull/16 で実装したやつ。


***** おおまかな実装内容
      こちらは名前空間に Ember.js の外からアクセスできるので
      Haml 内に JavaScript を埋め込んで Ember に渡すというちょっと乱暴なことができる。

      今回は email を todo-items テンプレート内で表示したかったので
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/16/files#diff-69c2e4b0a6040f2873e963c79265340fd97c099e1ea1a7fbf579902259126e3fR1][Ember.js の呼び出し元の haml]] 内で

      #+begin_src js
      :javascript
        TodoApp.register('session:current-user', Ember.Object.extend({ email: '#{current_user.email}' }));
        TodoApp.inject('controller:todo-items', 'current-user', 'session:current-user');
      #+end_src

      と書いてみた。

      以下にもう少し詳細に書いてみる。

***** ユーザー情報の登録
      #+begin_src js
      TodoApp.register('session:current-user', Ember.Object.extend({ email: '#{current_user.email}' }));
      #+end_src

      という記述で JavaScript の中に Haml での Ruby のコード呼び出し機能を用いて
      email を EmberObject を継承したクラスにぶち込んでいる。

      正直 ~:javascript~ で書いて Ruby のコードを呼び出すのは結構乱暴だとは思うけど
      できちゃうのでやっちゃった。

***** コントローラへの inject

      アプリケーションに ~session:current-user~ として登録できたので、後はもう

     #+begin_src js
     TodoApp.inject('controller:todo-items', 'current-user', 'session:current-user');
     #+end_src

     として controller に inject することができる。

***** template での表示

      inject された controller の template で ~{{current-user.email}}~ と記述するだけで
      そのユーザーのメアドが表示される。以上。

**** ES6 Module 対応版
     https://github.com/mugijiru/ember-rails-todo-app/pull/17 で実装したやつ。

***** おおまかな実装内容
      こちらは旧来版とは違って名前空間は隠蔽されているため
      Haml で JavaScript を書いて埋め込むなんて荒技はできない。

      だけどまあそんなことをしなくても
      data 属性に情報を埋めておいて
      それを initializer で取得して使えばいいだけである。

***** Haml へのデータ埋め込み
      Haml の方では

      #+begin_src haml
      #todo-app{ data: { email: current_user.email } }
      #+end_src

      こんな感じにデータを埋めておく。
      それを Ember.js の initializer で取得して処理してあげれば良い。

***** initializer でのデータの取得
      まずはデータを

      #+begin_src js
      const currentUser = Ember.Object.extend({
        email: document.querySelector(application.rootElement).dataset.email
      });
      #+end_src

      という感じで取得して適当な変数に放り込んでおく。
      ま、大体普通の JavaScript なので何も難しいことはない。

***** アプリケーションへの登録
      上で取得したデータをアプリケーションから見れるように登録してあげる必要があるので
      以下のように ~application.register()~ でデータを登録する。

      #+begin_src js
      application.register('session:current-user', currentUser);
      #+end_src

***** controller への inject
      上に書いた感じで application に登録してしまえば、後は旧来版と同じように

      #+begin_src js
      application.inject('controller:todo-items', 'current-user', 'session:current-user');
      #+end_src

      という感じで設定できる。

***** template での表示
      あとは旧来版と同じく
      inject された controller の template で ~{{current-user.email}}~ と記述するだけで
      そのユーザーのメアドが表示されると。うん、簡単でしたね。

**** 最後に
     API を経由せずに Ember.js にデータを渡す方法が
     旧来版と ES6 Module 対応版の両方で書けることがわかったので、
     旧来版から移行しようとした時もすぐ書き直せそうで安心。

     ES6 Module 対応版の方は、
     ember-rails から ember-cli-rails とかに乗り換えてもそのまま使えそうだしね。

*** DONE ember-rails から ember-cli-rails へ               :@Rails:@Ember_js:
    CLOSED: [2021-03-06 土 17:05]
    :PROPERTIES:
    :EXPORT_FILE_NAME: migrate-ember-rails-to-ember-cli-rails
    :END:

    Ember.js 関係で最も書きたかった記事にやっと辿り着いた。
    表題の通りで、
    ember-rails から ember-cli-rails に置き換える、という記事です。
    多分長くなる。

    やったことはいつも通り [[https://github.com/mugijiru/ember-rails-todo-app/pull/18][GitHub の PR]] にしています。

    PR の Description で「Rails 側ではこうした」「Ember 側ではこうした」みたいに書いているので
    ここではある程度時系列に沿ったような書き方にしようかな。

    完全に時系列通りには書かないので、
    正確な時系列でどうしたか知りたかったら PR のコミットログを追ってください

**** アプリの前提

     これまで作って来た https://github.com/mugijiru/ember-rails-todo-app が前提になります。
     ざっくり内容を書くと

     - ember-rails で Ember.js 2.18 の環境を動かしている
     - Sprockets での ES6 Module 対応済
     - 現実世界の複雑さを持ち込むために敢えて以下の手法を導入
       - Embedded Ember App
       - Multiple で動かせる構成
       - 一部コンポーネントの共通ライブラリ化
         - ember-libs という名前で別フォルダに切り出している
       - Bootstrap の利用
     - 複雑さでは以下もありうるが面倒などの理由でやってない
       - i18n.js での多言語対応
       - コンポーネント以外の共通ライブラリ化

     という感じ。

**** ember-rails 用の JS のコードが読まれないようにコメントアウト
     https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/8dd44540bd7d352e497f87a9a12df5ad3cf6efbb
     のあたりのコミット。

     本当は後からやった手順だけど、
     ここで読まれてるコードが邪魔になるので
     先にコメントアウトしておく方が後の手順でハマらなくて済むので
     ここに置いといた。

     まあ実は ember-cli-rails のアプリが読まれるところで
     ember-rails が require されてなければいいだけなので
     application.js で require_tree とかをしなければ良かったりはする。

**** Docker 環境への ember-cli の導入
     Docker でアプリが動くようにしているので、
     ember-cli も Docker で動くようにしている。

***** Docker で最新 LTS の Node.js が使われるように設定

      ember-cli と直接は関係ないけど、Node.js は入れる必要があるのでやってる手順。

      とりあえず最新の LTS を入れておく。
      Ubuntu で普通に apt から入れると 10 系が入っちゃうので
      yarn の apt リポジトリを登録してそこからインストールする。

      #+begin_src Dockerfile
      RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \
      && echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list

      RUN apt-get update -qq && apt-get install -y nodejs yarn
      #+end_src

***** ember-cli を Global に導入

      ember-rails で動いているアプリは Ember.js 2.18.2 で動いているので
      ember-cli も 2.18.2 を導入する。

      #+begin_src Dockerfile
      RUN yarn global add ember-cli@2.18.2
      #+end_src

**** アプリの初期構築

     上記手順で導入した ember-cli を使って改めて Ember.js アプリを構築する。
     ゼロから作っておく方が、より ember-cli-rails に向いた形になるとの判断。

***** ember-cli で移植先のアプリの雛形を構築

      ~RAILS_ROOT/ember/todo-app~ に構築する。

      ember-cli-rails の README だと ~RAILS_ROOT/frontend~ に構築するように書かれているが、
      複数の Ember.js アプリを平等に扱える形にしたいのと
      Ember.js アプリのコード置場を ~RAILS_ROOT/frontend~ にしていると
      Ember.js から別のフレームワークに差し替えが決まって、その移行作業をしている間に

      - frontend に新しいフレームワークで構築しようと思ったら既に Ember.js がいた
      - 新しいフレームワークでの実装を修正しようと思って frontend 以下を探していて時間を潰した

      ということが起こりそうなので、フレームワーク名は明示しておきたいお気持ち。
      というわけで ~ember~ というフォルダの下に更にフォルダを掘っているが、
      この考え方、あまり合意を得られた試しはない。みんな移行は発生しないつもりなのかな。

      ま、とりあえず以下のコマンドを実行したら ~RAILS_ROOT/ember/todo-app~ に雛形が作成される。

      #+begin_example
      $ ember new todo-app --no-welcome --skip-git --yarn --dir ember/todo-app
      #+end_example

      なお、面倒なので ~docker-compose run~ とかは省略している。
      ここより下の部分でも同様に省略しているので、
      そのあたりは読みながら脳内で補完とかしてください。

****** オプションについて
       - ~--no-welcome~ :: どうせ後で消すファイルが作られるだけなので出す必要なし
       - ~--skip-git~ :: Rails アプリと同じリポジトリに作るので git init は不要
       - ~--yarn~ :: yarn を使い慣れてるからそれを指定。ただ ~yarn link~ に問題があるから ~npm~ を使う方がいいかも?
       - ~--dir ember/todo-app~ :: ember というフォルダの中に構築するので指定する必要あり

***** ember-cli-rails-addon の導入

      ember-cli-rails と連携して ember-cli app を動かす時には
      ember-cli app 側に [[https://github.com/rondale-sc/ember-cli-rails-addon][ember-cli-rails-addon]] を入れておく必要があるので、
      早い段階で追加しておく

      #+begin_example
      $ cd ember/todo-app && ember install ember-cli-rails-addon
      #+end_example

      これを入れておくと CSRF Token のことを意識しないで済むし、
      ファイルを更新するだけで Rails から読めるように Ember.js app を build してくれたりする。
      というか、入れてないとそれらがうまく動かなくてハマる。

***** active-model-adapter の導入

      [[https://github.com/ember-data/active-model-adapter][active-model-adapter]] は
      ActiveModelSerializer の出力をいい感じに Ember.js で扱えるようにする Addon で
      ember-rails でも使われている。

      というわけでこいつも Rails でいい感じに Ember.js を使うためには必要なので先に入れておく

      #+begin_example
      $ cd ember/todo-app && ember install active-model-adapter
      #+end_example

**** ember-cli-rails の導入と設定

     ここは Rails 側の作業。
     ひとまず ember-cli-rails の導入に留め、
     ember-rails は一旦そのままにしておく。

***** ember-cli-rails の導入
      これは単に Gemfile に記載して ~bundle install~ を叩くだけである

      #+begin_src ruby
      gem 'ember-cli-rails'
      #+end_src

      #+begin_example
      $ bundle
      #+end_example

***** config/initializers/ember.rb で ember-rails の設定

      ember-cli-rails で generate コマンドが用意されているので
      まずはそれでファイルを生成する

      #+begin_example
      $ rails generate ember:init
      #+end_example

      これで ~config/initializers/ember.rb~ が作られるの。
      初期状態は以下の通り。

      #+begin_src ruby
      EmberCli.configure do |c|
        c.app :frontend
      end
      #+end_src

      それに変更を加えて、以下のようにする

      #+begin_src ruby
      EmberCli.configure do |c|
        c.app :todo_app, name: 'todo-app', path: Rails.root.join('ember', 'todo-app'), yarn: true
      end
      #+end_src

****** 引数について
       - 第一引数 :: あとで mount する時に使う値
       - name :: ハイフン繋ぎにしたかったので指定しているが、多分なんでもいい
       - path :: ~ember/todo-app~ に構築しているのでそれを見てもらえるように指定
       - yarn :: yarn を使い慣れてるので指定。ただ yarn link がうまく動かないのでやめた方がいいかも

***** config/routes.rb で Ember.js App を Mount

      Embedded Ember.js App というわけで
      Controller を自前で用意するので、contoller としてそれを指定する。

      #+begin_src ruby
      mount_ember_app :todo_app, to: '/ember_cli_todo_items', controller: 'ember_cli_todo_items', action: 'index'
      #+end_src

***** Controller 等の用意
      移植途中で元のアプリに戻せなくなるのは移行失敗時のリカバリを考えると嫌なのと
      元の挙動を確認したくなった時のために
      元の PATH で動く状態にすぐ戻せるようにしておきたい。
      というわけで別の PATH を用意して、ember-cli で構築したアプリはそこで動くようにする。

      #+begin_example
      $ rails g controller ember_cli_todo_items index
      #+end_example

      あとは ember-rails 実装での Controller, View を参考にしたりして以下の感じに。

****** Controller
       特にサーバから何かを View に渡す必要はないので基本的に空っぽ。

       #+begin_src ruby
       class EmberCliTodoItemsController < ApplicationController
         def index
         end
       end
       #+end_src

****** View
       rootElement を用意して、そこに initializer に渡す data 属性を置いておく。

       さらに ember-cli で生成する JS/CSS が読まれるように設定する。
       (今回 CSS は書かないけど……)

       #+begin_src haml
       #ember-cli-todo-app{ data: { email: current_user.email } }

       %base{ href: '/ember_cli_todo_items/' }
       = include_ember_script_tags :todo_app
       = include_ember_stylesheet_tags :todo_app
       #+end_src

       ~%base~ は Ember.js のアプリケーションを動かす PATH に合わせる必要があるのと
       最後の ~/~ が抜けていると script や stylesheet で正しく PATH 解決できないので注意。

       [[https://github.com/seanpdoyle/ember-cli-rails-assets][ember-cli-rails-assets]] の README を見ていると
       include_ember_script_tags とかに追加の引数で
       ~prepend: '/ember_cli_todo_items/'~ とか書いていれば ~%base~ は使わなくて良さそうだけど
       まだ試してはいない

**** ember-cli で作ったアプリが Rails 上で動くようにする
     Rails 側の設定はここまでで完了しているはずなので
     次は ember-cli 側の設定を進めて Rails 上で動くようにしていく。

***** config/environement.js の設定
      まず config/environment.js で以下を指定している

      #+begin_src js
      modulePrefix: 'todo-app',
      rootURL: '/',
      locationType: 'hash',
      #+end_src

      rootURL は ember-cli-rails の README 通りに設定していると
      ~/ember_cli_todo_app~ になりそうだが
      それを指定すると Ember.js App が読まれた時に URL が
      ~http://localhost:3000/ember_cli_todo_app/ember_cli_todo_app~ というように
      ~ember_cli_todo_app~ が二重に表示されてしまう。

      ちゃんと調べられていないが、恐らく README の記載では SPA として Ember が動く想定であって、
      ~include_ember_script_tags~ で読み込まれる Embedded App という想定ではないからと思われる。

      locationType は多分 hash にしておく方が
      ember-rails からの移行だと URL が変わらなくて良さそう、
      と思いつつ、深い PATH とかにしてないからか検証はできてない

***** app.js の設定
      あとは app.js の方でも config/environemt から読むようにしたり
      rootElement を指定したりしている。

      rootElement は config/environment で指定して、
      app.js ではそれを利用するのが正しい気はするが、一旦放置。

      #+begin_src js
      const TodoApp = Application.extend({
        rootElement: '#todo-app',
        modulePrefix: config.modulePrefix,
        podModulePrefix: config.podModulePrefix,
        locationType: config.locationType,
        rootUrl: config.rootUrl,
        Resolver
      });
      #+end_src

**** アプリの移植

     これまでの手順ではとりあえず ember-cli で構築した空っぽの Ember.js アプリが
     Rails の指定した PATH 上でとりあえず動くことを主眼に当ててやってきている。

     ここからはようやく、既存アプリの実装の移植。
     いくつかの段階に分かれるから、ここからも長いんだけどね。

***** 共通化してない機能のみで起動するようにする
      ember-libs というフォルダに切り出している部分までまとめて対応しようとすると
      えらく面倒なので、
      そのあたりを呼び出している部分はコメントアウトなどで呼び出されないようにして、
      とりあえず最低限の表示がされる程度を目指して移植するフェーズ。

      やってることは
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/3c31b5bcf86d68ac5db0eca9bb4af410df31c2f1
      のコミットが全てである。

      ざっくり説明すると

      - ember-rails で作っていた adapter, component, controller, initializer, model, route, template 等を ember-cli で作ったアプリの適切なディレクトリに配置
        - router.js は ember-cli 自動生成の雛形に必要な部分だけ移植している
        - adapter は ActiveModelAdapter を active-model-adapter addon から import するように変更している
      - 共通ライブラリに持って行った component の呼び出し部分をコメントアウト

      という感じ。
      これをすることで、不完全ながらも元のアプリと同じものが動くようになる

      ちなみにもっと複雑なアプリだと mixin を使っていたりなどするが
      それもテキトーに読み込まれないようにするなどで対処したらなんとなーく動く感じになるはず。なんとなーく。

      そうそう。ember-cli 対応することで各ファイルの単体テストなんかを書けるようになってるはずだけど
      元々そんなものを書いてないので、今回もそこまで頑張る必要はないと判断して
      フロントエンドのテストは一切書いていません。自動生成されたファイルはそのまま追加しているけど。

      一応、動作保証は system spec である程度担保しているつもり。
      ember-rails の時はそこでしか保証してないしね。

***** 共通ライブラリの Addon 化

      上までの段階だと共通ライブラリにした部分が全然動かないので、
      当然それを動く状態に持って行く必要がある。

      で、その際には、共通ライブラリを addon として構築し直すことをオススメする。
      なぜなら、なんか無理やり自前の仕組みで動くようにするより
      公式に提供されてる仕組みに乗っかる方が後々楽そうだからだ。

      ember-rails で動かしていた時に自前で解決していたのは
      ember-rails だと addon がサポートされてないからというだけの理由だしね。

      Addon 化の手順は大体以下の感じ

      1. ember-cli で Addon を generate
      2. 共通ライブラリのコンポーネントを Addon に移植
         - もし共通ライブラリに mixin とかも作っていたら同様に移植すること
      3. Addon をアプリ側で使えるように変更

      なお今回の手順では App と同様に Addon のテストを書く、みたいな丁寧な暮らしはしていない。
      元々書いてないんだし、そこまで頑張る必要もないという判断。

      あとやってることは [[https://cli.emberjs.com/release/writing-addons/intro-tutorial/][Addon 作成のチュートリアル]] に書いていることをベースにしている

****** ember-cli で Addon を generate
       https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/4d6713abfbed3217d65f7382e1f46d341c11d6aa
       でやっていることである

       #+begin_example
       $ cd ember && ember addon my-components --skip-git --yarn
       #+end_example

       というように適当な名前の Addon を作ってるだけ。

****** 共通ライブラリのコンポーネントを Addon に移植
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/cde30b30727d6eb9507b835d009d85759ddff5ee
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/4ad2f8a59ccc846a63e6ff31c8f8b53df81d8e42
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/30439f21f0659044bb4d2ea80ce68a2f8e0011b7

       あたりでやってる作業。

       実際の作業では1つ目を移植してみた段階で、
       動作確認のためにアプリ側で Addon が使えるように設定していたりする。

       ちなみに ember の addon は
       app/components のファイルから addon/components のファイルを import してやるみたいなお作法がある。

****** Addon をアプリ側で使えるように変更
       まずは上の手順で作った my-components という addon を
       App 側で読み込めるように package.json の dependencies に以下を書き加える

       #+begin_src json
       "my-components": "link:../my-components"
       #+end_src

       ember-cli の公式ドキュメントだと
       「yarn link を使う」というように書いているが
       それだとうまくいかないみたいな Issue が何個か立っているので
       ドキュメント通りのやりかたは諦めて、それらの Issue の中に書かれている方法を選択した。

       npm link だとうまくいきそうな雰囲気もあるので
       yarn を使わず npm link にしておけばいい可能性はある。未検証。

       まあそれらは置いといて、とにかく Addon が使える状態になったら
       各コンポーネントでコメントアウトとかで読めなくしていた
       共通ライブラリの呼び出しを元に戻したり記述を直したりして、
       元のように動くようにしましょう。

***** ember-bootstrap の導入と bootstrap を使った機能を移植
      ここまでやって、麦汁さんは「わーい動いた〜」と思っていたけど
      ボタンとかをクリックしてみると、Bootstrap 関係のやつが動かない。

      そう。元の記述のままだと Bootstrap 関係のやつはメソッド呼び出しでエラーになって動かないのです。
      というわけでそれらも動くようにしないといけない。

      というところで、どうやるのが手っ取り早いかというと
      [[https://github.com/kaliber5/ember-bootstrap][ember-bootstrap]] という Addon が転がっているので
      それをインストールして使うように変更するのが多分手っ取り早い。

****** ember-boostrap のインストール・初期設定
       最新版は ember-cli-rails@2.18.2 をサポートしていないので3系を使う必要がある。

       #+begin_example
       $ cd ember/todo-app && ember install ember-bootstrap@3.1.4
       #+end_example

       その上で、元々使っている Bootstrap のバージョンに合わせて
       ember-bootstrap でも3系が使われるように設定する。

       #+begin_example
       $ cd ember/todo-app && ember generate ember-bootstrap --bootstrap-version=3
       #+end_example

****** Bootstrap を使ってる機能の移植
       https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/22a3bff502ce993c2f2288623b061a4f38652a29
       でやっていることである。

       基本的には、自前で bootstrap 用に DOM を組み立てていたところを
       ember-bootstrap の Modal コンポーネント用に書き換えて、
       開いたりするための挙動を修正するだけである。

       ember-boostrap の公式ドキュメントでは Handlebars の書き方が
       ~<BsModal>~ みたいになっていて
       3.4 以降でサポートされた Angle Bracket 方式の表記になっているが、
       ~<>~ は ~{{}}~ に置き換えて
       PascalCase を snake-cake にしたりするぐらいで動くので、
       落ち着いて移植しよう。

***** 既存の system spec が新しい PATH で動くことを確認
      ここまでやると、全機能を手動で確認できる状態になってるので
      既存の system spec がアクセスするポイントを
      新しく作ったアプリの方に変更しテストが通ることを確認すると、
      ちゃんと移植できたんだなって安心できる

      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/0c59057ec458edb7cda0febd15585dfc0a916bc1

**** 元の PATH で動くようにする
***** 元の PATH への再移植
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/334ce5052564a1499de03fb5a6630af3a339af21
      でやっていること。

      1. EmberCliTodoItemsController と TodoItemsController に移植
      2. app/views/ember_cli_todo_items/index.html.haml を app/views/todo_items/index.html.haml に移植
         - rootElement に使う ID も ~todo-app~ に変更
         - ~%base~ の href 属性も ~/todo_items/~ に変更
      3. resources :ember_cli_todo_items を削除
         - 同時に controller, view も消す
      4. mount_ember_app で ~to~ と ~controller~ の指定を変更
         - ~to~ を ~/todo_items~ に変更
         - ~controller~ を ~todo_items~ に変更
      5. Ember.js 側で rootElement を ~#todo-app~ にする

***** テストの PATH を戻す
      これは
      [[*既存の system spec が新しい PATH で動くことを確認][既存の system spec が新しい PATH で動くことを確認]] でやったことを revert して
      テストが通ることを確認したら OK
**** ember-rails 関連の削除
***** ember-rails 用のコードの削除
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/138ac7b8a76ec0f299edb2d626c9252927647229
      でやってるように
      app/assets/javascripts の下にある
      ember-rails 関連のコードを全部消すだけ。

***** ember-rails 用の設定を削除
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/9e036017b7ebee1a84b6f6847d5079a61ca5177c
      でやってるように

      - ~config/application.rb~
      - ~config/initializers/assets.rb~

      の中に ember-rails のために書いた設定を丸っと消しましょう。もう不要なので。

***** ember-rails 及びその関連 Gem と決別
      設定も消せたら ember-rails, ember-source も要らないので
      さっくり Gemfile から消して bundle install し直しましょう。イエイ。

**** GitHub Actions の修正
     あとはやり残しとしては
     CI でもちゃんとテストが通るようにすること。

     このプロジェクトでは GitHub Actions を使ってるので
     そのワークフローを修正する

***** 最新 LTS の Node.js を使うようにする
      Dockerfile のところでもやりましたね。同じようなことをしましょう。
      とは言っても setup-node という action が公式に提供されているし
      [[https://docs.github.com/ja/actions/guides/building-and-testing-nodejs][公式ドキュメント]] もあるので、それに従って設定するだけで使えるようになる。

      #+begin_src yaml
      - name: Use Node.js
        uses: actions/setup-node@v1
        with:
          node-version: 14.x
      #+end_src

***** ember-cli をインストール

      これも似たようなことを Dockerfile でやってるので同じ感じに。

      #+begin_src yaml
      - name: install ember-cli
        run: yarn global add ember-cli
      #+end_src

***** Ember Addon 及び Ember App で yarn install

      こちらも依存を解決してやる必要があるので。

      #+begin_src yaml
      - name: Setup Ember.js Addon
        run: |
          cd ember/my-components
          yarn
      - name: Setup Ember.js App
        run: |
          cd ember/todo-app
          yarn
      #+end_src

      ここまでやると
      GitHub Actions でもテストが通るし
      普通に使えるようになる。やったね。

**** 最後に

     以上の手順で ember-rails から ember-cli-rails への置き換えができます。

     現実世界のアプリケーションはこのケースよりもっと複雑でしょうけども、
     やってやれないことはないはず。

     それに ember-cli が使えるようにしておかないと
     3系に移行ができないし、つまり、サポート切れのフレームワークを使い続けることになるので
     もしまだ ember-rails のアプリが残っていたら頑張ってやっていきましょ。
     別フレームワークに置き換えるよりは労力はかからないはずですし。

*** DONE Ember.js の共通コンポーネントの NPM への分離      :@Rails:@Ember_js:
    CLOSED: [2021-03-24 水 13:04]
    :PROPERTIES:
    :EXPORT_FILE_NAME: my-ember-libs-to-npm
    :END:

    相変わらず Rails における Ember.js 関連で遊んでいます。

    今回の記事で書くのは
    「Ember.js Addon を別リポジトリに分離して NPM パッケージにして利用する」
    なんだけど、
    後追いで出す「分離したリポジトリを Gem としても使えるようにし ember-rails 環境で動かす」
    という感じに記事の前振りです。

    本当は1つの記事にしたかったけど記述量が増えたから分割……。

**** 目的

     なんでこんなことをしているかというと
     「単一ソースで ember-cli にも ember-rails にも対応したい」
     「じゃあ NPM と Gem で公開してインスコしたらいいんじゃね」
     という考えから。

     というのも、
     この一連の記事は ember-rails から ember-cli-rails に
     徐々に移行していく手段を確立することが目的なので、
     1つの Rails の中に複数の Ember.js アプリがあって
     ember-rails と ember-cli-rails が混在している状況も有り得るかなあと。

     そういう時に、
     共通コンポーネントは単一ソースで使いたいよね〜と思って
     両対応ができるようにしてみている。

     まあ今回は ember-cli-rails だけの対応なんだけども。

**** 実践

     ember-cli-rails に移行した時に
     元々 ~RAILS_ROOT/app/assets/javascripts/ember-libs~ というところに
     共通コンポーネントとして置いていたファイル群を
     ~RAILS_ROOT/ember/my-components~ というところに
     Ember.js のアドオンという形で設置していました。

     正直そのままの方が、同一リポジトリなので改修とかしやすいんだけど
     「他のプロジェクトでも使いたい」
     といった時には分離も必要になるかなと。
     まあ今回の目的は別のところにあるけども。

***** 従来の実装を ember-components に移植

      https://github.com/mugijiru/ember-components/commit/847981e9732385d08db4f5f703813196622b80d2

      でやっていること。

      基本的には、元々のソースを addons 以下に置いているだけ。
      なんとなく、コンポーネントの prefix を my- から mg- に変えてるけど。

      あとは ember-cli-htmlbars を dependencies にも移動する必要あり。

      https://github.com/mugijiru/ember-components/commit/922d1f7ed5f6b3372b1d1551792f4e9739f5b1e3

      他にも [[https://github.com/mugijiru/ember-components/commit/30b3257227dab623c86dedfab032b85f32414e42][Docker で動かせるようにしたり]]
      [[https://github.com/mugijiru/ember-components/commit/34e81e2905e32dd2878b95fb9d5c7eb3b3a0b463][GitHub Actions でテストできるようにしたり]]
      ちょっと細かい修正をしたりしている。

      ここまでの差分は
      https://github.com/mugijiru/ember-components/compare/bbaf38aa0f6c99ebbc7e0cb7ee5ac2c201706bc6...34e81e2905e32dd2878b95fb9d5c7eb3b3a0b463
      で確認可能。

***** GitHub Packages の NPM Package の公開

      まず [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#publishing-a-package][パッケージを公開する]] に従って以下の変更をしている。

      パッケージ名を ~@mugijiru/ember-components~ にしたり、

      #+begin_src json
        "name": "@mugijiru/ember-components",
      #+end_src

      publishConfig の registry に GitHub Packages の URL を入れることでそこで公開できるようにしている。

      #+begin_src json
        "publishConfig": {
          "access": "restricted",
          "registry": "https://npm.pkg.github.com"
        },
      #+end_src

      access は GitHub 側の記載は何もないが
      https://tech.plaid.co.jp/npm-private-registry-to-github-packages-registry/
      を参考にして restricted にすることで、許可された人だけが使えるようにしている。

      今は公開リポジトリにしているから public でもいい気もするけど、
      実装当時はより業務でやりそうな雰囲気にしたかったので、
      非公開リポジトリかつ限定的な公開で進めていたので、このようになっている。

      さらに、今後 GitHub Packages に複数パッケージ公開するかもしれないので
      [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#publishing-multiple-packages-to-the-same-repository][同じリポジトリへの複数パッケージの公開]] に従って registory を指定したりしている

      #+begin_src json
        "repository": "git://github.com/mugijiru/ember-components.git",
      #+end_src

      その上で
      https://github.com/mugijiru/ember-components/blob/main/.github/workflows/release.yml
      のようなワークフローを用意すると
      Tag を打って push して
      GitHub 上でそのタグを使って Release を作成すると
      NPM Package として公開されるようになっている。

      上にも出した https://tech.plaid.co.jp/npm-private-registry-to-github-packages-registry/ を真似すると
      もっとスマートな感じになりそうだけど、一旦これでいいやってなってる。

***** 公開したパッケージを利用する

      https://github.com/mugijiru/ember-rails-todo-app/pull/48 の PR でやったこと。

      元々は ~RAILS_ROOT/ember/my-components~ に置いていたやつを NPM Package にしているので
      my-components 関連のやつをさっくり消してあげている。

      具体的には ~ember/my-components~ は全部消して
      package.json の devDependencies に入れていた
      ~"my-components": "link:../my-components"~ を削除している。

      今思ったけどこれ devDependencies だと多分 production 環境だと動かなかったな。
      まあ 2.18 なので公開する気がゼロだったからすっかり気付かなかったんだけど。

      まあそれは置いといて
      公開したパッケージを入れるため dependencies に以下のように記述する。

      #+begin_src json
        "dependencies": {
          "@mugijiru/ember-components": "^0.0.1"
        },
      #+end_src

      あとはプライベートなパッケージを入れられるように
      ~RAILS_ROOT/ember/todo-app/.npmrc~ に以下のような設定を入れている。

      #+begin_example
      @mugijiru:registry=https://npm.pkg.github.com
      #+end_example

      この設定は [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#installing-a-package][パッケージをインストールする]] の通りだとなんかうまく動かなかったので
      [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#installing-packages-from-other-organizations][他のOrganizationからのパッケージのインストール]] のやり方を採用している。
      あとでまた検証した方がいいかもなあ。。。

      それと [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages][GitHub Packages への認証を行う]] に従って

      #+begin_example
      //npm.pkg.github.com/:_authToken=${NPM_TOKEN}
      #+end_example

      としている。
      NPM_TOKEN には GitHub のパーソナルアクセストークンが入るので環境変数にしている。

      なので GitHub Actions で CI を回す際のパッケージのインストール時に

      #+begin_src yaml
      env:
        NPM_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
      #+end_src

      みたいに環境変数に PAT を入れてあげる必要あり。

      他には、これまた公開したパッケージを使う上で本質的ではないんだけど、
      移植した際に ~my-button~ から ~mg-button~ みたいに全部
      ~my-~ prefix だったのを ~mg-~ prefix にしているので
      利用箇所でそれらの修正の必要あり。
      命名を適当にやってたのでここでそれが仇になってる。つらい。

      以上で GitHub Packages に NPM として公開した Ember.js の Addon を
      ember-cli-rails で使えるようになりますよっと。
      正直 NPM とかに慣れてる人ならさっくりできそうな内容。。。

      まあ Ember.js の Addon も実際は NPM Package なので
      普通に NPM Package として公開するだけで使えたりするってだけですね。
      .ember-cli-build.js を活用したらまたちょっと話は違うはずだけど
      今回のはそこまでのやつじゃないし……。

*** DONE 自作の Ember.js Addon を ember-rails 用に無理やり Gem 化した :@Rails:@Ember_js:
    CLOSED: [2021-03-26 金 01:49]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-components-addon-as-gem
    :END:

    [[*Ember.js の共通コンポーネントの NPM への分離][前回の記事]] で Ember.js の共通コンポーネントを詰めた Addon を
    NPM package にしたわけですが、
    今度はそいつを割と無理やり Gem 化して
    ember-rails でも使えるようにしたよ、というお話です。

**** 目的
     Ember.js の Addon として切り出した共通コンポーネントを
     同一ソースで ember-rails でも使いたいな〜、使えるようにしたいな〜、という目的。

     ほら。
     ember-rails で1つの Rails アプリケーションの上に
     複数の Ember.js アプリを動かしていて
     一部ずつ ember-cli-rails 移行を進めていたら
     どうしても混ざる時期あるじゃないですか。

     そういう時に共通コンポーネントは同一ソースで両方で動かせると多分便利じゃないですか。

**** ember-components の Gem 化

     Gem にして ember-rails でも使えるようにするために色々やりました。
     こんなにやらないといけないのかってぐらいやった気がします。。。

***** Component の書き方を古い方式に戻した

      ember-rails だとどうも

      #+begin_src js
      import Component from '@ember/component'

      export default Component.extend({})
      #+end_src

      という書き方だと読み込んでくれないようなので
      全部以下のように書き換えている。

      #+begin_src js
      import Ember from 'ember

      export default Ember.Component.extend({})
      #+end_src

      で、この変更を加えると eslint に怒られるので
      新しい記述を要求する eslint のルールをオフにしてあげる必要がある。悲しい。

      #+begin_src js
        rules: {
          'ember/new-module-imports': 'off'
        },
      #+end_src

***** components を ember-rails で読み込めるようにする

      ember-libs というフォルダに共通コンポーネントとして分割した時も同じようなことをしたんだけど
      ember-rails に components を読み込ませるためのコードを
      このリポジトリに用意してある。

      [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/lib/ember/components/templates/ember-components.js][lib/ember/components/templates/ember-components.js]]

      やってることは、
      requirejs で読み込まれてるファイルを調べて component を見つけ次第
      ~application.register~ するだけのコードである。
      このコードは後で利用側から実行されるようにする。

***** addon 以下のファイルを vendor/assets 以下にコピー、変更する Raketask 作成

      ここでやってることは

      - 上で用意した ember-rails に読み込ませるためのコードをコピー。
      - Rails が読んでくれるところにファイルを置きたいのでaddon 以下のファイルを vendor/assets/javascripts 以下にコピー
      - ember-rails で module として読み込んでほしいので拡張子を ~.module.es6~ に変更
      - ~import layout~ などの Addon 用記述があるとエラーになるのでそれらの記述を強制排除

      となっている。

      後者2つは実装都合上、まとめてやっている

****** ファイルのコピー

       addon 以下に入っていても Rails 的には通常読み込めないので
       ~vendor/assets/javascripts~ 以下にファイルをコピーしてあげている。
       あと上の手順で作った ember-rails に読み込ませるためのコードもコピーしている。

       https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/Rakefile#L14-L18
       #+begin_src ruby
         path = 'vendor/assets/javascripts/ember-components'
         FileUtils.mkdir_p(path)
         FileUtils.cp('lib/ember/components/templates/ember-components.js', "#{path}.module.es6")
         FileUtils.cp_r('addon/templates', path)
         FileUtils.cp_r('addon/components', path)
       #+end_src

       多分 ~app/assets/javascripts~ 以下でもいいんだろう。
       というかそっちの方が良さそうな気もするけど、
       ~app~ は Ember.js 側で使っているので、それと混ざると嫌だなということで避けている。

****** addon 用の記述削除 & 拡張子の変更

       component に関しては addon での component 作成のお作法に従い
       ~import layout~ とか書いているけど
       ember-rails ではその記述はむしろ不要になるというか
       hbs を import できない問題が発生するので
       それらの行を強制的に削除する処理を入れている。

       また、それと同時に ember-rails で ES6 module として読み込めるように
       拡張子を ~.module.es6~ にしている。

       方法としては、ファイルを ~.js~ から ~.module.es6~ にコピーしつつ不要な行を消して
       それが済んだら ~.js~ ファイルを消すという手法を取ってる。
       結構、無理やり感がある。

       https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/Rakefile#L19-L33
       #+begin_src ruby
       Dir["#{path}/components/*.js"].each do |file_path|
         File.open(file_path, 'r')
         basename = File.basename(file_path, '.js')
         File.open("#{path}/components/#{basename}.module.es6", 'w') do |write_f|
           File.open(file_path, 'r') do |read_f|
             read_f.each do |line|
               next if line =~ /^\s*import layout/
               next if line =~ /^\s*layout,/

               write_f.puts line
             end
           end
         end
       end
       FileUtils.rm(Dir.glob("#{path}/components/*.js"))
       #+end_src

***** Rails Engine 化

      Rails Engine として組み込んで使えるように
      ~lib~ 以下にちょろちょろコードを書いている。

      - [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/lib/ember/components.rb][lib/ember/components.rb]]
      - [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/lib/ember/components/version.rb][lib/ember/components/version.rb]]
      - [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/lib/ember/components/engine.rb][lib/ember/components/engine.rb]]

      ほとんど「Rails Engine のお作法」ってだけのコードだけど
      上に書いたファイルをコピーしたりする時の
      PATH を取得するための便利メソッドとして以下を生やしている。

      #+begin_src ruby
      def self.root
        Pathname(__FILE__).join('../../..')
      end
      #+end_src

***** gemspec 修正

      Gem として GitHub Packages に登録するので当然 .gemspec ファイルを用意している。
      [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/ember-components.gemspec][ember-components.gemspec]]

      一応 GitHub Packages に出すためのお作法として

      #+begin_src ruby
      spec.metadata["allowed_push_host"] = "https://rubygems.pkg.github.com"
      #+end_src

      というように push できるホストをしていしたり

      #+begin_src ruby
      spec.metadata["github_repo"] = "ssh://github.com/mugijiru/ember-components.git"
      spec.metadata["git_repo"] = "ssh://github.com/mugijiru/ember-components.git"
      #+end_src

      というようにリポジトリを指定していたりする。

      [[https://docs.github.com/ja/packages/guides/configuring-rubygems-for-use-with-github-packages#publishing-multiple-packages-to-the-same-repository][同じリポジトリへの複数パッケージ公開]] の記述を読む限り
      github_repo だけ指定あれば良さそうな気もするが
      git_repo があっても特に害もないだろうということでとりあえず入れている。

      あとは gem に含めたいファイルとして

      #+begin_src ruby
      spec.files = Dir[
        'lib/**/*',
        'vendor/**/*',
        'README.md',
        'LICENSE.md'
      ]
      #+end_src

      としている。
      lib 以下は Rails Engine として組込むために必要だし
      vendor 以下には ember-rails で読み込める形に変換したファイルがあるので
      gem に含める必要がある。

***** GitHub Actions での Gem 登録

      [[*Ember.js の共通コンポーネントの NPM への分離][NPM Package にした時]] と同様に
      Tag を打ってそれからリリースを作ったら Gem が登録されるように
      GitHub Actions を設定している。

****** Gem の build

       publish する前に以下のようにして Rake Task を実行している。

       #+begin_src yaml
       - name: Build gem
         run: |
           bundle exec rake clean_assets generate_assets build
       #+end_src

       clean_assets は説明してなかったけど ~vendor/assets/javascripts~ 以下を
       真っ新にするだけの処理。

       で、generate_assets が
       [[*addon 以下のファイルを vendor/assets 以下にコピー、変更する Raketask 作成][addon 以下のファイルを vendor/assets 以下にコピー、変更する Raketask 作成]]
       のあたりで書いた、コピーしたり中身を弄ったりしている処理。

       最後の build は Gem を作ったことある人ならわかるはずだけど
       gemspec の記述に従って gem ファイルを生成する処理。
       これを実行する pkg 以下に ~ember-components-x.y.z.gem~ みたいなファイルが作られる。

****** Publish

       上の手順で gem はできたので、あとはそれを GitHub Packages に登録するだけである。
       そのための step が以下。

       #+begin_src yaml
       - name: Publish to RubyGems
         run: |
           mkdir -p $HOME/.gem
           touch $HOME/.gem/credentials
           chmod 0600 $HOME/.gem/credentials
           printf -- "---\n:github: Bearer ${{ secrets.GITHUB_TOKEN }}\n" > $HOME/.gem/credentials
           gem push --key github --host https://rubygems.pkg.github.com/mugijiru pkg/*.gem
       #+end_src

       まずは [[https://docs.github.com/en/packages/guides/configuring-rubygems-for-use-with-github-packages#authenticating-with-a-personal-access-token][Authenticating with a personal access token]] の手順に従って
       ~~.gem/credentials~ に
       ~github: Bearer ${{ secrets.GITHUB_TOKEN }}~
       の記述が入るようにしている。

       それをすると GitHub Packages の認証が通るようになるので

       #+begin_example
       gem push --key github --host https://rubygems.pkg.github.com/mugijiru pkg/*.gem
       #+end_example

       を実行することで Gem として登録ができる。


**** ember-rails アプリケーションから Gem 化した Addon の読み込んで利用する

     https://github.com/mugijiru/ember-rails-todo-app/pull/51
     の PR でやっていることである。

     PR では途中色々ごちゃごちゃやってるけど、
     ここでは最終結果に基いて説明をする。

***** Gem を bundle install できるようにする

      まずは bundle install で組込めないと何も始まらないので
      Gemfile に以下を追加する。

      #+begin_src ruby
      source "https://rubygems.pkg.github.com/mugijiru" do
        gem "ember-components"
      end
      #+end_src

      さらに手元のマシンで以下のコマンドを実行して、
      bundle install の際に GitHub Packages への認証が通るようにする。

      #+begin_example
      $ bundle config --local https://rubygems.pkg.github.com/mugijiru mugijiru:XXXXXX
      #+end_example

      ~XXXXXX~ には Gem をインストールできるパーソナルアクセストークンを設定すること。

      こうしておけば

      #+begin_example
      $ bundle install
      #+end_example

      で無事に自作 Gem の ember-components がインストールできる

      Docker を使ってる場合は以下のようにして
      Docker 内で bundle config が設定された状態で ~bundle~ を実行する必要あり

      #+begin_example
      $ docker-compose run rails bash -c "bundle config --local https://rubygems.pkg.github.com/mugijiru mugijiru:XXXXXX && bundle"
      #+end_example

***** templates_root への登録

      ember-rails は Rails 側で templates_root を設定してあげる必要がある。

      というわけで config/application.rb で
      ~ember-components/templates~ が templates_root として認識されるように記述する。

      #+begin_src ruby
      config.handlebars.templates_root = %w[todo-app/templates ember-components/templates]
      #+end_src

***** sprockets で ember-rails を読み込む

      Gem として読み込めるようになったので
      Sprockets で以下のようにして require してあげると
      Gem の ~vendor/assets/javascrips/ember-components~ に生成したファイルが
      ember-rails アプリ側で認識されるようになる。

      #+begin_src js
      //= require ember-components
      #+end_src

***** Ember.js に component を register する

      require するだけだと Ember.js ではまだ使えないので
      Gem 内の Componentを登録する必要がある。

      が、基本的な処理は
      [[*components を ember-rails で読み込めるようにする][components を ember-rails で読み込めるようにする]] のところで書いたので、
      ember-rails 側では initializers に以下のような内容のファイルを置けば良い。

      #+begin_src js
      import EmberComponents from 'ember-components';

      export function initialize(application) {
        EmberComponents.registerAll(application);
      }

      export default {
        name: 'register-ember-components',
        initialize: initialize
      };
      #+end_src

      実質的にやってることは
      Gem 内のスクリプトに定義している registerAll メソッドを叩いているだけ。

      本当はこういう処理すらなしに使えるのがベストだけど
      そこまでうまくやる方法は見つけられず……。

***** 利用箇所の修正

      これは component の prefix を ~my-~ から ~mg-~ に変えたから発生している作業なので
      本質的には不要な作業。

      とにかく ~my-button~ のような古い prefix になっているところを
      ~mg-button~ というように新しい prefix に置き換えるだけの簡単なお仕事。

***** GitHub Actions の修正
****** setup-ruby で ember-components を bundle install できるようにする
       GitHub Actions の CI でも bundle install をしているので
       そこでもインストールが正常に行われるようにしてあげないといけない。

       #+begin_src yaml
       - uses: ruby/setup-ruby@v1
         env:
           BUNDLE_HTTPS://RUBYGEMS__PKG__GITHUB__COM/MUGIJIRU/: "mugijiru:${{ secrets.NPM_AUTH_TOKEN }}"
         with:
           bundler-cache: true
       #+end_src

       のように ~bundle config~ で設定したのと同じようなものを
       env で設定してあげるとインストールができる。

       NPM_AUTH_TOKEN なのは、NPM Package にした時に使ったやつが
       丁度いいスコープを持っていたから流用しちゃった。てへぺろっ。

****** assets:precompile

       Gem の作りが悪いのか、
       rspec を流す前に

       #+begin_example
       $ bin/rails assets:precompile
       #+end_example

       を流さないと component の template がテスト環境でで読まれない。
       というわけで GitHub Actions で rspec を実行する前にその手順を挟んでいる。

       https://github.com/mugijiru/ember-rails-todo-app/blob/4acafe0fd741fd24dc4e6bc69d98df5cbb68ef0e/.github/workflows/ci.yml#L32

       ちなみにこれは手元で rspec を流す時も同じなので
       ちゃんと手元のマシンでも precompile してあげましょう。だるい。

***** 旧共通ライブラリの削除

      ~app/assets/javascripts/ember-libs~ に配置していたファイルは不要なので
      さっくりと

      #+begin_example
      $ rm -rf app/assets/javascripts/ember-libs
      #+end_example

      して

      #+begin_src js
      //= require_tree ../ember-libs
      #+end_src

      としている行が残っていればそれも削除すること。

      ~config/application.rb~ で templates_root として
      ~ember-libs/templates~ を追加している場合はそれも削除しておくこと。
      まあこれは残っててもエラーにならないけどね。

**** 旧スタイルの ember-rails アプリケーションでも Gem 化 Addon を利用する

     https://github.com/mugijiru/ember-rails-todo-app/pull/52
     でやっていること。

     まあ正直 module 化しているやつとほとんどやってることは変わらない。

     変わってる点は、registerAll の呼び出し方ぐらいで
     TodoApp という Ember.js アプリケーションが入ってる変数が
     グローバル空間に収まっているので
     application.js.es6 の方で直接以下のように書いている。

     #+begin_src js
     import EmberComponents from 'ember-components';
     EmberComponents.registerAll(TodoApp);
     #+end_src

     他は module 化しているパターンと一緒なので割愛。

**** 最後に

     という手順で
     NPM Package にした Ember.js Addon を
     若干無理やりながらも ember-rails で使えるようにすることができました。

     まあ mixin とかは試してないのと
     Component をサブフォルダに分割していたりすると
     もうちょっと手をかけないといけなさそうだけど
     とりあえず動いたから許して。

     正直、無理やり感が結構あるので
     普通のプロダクトに適用するのは厳しい感じある。

*** DONE ember-cli-rails の Ember.js を 2.18 から 3.4 にアップデート :@Rails:@Ember_js:
    CLOSED: [2021-04-04 日 15:38]
    :PROPERTIES:
    :EXPORT_FILE_NAME: update-emberjs-2.18to3.4
    :END:

    前回までで ember-rails と ember-cli-rails の共存周りを一通り済ませて
    そのあたりは大体満足したので
    次の段階である Ember.js アプリの最新化を進めていくぞい。

    で、どう進めていくかというと
    2.18 は最新版からはかなり遠いので
    3系で LTS であったバージョンを順番に適用していく方針。

    それ以外のところだと基本的に
    https://cli.emberjs.com/release/basic-use/upgrading/
    に従って対応をしていく。

    というのを実践した PR がこちらになります。
    https://github.com/mugijiru/ember-rails-todo-app/pull/61

**** ember-cli の更新

     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/0b71b86330ab46ec8df46cdcb308daf3ed766681
     のコミットでやっていることですね。

     まずは Dockerfile で入れている ember-cli を 2.18 から 3.4 にする。
     3.4 系の最終バージョンは 3.4.4 なのでそれを指定している。

     #+begin_src Dockerfile
     # install ember-cli
     RUN yarn global add ember-cli@3.4.4
     #+end_src

**** ember-cli-update の導入

     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/ded293ff2f686081549d0019e500facb5c2aaa3d
     のコミットでやってることですね。

     Ember.js をアップデートする際には ember-cli-update を使うのが王道っぽいので
     それも Dockerfile でインストールしておく。

     #+begin_src Dockerfile
     # install ember-cli-update
     RUN yarn global add ember-cli-update
     #+end_src

     また、こいつは今後も 3 系で更新していくにあたり必要と思われるので
     ember-cli よりも先に入れておくことにする。

**** bundle && yarn

     Dockerfile を更新したので bundle install と yarn install を実行しておく。

     #+begin_example
     $ docker-compose run rails bundle
     #+end_example

     #+begin_example
     $ docker-compose run rails bash -c "export NPM_TOKEN=XXXXXXXXXX && cd ember/todo-app && yarn"
     #+end_example

     NPM_TOKEN という環境変数を使ってるのは
     ember-components という自作の NPM パッケージを使うために
     [[https://github.com/mugijiru/ember-rails-todo-app/blob/7916518d766145fc0b8d9978efbfb08d6937f813/ember/todo-app/.npmrc][.npmrc]] で GitHub Packages を使うような設定をしているため。

**** ember-cli-update bootstrap の実行

     https://github.com/ember-cli/ember-cli-update/wiki/Getting-Started に書かれているように

     #+begin_example
     $ docker-compose run rails bash -c "export NPM_TOKEN=XXXXXXXXXX && cd ember/todo-app && ember-cli-update bootstrap"
     #+end_example

     を実行することで config/ember-cli-update.json が生成される。
     ember-cli-update は実行時にこのファイルを見て色々処理をする様子。

     雰囲気的には Addon もこれを使って更新できそうだが、ちょっとまだ調べてない。

     とりあえずこの実行結果をコミットしたのが以下。
     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/35177e82eac6a9d490c49348ec8e50b31828bb10

**** ember-cli-update で 3.4.4 に更新

     いよいよアップデート作業である。
     とりあえず 3.4.4 に上げたいので以下のコマンドを叩く。

     #+begin_example
     % docker-compose run rails bash -c "export NPM_TOKEN=XXXXXXXXXX && cd ember/todo-app && ember-cli-update --to 3.4.4"
     #+end_example

     すると

     #+begin_example
     ? Blueprint updates have been found. Which one would you like to update?
     > app, current: 2.18.2, latest: 3.25.3
     #+end_example

     というように質問される。
     恐らく Addon も ember-cli-update で管理できるようにしていたら他の選択肢も出て来るんだろうが、
     とりあえず今回は app を更新したいだけなので何も考えずに Enter を叩く。

     すると、以下のように何やらファイルが生成されたようなログが出て来る。
     しかも2回も生成されてる雰囲気。

     #+begin_example
     installing app
       create .editorconfig
       create .ember-cli
       create .eslintrc.js
       create .travis.yml
       create .watchmanconfig
       create README.md
       create app/app.js
       create app/components/.gitkeep
       create app/controllers/.gitkeep
       create app/helpers/.gitkeep
       create app/index.html
       create app/models/.gitkeep
       create app/resolver.js
       create app/router.js
       create app/routes/.gitkeep
       create app/styles/app.css
       create app/templates/application.hbs
       create app/templates/components/.gitkeep
       create config/environment.js
       create config/targets.js
       create ember-cli-build.js
       create .gitignore
       create package.json
       create public/robots.txt
       create testem.js
       create tests/helpers/destroy-app.js
       create tests/helpers/module-for-acceptance.js
       create tests/helpers/start-app.js
       create tests/index.html
       create tests/integration/.gitkeep
       create tests/test-helper.js
       create tests/unit/.gitkeep
       create vendor/.gitkeep
     WARNING:
     WARNING: The 'package.json' file for the addon at /usr/local/share/.config/yarn/global/node_modules/ember-cli/lib/tasks/server/middleware/tests-server
     WARNING:   specifies a missing dependency 'exists-sync'
     WARNING: Node v14.16.0 is not tested against Ember CLI on your platform. We recommend that you use the most-recent "Active LTS" version of Node.js. See https://git.io/v7S5n for details.
     installing app
       create .editorconfig
       create .ember-cli
       create .eslintignore
       create .eslintrc.js
       create .template-lintrc.js
       create .travis.yml
       create .watchmanconfig
       create README.md
       create app/app.js
       create app/components/.gitkeep
       create app/controllers/.gitkeep
       create app/helpers/.gitkeep
       create app/index.html
       create app/models/.gitkeep
       create app/resolver.js
       create app/router.js
       create app/routes/.gitkeep
       create app/styles/app.css
       create app/templates/application.hbs
       create app/templates/components/.gitkeep
       create config/environment.js
       create config/optional-features.json
       create config/targets.js
       create ember-cli-build.js
       create .gitignore
       create package.json
       create public/robots.txt
       create testem.js
       create tests/helpers/.gitkeep
       create tests/index.html
       create tests/integration/.gitkeep
       create tests/test-helper.js
       create tests/unit/.gitkeep
       create vendor/.gitkeep
     #+end_example

     で、実行後に Ember アプリのディレクトリで ~git status~ を叩くと以下のような感じ。

     #+begin_example
     Changes to be committed:
       (use "git restore --staged <file>..." to unstage)
             new file:   .eslintignore
             modified:   .eslintrc.js
             modified:   .gitignore
             new file:   .template-lintrc.js
             modified:   README.md
             modified:   config/ember-cli-update.json
             new file:   config/optional-features.json
             modified:   config/targets.js
             modified:   package.json
             modified:   testem.js
             new file:   tests/helpers/.gitkeep
             deleted:    tests/helpers/destroy-app.js
             deleted:    tests/helpers/module-for-acceptance.js
             deleted:    tests/helpers/start-app.js

     Unmerged paths:
       (use "git restore --staged <file>..." to unstage)
       (use "git add/rm <file>..." as appropriate to mark resolution)
             deleted by us:   .travis.yml
     #+end_example

     .travis.yml は「どうせ使わねーだろ」ってことで自分で消してあるので
     改めて ~git rm .travis.yml~ すれば良い。

     それ以外の変更点も、ざっと眺めた感じは、きっといい感じに 3 系に対応してくれてそうなので
     気にせずコミットする。適当である。

     この実行結果のコミットは
     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/c78deca904a43aa5587cf1489cabd90461469c31
     ですね。

**** 古いコードを自動置き換え

     https://cli.emberjs.com/release/basic-use/upgrading/#updatingyourcodeautomatically

     に書かれてるように ~ember-cli-update~ では
     ~--run-codemods~ オプションで実行することで
     古い記述を自動的に新しい書き方に直してくれるという便利機能があるので、それを実行する。
     後で理由を記載するが、ここでもまた NPM_TOKEN が必要になる。

     #+begin_example
     $ docker-compose run rails bash -c "export NPM_TOKEN=XXXXXXXXXX && cd ember/todo-app && ember-cli-update --run-codemods"
     #+end_example

     するとまた

     #+begin_example
     ? Which blueprint would you like to run codemods for?
     > ember-cli
     #+end_example

     というように1つしかない選択肢を出される。
     これもまた Addon を ember-cli-update で更新管理できるようにしていたら選択肢が増えるんだろう、
     という推測をしてそのまま Enter を叩く。

     すると、今度は以下のようにいくつかの選択肢が出て来る。

     #+begin_example
     ? These codemods apply to your project. Select which ones to run. (Press <space> to select, <a> to toggle all, <i> to invert selection)
     ❯◯ ember-modules-codemod
      ◯ ember-qunit-codemod
      ◯ ember-test-helpers-codemod
      ◯ es5-getter-ember-codemod
      ◯ notify-property-change
      ◯ qunit-dom-codemod
     #+end_example

     それぞれ何をしてくれるかというと、多分大体以下の感じ。

     - [[https://github.com/ember-codemods/ember-modules-codemod][ember-modules-codemod]] :: ~import Ember from 'ember'~ という古い記述を ~import Component from '@ember/component'~ とかに修正するやつ
     - [[https://github.com/ember-codemods/es5-getter-ember-codemod][es5-getter-ember-codemod]] :: ~obj.get('foo')~ みたいな古い記述を ~obj.foo~ みたいな記述方式に変更するやつ
     - [[https://github.com/ember-codemods/ember-test-helpers-codemod][ember-test-helpers-codemod]] :: テスト用の記述を新しい書き方に変更するやつ
     - [[https://github.com/ember-codemods/ember-qunit-codemod][ember-qunit-codemod]] :: ember-qunit の moduleFor とかの書き方を新しい方式に変更するやつ
     - [[https://github.com/ember-codemods/ember-3x-codemods/tree/master/transforms/notify-property-change][notify-property-change]] :: notifyPropertyChange の書き方が変わる。使ったことないからよくわからん。
     - [[https://github.com/simplabs/qunit-dom-codemod][qunit-dom-codemod]] :: DOM 選択の記述を jQuery 依存じゃないようにするっぽい

     例えばここで
     ember-modules-codemod だけ選択して Enter すると
     何かよくわからないが NPM Package を Fetch しにいき、それが終わるとコードの自動補正が実行される。

     #+begin_example
     Running codemod ember-modules-codemod
     Running command 1 of 1
     Skipping path addon which does not exist.
     Skipping path addon-test-support which does not exist.
     Skipping path test-support which does not exist.
     Skipping path lib which does not exist.
     Processing 11 files...
     Spawning 7 workers...
     Sending 2 files to free worker...
     Sending 2 files to free worker...
     Sending 2 files to free worker...
     Sending 2 files to free worker...
     Sending 2 files to free worker...
     Sending 1 files to free worker...
     All done.
     Results:
     0 errors
     6 unmodified
     0 skipped
     5 ok
     Time elapsed: 1.785seconds

     Done! All uses of the Ember global have been updated.
     Finished running command 1 of 1
     Finished running codemod ember-modules-codemod
     #+end_example

     これで何が変更されているかというと
     ~git diff --cached~ の一部を表示するとこんな感じ。

     #+begin_example
     diff --git a/ember/todo-app/app/components/todo-item.js b/ember/todo-app/app/components/todo-item.js
     index bc28c83..a803fc5 100644
     --- a/ember/todo-app/app/components/todo-item.js
     +++ b/ember/todo-app/app/components/todo-item.js
     @@ -1,12 +1,14 @@
     -import Ember from 'ember';
     +import { later } from '@ember/runloop';
     +import { computed } from '@ember/object';
     +import Component from '@ember/component';

     -export default Ember.Component.extend({
     +export default Component.extend({
        tagName: 'li',
        classNames: ['p-todo-item'],
        classNameBindings: ['isCompleted:p-todo-item__completed'],

        item: null,
     -  isCompleted: Ember.computed('item.isCompleted', function () {
     +  isCompleted: computed('item.isCompleted', function () {
          return this.get('item.isCompleted');
        }),
     #+end_example

     ~import Ember from 'ember'~ という記述はもう古いので
     個別に ~import Component from '@ember/component'~ とするような記述に変更されている感じ。

     いい感じにコードを変更してくれることがわかったので、
     同じ調子で ember-qunit-codemods なども適用していく。

     すると ~ember-test-helpers-codemod~ でエラーになったりするけど
     そもそもこのプロジェクトでは Ember.js に対する qunit でのテストをまだ書いてないので
     多分それが原因で単にファイルがないだけとかなので軽く無視する。

     という感じで実際に適用して変更があったのが

     - https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/815ccd8c6d79f6e6bc6171f214f8cd375e1a6537
     - https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/d21b563c6352718c702f4ccd883cd780973d9982

     の2つだけ。
     ま、複雑なことしてないしね。



**** packages の更新

     [[*ember-cli-update で 3.4.4 に更新][ember-cli-update で 3.4.4 に更新]] の方でやっておけば良かったんだけど、
     ここまでの作業で package.json は更新されてるけど
     実際にインストールされてるライブラリの更新はされてなかったorz

     というわけで Ember.js アプリのディレクトリで ~yarn~ を叩いたら
     色々新しくインストールされて
     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/196d9f7b389c5e2c8d690cd1e608251c69a377d2
     みたいな感じで yarn.lock も更新されると。

**** テストの実施

     まあ後はちゃんと動くよねということを確認するために
     テストを実行して問題なければ OK ですと。

     このプロジェクトだと system spec を書いているので
     それを実行した上で、念の為手でも動作確認して問題なかった、という感じ。

     もっと複雑なケースだと色々問題あるんだろうな〜。

**** 問題があった場合

     もし問題があったら、エラー内容などを確認しつつ

     - [[https://deprecations.emberjs.com/][Ember Deprecations]]
     - [[https://blog.emberjs.com/tag/releases/][Ember release blog post]]

     と睨めっこしたら良いんだと思う。
     今回問題がなかったから、そのあたりの知見は得られなかったけど……。

**** その他

     実は eslint で怒られてるのはまだ無視しています。
     そこまで修正入れると面倒なのと、差分が大きくなるなと思って。
     それは別の機会に直しておきます。

**** 最後に

     とりあえず3系にするだけならそんなに難しくなさそうな所感を得た。

     eslint で怒られてるの直す必要があるな〜というのと、
     ember-components@0.0.3 がいつから使えなくなるか気になるのと
     ember-bootstrap あたりの Addon を ember-cli-update で管理できるようにしたいなという気持ちは残ったけど。

     ま、そこもおいおい試していく

*** DONE RPA ちょっとだけ調べてみた
    CLOSED: [2021-04-25 日 23:46]
    :PROPERTIES:
    :EXPORT_FILE_NAME: research-rpa
    :END:

    RPA ちょっとだけ調べてみたのでとりあえず Blog 記事にする。
    ちなみにいくつかリンク張るけど、面倒なのでアフィリエイトとかそういうのにはなってない。
    お金は好きだけど面倒が勝った。

**** モチベーション
     身の回りで RPA 導入するって話があって
     それ聞いて色々思うところがあったから調べてしまった。
     そんで折角調べたんだから世の中に出してしまえ、というぐらいの軽い気持ち。

     そんな軽い気持ちなので、まだどれ1つ試してはいない。

     あと、記事中でやたら Excel のことを気にしているけど、
     自動化してデータ取りたいやつの半分ぐらいは Excel だろっていう偏見があるからです。

**** RPA とは
     わざわざ説明要らない気がするけど一応。

     ロボティクス・プロセス・オートメーションとかいうやつで
     ざっくり言うと「機械に任せて自動化しようぜ」ってやつ。
     あと、プログラマではない人も扱えるようにコードは書かないとか、
     昔からある画面自動操作とちょっと違って、仮想環境上で実行されるとかあるっぽい。
     ま、細かいことは知らん。
     動きゃいいんだよ動きゃ。

**** RPA の分類

     ざっくりと

     - スタンドアローン型
     - オンプレミス型
     - クラウド型

     と分かれる。

***** スタンドアローン型

      デスクトップ型とも言われるやつ。
      一台のマシンにインストールしてその中で完結するタイプ。
      感覚的には一番わかりやすいんじゃないかな。
      RDA(ロボティクス・デスクトップ・オートメーション)と呼んで他と区別されることもあるらしい。

      各個人のマシンにインストールして動かすので操作対象の制限が少なく
      個人作業の効率化に向いている。

      インストールして使うタイプなので、大体 OS の制限がある。
      っていうか Windows で使ってくださいって言われる印象がある。

      仕組みが単純だからなのか比較的安価なのが多いっぽい。
      とはいえ、大体初期導入で20万円とか30万円とか取られて
      月々10万円取られる、みたいなのがお約束。

      で、個人の作業の効率化には向いているけど、
      会社全体とか部署全体の効率化のために
      他の人が作ったシナリオを流用したい、みたいなのには向かない。
      だって各個人のマシンに入れるものですし。

      それを回避するために、
      こいつを自社管理サーバ(オンプレでも AWS でも)にインストールして、
      1アカウントを使い回してリモートデスクトップでアクセスして操作する、
      みたいなのはバカげた考えなのでやめた方がいい。

      共通アカウントって時点でセキュアじゃないし、
      誰かのロボットが動いていると自分の処理が動かせないので待ちが発生するし、
      サーバの管理コストも発生するしでコストメリットに対するデメリットがでかいはず。
      導入しようとしている人にそれが理解できるか知らんけど。

***** オンプレミス型

      サーバ型とも言われるやつ。
      オンプレサーバにインストールしてみんなで使うみたいな用途向け。

      オンプレサーバに入れるので

      - 情報が社外に流出しないようにしたい
      - イントラネットのサーバにアクセスしたい
      - 使用状態の監視をしたい

      みたいなことを要求しがちな大企業でも導入しやすそうな気がしている。

      一方で、オンプレサーバに入れるとなるとサーバ管理コストも発生するし、
      多分仕組み上お値段もお高めになるかなって気はしている。

      オンプレミス型とは書いているけど
      別に AWS EC2 上で動かしても問題はないはず。
      イントラネットに閉じる、みたいなのとはズレてくるからメリットが薄れそうだけど。

      正直3分類の中で一番興味ないのでほとんど調べてない。
      つまりできないこととかもよくわからん。

      多分、サーバにはサーバソフトウェアを入れた上で、
      各自のマシンにはクライアントソフトウェアを入れて、それ経由でサーバにアクセスして、
      実際の処理は各自のマシンで実行される仕組みにしているんじゃないかな。
      じゃないと大企業で大事な Excel などの操作もできなさそう(やりにくそう)だし。

***** クラウド型

      みんな大好きクラウド環境で動くタイプ。
      クラウド環境で動くので、使用場所を問わないし管理もしやすいやつ。
      ほっといても運営がどんどん機能追加してくれるしね。多分。

      ブラウザ上で完結している場合は Excel などの操作はできないが、
      それを解決するために別途クライアントをインストールする、というタイプもある。

      ただ、多分クライアントソフトの開発にそれほどリソースが割けないので
      対応ソフトウェアが多くはない、ということもありそう。
      まあ時代はクラウドなので今時 Excel などのローカル環境で動くソフトウェアなんて使いませんよねハハハ。

      オンプレ型と違ってサーバ管理コストは発生しないので
      エンジニアの端くれとしてはオンプレ型よりこっちの方が好み。
      だって情シスでもないのにサーバ管理させられたくないっしょ。通常業務が滞る。

      サービス終了となった時に全部動かなくなってつらいことになりそうなので
      クラウド型を選択する時は人気度にも気をつけた方がいいかもしれない。
      それ以外のタイプでもサポート終了したら色々困りそうだけど、
      即座に動かなくなるわけではないはずなので、まだマシそう。

**** どのタイプを使うべきか

     用途による。

     とだけ書いてもしょうがないので、ちょっと主観で述べると、
     とりあえず基本的にはクラウド型にしとく方が良さそうな気がする。

***** 会社単位・部署単位での導入の場合

      会社全体や部署全体の効率化観点だと、
      どうせ「このシナリオをみんなが使えるようにしたい」みたいになるので
      最初からそういう用途があることを折り込んでおいた方が良さそう。

      となるとオンプレ型かクラウド型になるけど、
      オンプレサーバの管理とかしたくないじゃん? じゃあクラウド型じゃん?

      管理コストとかより情報流出対策とかの方が大事な方は、オンプレ型になる気がする。
      あとはイントラネットへのアクセスが必要だったらクラウド型は厳しいかも。

***** 個人での導入の場合

      個人用途だと
      わざわざオンプレ型にして無駄に管理の手間や利用料金を増やしたい酔狂なやつ以外は
      スタンドアローン型かクラウド型になると思う。

      で、個人だと色々自由なはずなので
      使うソフトウェアは基本的にクラウドアプリケーションに寄せておいたら、
      スタンドアローン型のメリットである、ローカル環境の操作は不要になるかなと。

      また、クラウド型にしておいたら、
      PC を買い替えた時とかもインストールし直しとかデータ移行とかも不要で便利。
      いや、ローカルクライアントも必要なやつだとインストールし直しは発生するけども。

      もしローカル環境の自動化をしたいとか、イントラネットにアクセスしたいとか、
      クラウドサービスの利用は諸々の制限がある場合はスタンドアローン型になるかなって気はする。
      けど、そういうところソフトウェアのインストールにも制限がありそう(偏見)。

**** その他、気にした方がいいポイント
***** 機能面
      各会社がシノギを削ってるのでそれぞれの製品毎に強みがあったりする。

      例えば、AI による判定機能が入ってるとか、
      素人でも簡単にロボットが作れちゃうとか、
      複雑な操作までできることが売りのやつとかもある。

      そのあたりは、各自が自分のスキルレベルとかやりたいことに合わせて検討して欲しい。
      というか、そこまで調べる元気はなかった。
      あと AI がどうのこうのってやつはそもそも信用してなかったりするので、売り文句を見てると苦痛だった。

***** お値段

      大事だよね〜お値段。お高いの厳しいもんね。
      まあ、安くてもやりたいことができないんじゃあ導入する意味はないので
      機能重視で考えた方がいいと思うよ。

      ちなみに大体のやつは月額10万円からで初期費用は別途30万とかの世界なので
      私としては「高い……無理……」ってなるんだけども。
      ギョームソフトウェアってお高いね。

      個人的には、基本サービスは安いけど、
      つい頼みたくなるような便利な追加オプションがあるような料金設定はニクいなって思う。

***** やめやすさ

      導入してみてダメだった時のことを考えると
      やめやすさは考慮に入れておいた方がいいと思うの。

      例えば、シナリオのエクスポート機能があって、それを他の RPA に取り込むことができると嬉しいよね。
      そんなのをサポートしている RPA があるって聞いたことないけど。
      互換性の維持とか厳しそうだしな。

      あとは契約期間だよね。1年更新とかやめてほしい。
      月額プランと年契約プランで後者は割安、とかならいいけど。
      その場合でも解約申請期間がめっちゃ短かいとかわかりにくいとかもやめてほしいよね。

***** 息が長そうか

      せっかく使い続ける選択をしたのに、
      製品サポートそのものが終了してしまったら困るので長く続きそうかってのは大事。

      それをどう判断するかは、ユーザー数が十分いそうか(維持できるだけの収益がありそうか)とか、
      母体が大きいか、とかになるのかなあ。

      個人的にはサービスサイトの表示が微妙なところは、
      そこにコストがかけられない程度に儲かってないんだな、つまり危なそうだな、という気持ちになる。

**** で、具体的にどの製品を使ったらいいのか

     これ、ほんと全然操作したことはなくって、ググって見つかる情報だけで判断しているので
     その前提でよろしくな。

     あと、基本的にケチなので、ほとんど無料プランがあるやつしかリストアップしてない。

***** Coopel

      [[https://coopel.ai/][Coopel]] は DeNA が出しているクラウド型の RPA サービス。
      ローカルクライアントもあって、それを使うとローカルのファイルも扱えたりするやつ。
      少なくともみんな大好きな Excel は扱えるよっ!
      Mac と Windows の両対応なのも嬉しいポイント。

      記事執筆時点だと、1アカウントあたり月額5,400円(税抜)と
      他の RPA サービスに比べるとかなりリーズナブルな感じ。
      最低アカウント数は1アカウントからっぽい雰囲気だし(多分、明示はされてない)

      機能面では、クラウド型がベースなのもあってちょっと弱い気がしている。
      あと、まだ出たばかりのサービスでユーザー数が多くなさそうで、ちゃんと生き残ってくれるか気になる。

      とはいえ国産 RPA だと調べた中では一番好きな感じ。

      他のやつは、クソ高いか「お値段はお問い合わせください」だったり、
      Mac 対応してなかったりするので。

***** UiPath Community Edition

      [[https://www.uipath.com/ja/][UiPath]] は海外の RPA サービスで結構有名っぽいやつ。
      Community Edition だと、個人でも使えるようだし、
      企業でも条件を満たせば無料で使えるようなので小規模事業な各位には良いかもしれない。
      https://www.uipath.com/hubfs/legalspot/JP-UiPath-Specific-Terms-for-Community.pdf

      Automation Cloud とかいうクラウド型のやつとか、色々な機能が使えるっぽい。

      機能も豊富らしいが、その分複雑なので素人には難しい、みたいな意見も見かけた。
      あと海外製なので日本人には英語がつらそう、
      と思ってたけど日本語化されてるのでそこは割とつらくないかもしれない。

      どの程度きっちり日本語化されてるかはわからないけど、
      ざっくり Qiita を見た感じだと割とちゃんとされてそうな雰囲気。

      あとは、海外製なので UI が日本人には合わない可能性はありそう。
      使ったことないから知らんけど。

      機能とかとは関係ないけど、公式サイトの英語版と日本語版の違いがちょっと面白い。

***** Automation Anywhere Community Edition

      [[https://www.automationanywhere.com/jp/][Automation Anywhere]] も海外製で有名っぽいやつ。
      学生や開発者、或いは小規模事業者なら無償の Community Edition が使えるとのこと。
      クラウド型の機能とかなんだとか、結構色々な機能を使える。

      こっちも日本語化は一応されてるが、
      [[https://qiita.com/RPAbot/items/2a2d94eeab641dfa6516][Qiita の記事]] を見た感じだと、英語の部分も残ってそうな雰囲気。
      英語となると苦しい人達には厳しいかもしれない。

      UiPath に比べるとライセンスがちょっと厳しい印象。
      https://www.automationanywhere.com/jp/community-edition-license-agreement-a2019

      特に利用台数が限られてるので、
      複数台マシンを所持していて、どっちからでも実行したい時とか、
      移行したい時とか困らないかなってお気持ち。

***** Power Automate Desktop

      [[https://flow.microsoft.com/ja-jp/desktop/][Power Automate Desktop]] は Microsoft が出してるやつで
      割と最近 Windows 10 ユーザーなら無料で使えるようになったやつ。
      Power Automate シリーズの1つなので、
      多分、もっと便利に使いたくなった時に、
      そのシリーズの他の製品との連携もスムーズにできるんじゃないかなってやつ。

      MS なので、多分息も長いし、
      Windows で個人用途でデスクトップ型で構わないなら
      まずはこれを試しておけって気がするやつ。無料なので。
      MS だから Excel も当然使えるしなっ!

***** Automator

      Mac 買ったら入ってるやつですね。なので実質無料。
      とりあえず Mac で RPA 的なことをしたかったらこれ使ってけば良いのでは、と思ってる。

      Excel なんかは対応してなかったりするのが微妙なところ。

**** 最後に

     個人的にはコードを書きたいので RPA あんまり入れる気がしないでござる。
     テスタビリティなさそうだし。
     NoCode での開発ツールに対する自動テストみたいな、
     コード書かない縛りプレイの時に使うかも、ぐらいのお気持ち。

*** DONE 最近 org-pomodoro 使ってないことに気付いた            :@Emacs:@雑記:
    CLOSED: [2021-04-29 木 18:03]
    :PROPERTIES:
    :EXPORT_FILE_NAME: why-not-use-org-pomodoro
    :END:

    [[https://github.com/marcinkoziej/org-pomodoro][org-pomodoro]] って便利な org-mode の拡張があるんですよ。
    org-clock とポモドーロテクニックを組み合わせて使える便利なやつ。

    デフォルト設定で話すと、
    何か TODO にカーソルを乗せてる状態で起動したら
    そいつが clock-in した上で25分のタイマーが動いて、
    25分経過したら clock-out した上で、5分の休憩が挟まって
    その休憩終了時には「次のポモドーロ開始するかい?」みたいなのが出て来て
    そこでまた M-x org-pomodoro を叩いたらまた25分のタイマーが開始して……みたいなやつ。

    まあ使い方それで合ってたかちょっと自信ないけど。
    というのも、表題の通りで、最近使ってないんですよね。
    便利な雰囲気なのに。

    なんで馴染まないのかな〜。
    やっぱり割込み作業が多くて pomodoro を乱されるから?
    あとは会議が挟まってくるとどう運用していいかわからなくなるから?

    前者の解決は、タイマー起動中は Slack の通知を切って見れないようにするぐらいじゃないと
    多分割込みを防げないよな〜という気はする。
    ちょっとその運用考えるか。

    後者は、まあ会議の時はもう pomodoro 放置でいいっていう割り切りかな。

    という悩みがあるので
    ポモドーロテクニックを1年以上継続しているぞ! みたいな猛者の方は
    どうやってそれを維持しているか教えてほしい。

    org-clock は使ってるけどね。pomodoro 存在を忘れてた。無念。

*** DONE org-agenda を活用し始めた                              :@Emacs:@org:
    CLOSED: [2021-04-29 木 19:03]
    :PROPERTIES:
    :EXPORT_FILE_NAME: try-org-agenda
    :END:

    昨年から org-mode をもっと活用していこうということで、
    org-clock を使い始めたり org-pomodoro を導入したり org-habits を設定してみたりしている麦汁さんです。

    org-mode は機能が豊富過ぎてマジで何が出来るのか全貌を把握し切れてないのですが、
    そんな中で、やっぱり全然把握できてなくて使ってなかった機能の1つが org-agenda ってやつ。

    なんかうまく使うと、予定を組んでたり締切を設定していたりするタスクが一目瞭然になって
    お仕事などが捗るという素敵な機能らしいのだけど、
    どうもイマイチ使い方がわからなくて放置していました。

    ただまあ仕事が捗るなら試してみる価値はあるよな〜ということで、
    今年の頭ぐらいから使い始めている。

    まず、平日朝イチでやっておきたい習慣タスクに対して
    ~Weekday~ と ~Start~ の2つのタグを振ってるか、
    ~Daily~ というタグを振ってるので
    それを表示できるやつを以下のように仕込んでる。

    #+begin_src emacs-lisp
    ("hs" "Weekday Start"
     ((tags "Weekday&Start|Daily"
            ((org-super-agenda-groups '((:name "予定が過ぎてる作業" :scheduled past)
                                        (:name "今日の作業" :scheduled today)
                                        (:discard (:anything t))))))))
    #+end_src
    https://github.com/mugijiru/.emacs.d/blob/a523566f2be993655f74ebf20afc4da444019f5e/inits/60-org.el#L89-L93

    麦汁さんのやりたいことを実現するには、
    デフォルトの org-agenda だとなんか機能が足りないっぽかったので
    それを補うために [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] も使っている。

    とりあえず上の例の2行目でタグによる絞り込みをしているが
    これは org-mode の標準機能を使っていて
    https://orgmode.org/manual/Storing-searches.html#Storing-searches
    あたりに書いてる方法で絞り込んでいる。

    で、その後に org-super-agenda の機能である
    [[https://github.com/alphapapa/org-super-agenda#group-selectors][Group Selectors]] というやつで
    スケジュール通りのやつと、スケジュールが過ぎてるやつとで表示を切り分けてる。

    ~(:discard (:anything t))~ は、
    そこまでの条件にマッチしなかったやつを全部無視するような設定。
    これがないと ~Other items~ という形で全部並んでしまって邪魔になる。

    最初の絞り込みで綺麗に絞り込めると良いかもしれないが、
    そこまで高度な機能は org-mode には備わってなさそう。
    それか、そういう高度な機能を見つけて使いこなせる能力を俺が有してないか。

    まあそれはともかく、上の感じでタスクを登録していると以下のように表示される。

    #+begin_example
    Headlines with TAGS match: Weekday&Start|Daily

     予定が過ぎてる作業
      next-actions:TODO 排便                                                      :Weekday:Start:

     今日の作業
      next-actions:TODO 体重・体脂肪率計測                                                 :Daily:
    #+end_example

    実際のやつはもっと色々あるというか、そもそもわざわざ排便を org-mode で管理はしてないので
    あくまでサンプルとして2つ置いてるだけだとご認識ください。

    同じノリでその日の締め作業も取れるように設定している。

    また、日中使うための設定も用意していて、こっちは結構複雑。

    #+begin_src emacs-lisp
      ("d" "Today"
       ((agenda "会議など"
                ((org-agenda-span 'day)
                 (org-agenda-files my/org-agenda-calendar-files)))
        (tags-todo "-Weekday-Daily-Holiday-Weekly-Weekend"
                   ((org-agenda-prefix-format " ")
                    (org-agenda-overriding-header "今日の作業")
                    (org-habit-show-habits nil)
                    (org-agenda-span 'day)
                    (org-agenda-todo-keyword-format "-")
                    (org-overriding-columns-format "%25ITEM %TODO")
                    (org-agenda-files '("~/Documents/org/tasks/next-actions.org"))
                    (org-super-agenda-groups '((:name "仕掛かり中" :todo "DOING")
                                               (:name "TODO" :todo "TODO")
                                               (:name "待ち" :todo "WAIT")
                                               (:discard (:anything t))))))
        (alltodo ""
                   ((org-agenda-prefix-format " ")
                    (org-agenda-overriding-header "予定作業")
                    (org-habit-show-habits nil)
                    (org-agenda-span 'day)
                    (org-agenda-todo-keyword-format "-")
                    (org-overriding-columns-format "%25ITEM %TODO")
                    (org-agenda-files '("~/Documents/org/tasks/projects.org"))
                    (org-super-agenda-groups '((:name "〆切が過ぎてる作業" :deadline past)
                                               (:name "予定が過ぎてる作業" :scheduled past)
                                               (:name "今日〆切の作業" :deadline today)
                                               (:name "今日予定の作業" :scheduled today)
                                               (:discard (:anything t))))))
        (tags-todo "Weekday|Daily|Weekly"
                   ((org-agenda-overriding-header "習慣")
                    (org-habit-show-habits t)
                    (org-agenda-files '("~/Documents/org/tasks/next-actions.org"))
                    (org-super-agenda-groups '((:name "予定が過ぎてる作業" :scheduled past)
                                               (:name "今日予定" :scheduled today)
                                               (:discard (:anything t))))))))
    #+end_src
    https://github.com/mugijiru/.emacs.d/blob/a523566f2be993655f74ebf20afc4da444019f5e/inits/60-org.el#L109-L144

    通常なら Agenda for current week or day ってのが標準で用意されてるので
    それを使えばいいかなって思うんだけど
    1 view でいい感じにカテゴライズされていて取得できるってのが欲しかったんですよね。
    で、それをやろうと思うとやはり org-super-agenda が必要そうだったって感じ。

    とりあえず現在は next-actions.org に、直近やるつもりの作業を詰めていて
    projecs.org に、直近ではないけどやることリストを並べてるって感じ。
    スプリントバックログとプロダクトバックログみたいな扱いのつもりですね。
    あとは別途 org-gcal で同期している Google Calendar から取得した予定用のファイルもあったりする。

    そうやっていくつかあるファイルからいい感じになるようにということで設定しているのが先程のコードで
    それで org-agenda のバッファを生成すると以下のような雰囲気のやつになる。

    #+begin_example
     会議など
     11:00-12:00 すごい会議
     15:00-18:00 長い会議
    ------------------------------
    今日の作業
     仕掛かり中
     - 藁人形の作成
     待ち
     - 五寸釘発注の稟議

    予定作業
     〆切が過ぎてる作業
     - 五寸釘の発注

    習慣
     予定が過ぎてる作業
     - 排便
     今日予定
     - 体重・体脂肪率計測
    #+end_example

    もちろん、内容はサンプル用に適当にでっち上げたやつです。

    本当はタグも表示されてしまうけど、それはあまり要らないかなと思ってるので、
    それはなんとか非表示にしたいなあと願ってる。
    ~org-overriding-columns-format~ を弄っても今のところいい感じにならなくて悲しい。

    あと、今の設定と使い方だと「あと数日で着手しないといけないタスク」とか
    そういうやつはわからないので、それもなんとかしたい。

    多分着手予定の日を早めに設定して起きつつ
    〆切を設定してたら今でもある程度いけるんだろうけど、
    気付いたら着手予定が同じ日になってて
    いきなりその日に全部やらないといけない雰囲気になるとかありそうでこわい。

    数日前から、着手予定のやつがいつ着手予定なのか見れるようにしたらいいんだろうな〜。
    ま、少しずつ改善を入れていくしかないか……。
*** DONE Ember.js@3.4 から最新の 3.26 に上げた             :@Rails:@Ember_js:
    CLOSED: [2021-05-09 日 14:35]
    :PROPERTIES:
    :EXPORT_FILE_NAME: update-emberjs-3_4-to-latest
    :END:

    いつも Ember.js ネタを書く時に使ってる
    https://github.com/mugijiru/ember-rails-todo-app
    のリポジトリですが、ゴールデンウィークで Ember.js の最新版への対応を完了させました。

    そこへの対応のために https://github.com/mugijiru/ember-components の addon の方も
    2.18 から最新化することになりました。

**** 対応の方針
     どう対応させていったかというと、
     [[*ember-cli-rails の Ember.js を 2.18 から 3.4 にアップデート][ember-cli-rails の Ember.js を 2.18 から 3.4 にアップデート]]
     の記事でも書いた

     #+begin_quote
     3系で LTS であったバージョンを順番に適用していく方針
     #+end_quote

     を実際にやってみたって感じ。

**** 実際の対応
***** eslint 対応

      3.4 に上げた後に、eslint で怒られてるのに対応できそうだなとなったので
      3.8 に上げる前に修正をした

      https://github.com/mugijiru/ember-rails-todo-app/pull/66

      大きな変更点は
      jQuery を使って要素を取得していたところを
      純粋な JS に書き換えたところぐらい。

***** 3.4 → 3.8
      https://github.com/mugijiru/ember-rails-todo-app/pull/67

      1. ~ember-cli-update --to 3.8~
      2. ~yarn~
      3. ~ember-cli-update --codemods~

      を叩いたぐらい。codemods では特がないので難しいところは何もない。

***** 3.8 → 3.12
      https://github.com/mugijiru/ember-rails-todo-app/pull/68

      3.8 に上げるよりはちょっと面倒だった。

      が、基本的には

      1. ~ember-cli-update --to 3.12~
      2. ~yarn~
      3. ~ember-cli-update --codemods~

      を叩いてるだけである。

      とりあえず [[https://github.com/mugijiru/ember-rails-todo-app/pull/68/commits/cd7e96493dc9f52c67ee499801144c25b54a4d36][codemods で結構変更があった]] ので、それを軽く話すと

      - handlebars で AngleBraket を使うようになった
        - 3.4 からサポートされ始めてるけど 3.10 でちゃんと使えるようになったっぽい
      - handlebars でコンポーネントに値を渡す時に ~@hoge={{value}}~ みたいに ~@~ をつけるようになった
        - これで component の変数か、単なる HTML の属性値かの区別がつくようになったっぽい
      - model が ~ember-data~ ではなく ~@ember-data/model~ を import するようになった
        - この頃から個別機能を import させる方針になり始めてるっぽい

      という感じ。
      モダンっぽいし、こっちの方が好みの書き方ですね。

      あとは Observer を使ってるところが eslint で怒られていたけど
      直すのが大変そうだったので eslint の方を無視するようにしちゃった。
      まあ、これよりずっとあとの手順で直してるんだけども。

***** 3.12 → 3.16
      Octane が入って来てるからか、
      ember-cli-update での差分も大きく、
      動くようにするまでにいくつかやることがあった。

      まずはいつものように

      1. ~ember-cli-update --to 3.16~
      2. ~yarn~
      3. ~ember-cli-update --codemods~

      を実行。
      で、[[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/da37e4342c120a4c73a88f7b72ee7344d07eb3e6][ember-cli-update したところで]]
      app.js が書き換えられて自分の設定が消えたのを直すハメになったり
      同じく config/environment.js が書き換えられてそれも直すハメになったりしてた。
      新しい文法にするのはいいけど設定を吹っ飛ばすのはやめてほしい。

      あと config/optional-features.json で jquery-integration が false にされたのもいただけなかった。
      [[https://github.com/rondale-sc/ember-cli-rails-addon/blob/master/app/initializers/ember-cli-rails-addon-csrf.js][ember-cli-rails-addon-csrf]] 的に必要なんだよぉ。

      あとは [[https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/][Ember.js Octane vs Classic Cheat Sheet]] を参考に書き換えた。

      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/5a2d971f18fa3da9d3f45c344666e7c134b2bf4a][hbs の書き方がさらに変わったので修正]]
        - 親から貰った受け取ったプロパティは @ を prefix とするように変更
        - 自身の持つプロパティは this. を prefix とするように変更
        - ~@click=~ で定義していた click イベントは on を使うように変更
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/ed3e7e3c1fdac5a88277fafa6c5ce42a603ff9cb][jQuery に頼ってた部分を素の JS に書き換え]]
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/0f4113e6a918dbfd5f75500370fd2e00486d1cec][Component の action の書き方などの変更]]
        - actions で囲むのではなく ~@action~ というデコレータをメソッドにつける方法になった
        - form の button を叩いた時に submit されるようになってしまったので preventDefault で送信されないようにした
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/3362321970ed616212ce1250fec3555eba434bd4][Controller の action などの書き方などを変更]]
        - actions で囲むのではなく ~@action~ というデコレータをメソッドにつける方法になった
        - こっちでも jQuery に頼ってたのを直した

      ということをやっている。

      設定が変わってるのをちゃんと戻す作業とか
      jquery-integration の問題とか
      書き方が色々変わったりしているので、なかなか苦労した。
      hbs は結構変わってるしね……。

      まあでも大体そんな感じのことをしたらなんとかなる。

***** 3.16 → 3.20
      https://github.com/mugijiru/ember-rails-todo-app/pull/71

      これは

      1. ~ember-cli-update --to 3.16~
      2. ~yarn~
      3. ~ember-cli-update --codemods~

      だけで済んでるのでちょー楽だった

***** 2.18 → 3.4 for @mugijiru/ember-components
      ここで突然別の流れをぶち込むハメに。

      というのも ember-todo-rails-app の Ember.js を 3.24 に上げようとしたら
      その中で使ってるコンポーネントである @mugijiru/ember-components の方を更新しないと
      上げられない状態になってしまったから。

      多分 Classic な書き方がダメなんだろうなという推測で、
      こっちも Octane 対応をしないといけないな、という判断になった。

      で、こっちも段階的に上げていくわけですが、
      ひとまず 3.4 にするにあたり
      ember-rails サポートも切っておく方が楽なので

      - https://github.com/mugijiru/ember-components/pull/5
      - https://github.com/mugijiru/ember-components/pull/6

      で 2.18 のままだけど Gem のサポートをやめて module を使う仕組みに書き換えている。
      ember-rails でなければ古い書き方をする必要はないのだ。

      そしてさらに https://github.com/mugijiru/ember-components/pull/7 で 3.4 に上げている。

      コード変更で面倒だったのは

      - [[https://github.com/mugijiru/ember-components/pull/7/commits/7bf7f7c7905af7a671d84b25991b9ceb68800048][codemods 適用]]
        - テストの書き方が多少変わってるのでそっちを覚えないといけない
      - [[https://github.com/mugijiru/ember-components/pull/7/commits/b70537441d63aa6f9efafa03c407ef30973461c5][test 用に読み込むパッケージ名の修正]]
        - package.json でパッケージ名が修正されたのに伴う変更。まあこうあるべきって感じ。
      - [[https://github.com/mugijiru/ember-components/pull/7/commits/a6505609e2ccf2c8d17ee703cc1aa7cff2847aea][テストでのレンダリングの仕組みが変わったようなので対応]]
        - どうもレンダリングで Wrapper になる div が入るようになったっぽいので雑に div で取ってたのが動かなくなった

      あたりかな。
      パッケージ名の修正と div のやつはどっちも気付くのに時間がかかってしまったやつ。つらかった。

***** 3.4 → 3.8 for @mugijiru/ember-components
      https://github.com/mugijiru/ember-components/pull/8

      まあ難しいことをしなくても普通に上がったやつですね。はい。
      なので詳細はいいや。

***** 3.8 → 3.12 for @mugijiru/ember-components
      https://github.com/mugijiru/ember-components/pull/9

      これもあっさり上がったので特筆することなし

***** 3.12 → 3.16 for @mugijiru/ember-components
      - https://github.com/mugijiru/ember-components/pull/10
        - 3.16 に上げたのはこっち
      - https://github.com/mugijiru/ember-components/pull/12
        - 3.16 に上げただけだと修正が足らなかったので追加修正したやつ

      いつもの手順はもういいとして、
      特別にやったことは

      - [[https://github.com/mugijiru/ember-components/pull/10/commits/8bc5e01b97e1740601a4710496d28d6840ce6e4d][hbs の書き方を新しい形式に合わせた]]
        - this をつけただけだけど
      - Component の書き方修正([[https://github.com/mugijiru/ember-components/pull/10/commits/654619191256c8a778440007fab2c9f16185f247][mg-button]], [[https://github.com/mugijiru/ember-components/pull/10/commits/9b4beeec63023fecb43b5208a1f324030916e4b0][mg-checkbox]], [[https://github.com/mugijiru/ember-components/pull/10/commits/7c2b92a8a1634b0a1d4fa1d8dc3fd02732cf9525][mg-toggle-switch]])
        - addon/templates/components/*.hbs から addon/components/*.hbs に移動
          - どうもいつの間にか templates/components に置かなくて良くなったっぽい
            - さらに新しい [[https://cli.emberjs.com/release/advanced-use/project-layouts/#podslayout][pods layout]] というのもあるけど addon の場合は互換性維持のために classic 推奨。
        - import 元を ~@glimmer/component~ にして Native Class を用いた記述に変更
          - これまで ~export default Component.extend~ していたのが ~export default class Hoge extends Components~ という書き方になった
          - Native Class になったのでプロパティも普通に ~hoge = 'fuga'~" みたいに書くようになった
        - className, classNameBindings は使えなくなったので調整
        - 親から渡って来るパラメータの初期値調整のための記法の使用
          - ~get hoge () { return this.args.hoge ?? '' }~ のようにしてデフォルト空文字列にするなど
            - 親から渡って来るパラメータは ~this.args~ のように隔離された場所に入るようになってる。便利。
      - [[https://github.com/mugijiru/ember-components/pull/12][Click が実行されない問題の修正]]
        - onClick というパラメータで渡って来たやつをクリック時に実行するように調整している

***** 新しい @mugijiru/ember-components に更新

      https://github.com/mugijiru/ember-rails-todo-app/pull/72

      MgButton とかに ~{{on "click" this.save}}~ とかでアクションを渡せていたのが
      ここからは ~@onClick={{this.save}}~ のように渡さないといけない。
      なぜなら @mugijiru/ember-components を Octane 対応する際にそういう風に仕様が変わったからだ。

      https://guides.emberjs.com/release/in-depth-topics/patterns-for-actions/
      を見た感じ、そうするのが正しいっぽい。
      ただの button には ~{{on "click" this.save}}~ というように書くことになるので
      混乱がありそうでだるいけど。

***** 3.20 → 3.24
      @mugijiru/ember-components の Ember.js を 3.16 にして Octane 対応を済ませることで
      ember-rails-todo-app の Ember.js を 3.24 に上げられるようになった。

      https://github.com/mugijiru/ember-rails-todo-app/pull/73

      ここではあんまり対したことはしてないけど
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/73/commits/9268c5414c2c3052c2537fa1e2dacc0b4ee55886][active_model_serializer を使うことを明示的に書かないといけなくなった]]
      というのが一番だるいポイントかな。
      これも原因判明までに時間食ったやつ……。

***** 3.24 → 3.26(最新)
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/74][ember-bootstrap を 4系に上げた]]
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/76][Ember.js を最新化し、文法も最新に合わせて書き直した]]

      あたりで、最新化できた。
      ember-bootstrap は上げられるから上げておいただけだけども。

      - native class としてクラス定義するように変更
      - @tracked, @sevice, @action, @attr などのデコレータを使うように変更
      - computed property は tracked を使う書き方に置き換え
      - set, get を使った書き方も古いので ~this.get('hoge')~ などを ~this.hoge~ みたいに書き換え

      あたりのことをしている。
      結構変更は多いけど、まあ、基本的に lint のいうことに従って対応しただけである。

      ひとつ initializer で current-user を無理やり inject している処理が
      Native Class に置き換えできなかったので、
      ここはどこかでなんとかしないとまずそう。多分 Ember.js@4 に追従できなくなる
      https://github.com/mugijiru/ember-rails-todo-app/pull/76/commits/f6b6ed65863a9e94ed1b41154387e87e4f0da1bf

      User class を用意して instanceInitializer でそこに突っ込んでやるとか、
      Service class を用意したりしたら、なんとかなりそうな気はしている。

***** 3.16 → 3.20 for @mugijiru/ember-components
      アプリ本体だけでなく addon も最新化対象である。
      https://github.com/mugijiru/ember-components/pull/13

      3.20 に上げるのは何も問題なし。
      3.16 に上げる時に苦労したからねえ。

***** 3.20 → 3.24 for @mugijiru/ember-components

      https://github.com/mugijiru/ember-components/pull/15

      3.24 に上げるのも特に苦労なし。

***** 3.24 → 3.26(最新) for @mugijiru/ember-components
      https://github.com/mugijiru/ember-components/pull/16

      基本的には難しいことなし。
      ただし Interactive な要素じゃないのに click させるなって eslint に怒られてたから
      MgChecobox や MgToggleSwitch を div から button に変更した。
      https://github.com/mugijiru/ember-components/pull/16/commits/d9f14499f92584479fe7154879003bfd5f237f03

      ~input type="checkbox"~ が良い気もするけど、ま、一旦いいや。

***** 最新の @mugijiru/ember-components 取り込み
      https://github.com/mugijiru/ember-rails-todo-app/pull/77

      最新化する際に、
      div から button に書き換えた影響で style 崩れがあるので調整している。

      @mugijiru/ember-components 用の css は addon 側に置いても良いよなあと思ってるけど
      今回はそこは放置している。めんどくさくて。

**** 最後に
     ゴールデンウィークをこれで結構消費してしまったのでちょっと残念な気持ちになっている。

     けどまあ、どこで引っ掛かりやすいかは結構洗い出せたので良い。

     - 3.8 → 3.12 :: codemods で結構変更される
     - 3.20 → 3.24 :: addon が 2.18 で使えるような古い書き方だと使えなくなる
     - Octane 対応 :: 書き方が色々変わる。古い書き方も一部まだサポートされてそうだけど。

     とりあえず Octane が鬼門かねえ。
*** DONE ember-rails アプリケーション保守入門              :@Rails:@Ember_js:
    CLOSED: [2021-05-24 月 09:02]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-introduction
    :END:
    ちょっとした事情で Ember.js 入門的なサムシングをすることになったけど
    どうせなら公開情報にしちゃえって気持ちになったので
    資料化する前にブログの記事にしちゃうぞ、というエントリです。

**** 想定する読者
     携わっているシステムが ember-rails を利用して作られているために
     令和になっても 2018 年にサポートが切れてしまった Ember.js@2.18 のアプリケーションを
     なんとか動かし続けないといけない哀れな子羊たち

**** 記事を書いている人
     Rails と Ember.js と Vue.js での開発をしたことがある人。
     React や Angular はやったことない。
     なので比較には Rails と Vue.js を出しがち

**** この記事で書かないこと
     既に存在してしまっている ember-rails アプリケーションの保守をする人達向けの記事なので、
     ember-rails を使って新規で Ember.js アプリを構築する、みたいなことは書きません。

     それに今更 ember-rails で構築するのはよろしくないですし、
     Rails で Ember.js やりたいなら [[https://github.com/thoughtbot/ember-cli-rails][ember-cli-rails]] にしておいた方が良いですよ。

     どうしても構築から知りたい人は
     [[https://github.com/mugijiru/ember-rails-todo-app/compare/9f190efb6320e19a80768b0c6a37e1929e9c4146...b18270e90c694f14e0fac5df2cb9aadad41376c5][ember-rails-todo-app で ember-rails アプリを構築したあたりのコミット]]
     を見たりとかしたらなんとなくわかるかもだけど
     まああんまり要らないよね。

**** Ember.js と ember-rails の簡単な紹介
***** Ember.js とは
      [[https://emberjs.com/][Ember.js]] はWebフロントエンドMVCフレームワークの1種。
      昔流行ったよね WebフロントエンドMVC。
      残念ながら最近はもう主流ではない。

      Ruby on Rails の影響を受けてるようなので、
      Rails エンジニアが取っ付きやすいフレームワークになっている。多分。

***** ember-rails とは
      [[https://github.com/emberjs/ember-rails][ember-rails]] は Ember.js をいい感じに Rails と連携してくれる素敵な Gem です。
      これを使うと Rails 上で動く Ember.js アプリケーションが簡単に作れる。

      Ember.js 自体が [[https://rubygems.org/gems/ember-source/versions/2.18.1?locale=ja][ember-source]] という Gem を提供してくれていたので
      それらのソースも依存関係で入って来てくれる便利なやつ。

      だけどそういう蜜月も Ember.js@2.18 の頃までのお話なので
      今から新規で Rails の上で Ember.js を触りたい子は
      大人しく [[https://github.com/thoughtbot/ember-cli-rails][ember-cli-rails]] を使いましょう。

**** Rails 側の設定

***** Gem の install
      #+begin_src ruby
      gem 'ember-rails'
      gem 'active_model_serializers', '~> 0.9.0'
      #+end_src

      多分このあたりを入れておけば良い。
      active_model_serializers は
      [[https://github.com/emberjs/ember-rails/blob/3ff45327d1320376715b365f0319192a35dc1d56/ember-rails.gemspec#L16][ember-rails の gemspec でバージョン指定がされてない]] けど
      Ember.js 側で使う active-model-adapter が 0.9 系対応なので
      バージョンをこちらで固定している。

      実は ember-rails-todo-app 1.x では
      [[https://github.com/mugijiru/ember-rails-todo-app/blob/21241d30fe4f9987760bd18bc2341b1943de26fe/Gemfile#L39-L42][jquery-rails や ember-source も指定している]] けど
      多分わざわざ指定しないでいい気もする。

***** config.handlebars.template_root
      ember-rails ではこれで指定されているフォルダが Ember.js の Template として利用される。
      デフォルト設定だと ~app/assets/javascriptes/templates~ が指定されている。

      複数の Ember.js App が動くようになってる場合には
      config/application.js あたりで複数設定されているはず。

      もし新しくテンプレートを放り込む場所を増やしたかったらここを弄る必要あり

**** Ember.js の基礎
***** EmberObject
      Ember.js では EmberObject というものが全体的に使われている。

      こいつは Ember.js で使う Class 的なやつのベースとなる機能を提供する。
      例えば Computed Property や Observer がそれにあたる。

      以下では EmberObject のよく使う機能について
      Vue.js の props, data, computed, watch, methods あたりと比較しながら解説する。

****** 通常のプロパティ
       Vue.js における data にあたるもの。

       EmberObject は、JS の Object でもあるので、
       普通に JS Object のプロパティとして定義したら Vue.js の data 的に扱える。

       #+begin_src js
       export default Ember.Object({
         width: 200,
         height: 200
       })
       #+end_src

       参照したり更新したりする時は

       #+begin_src js
       this.get('width') // 参照
       this.set('width', 300) // 更新
       #+end_src

       のような書き方になります。正直だるい。

       で、上で「Vue.js でいう data にあたるもの」と書いたが、
       Vue.js でいう props と data 的な区別は特にないので、
       外から簡単に書き換えられる値でもある。

******* 3系では
        3系だと EmberObject は使わなくなって JS の Native Class なので

        #+begin_src js
        width = 200
        height = 200

        hoge() {
          this.width = 200
        }
        #+end_src

        みたいな感じに書ける。

        また Vue.js でいう props 的なのは
        ~this.args~ の中に閉じ込められるし、
        値が変に上書きされることもない。便利。

****** Computed Property
       Vue.js の Computed Property のように
       通常のプロパティから新しい値を導出してプロパティとして使えるようにするやつ。
       Vue.js のそれと同様にキャッシュされるしリアルタイムに反映される。

       書き方は Vue.js よりちょっとだるくて

       #+begin_src js
       fullName: Ember.computed('firstName', 'lastname', function () {
         return `${this.get('firstName')} ${this.get('lastName')}`
       })
       #+end_src

       みたいな感じ。
       Vue.js だと

       #+begin_src js
       computed: {
         fullName() { return `${this.firstName} ${this.lastName}` }
       }
       #+end_src

       で済むのになって思うことはある。

       ただ、別名でも取れるようにしたり(alias)とか、全部足したり(sum)とかのよくあるやつは
       関数が定義済なので a と b を足した c が欲しい場合は

       #+begin_src js
       c: Ember.computed.sum('a', 'b')
       #+end_src

       とか書けるのでそれは便利かもしれない。
       https://api.emberjs.com/ember/2.18/modules/@ember%2Fobject#functions-computed

******* 3系では
        3.15 以降だと
        [[https://guides.emberjs.com/release/upgrading/current-edition/tracked-properties/][Tracked Property]] というのを使うのが推奨されている。
        まだ使えるけどね Computed も。

        `@tracked` というデコレータが付与されたプロパティは値の変更が検知されるようになる。

        また 3.15 以降では JS の Native Class になるので
        Tracked Property と Getter を使って

        #+begin_src js
        @tracked firstName
        @tracked lastName
        get fullName() { return `${this.firstName} ${this.lastName}` }
        #+end_src

        みたいに書ける。便利。
****** Observer
       Vue.js の watch のようなやつ。
       値を監視して、変更があったら関数が実行されるやつ。

       #+begin_src js
       Ember.Observer('hoge', function () {
         console.log('"hoge" is changed!')
       })
       #+end_src

       みたいな感じで使う。

******* 3系では
        Observer もまだ使えるけど、
        Tracked Property を使ってなんとかするのが推奨されている。

        上の例みたいにログだけ残したい時どうしたらいいんだろうね。

****** Methods
       これは普通に関数を書けばいいだけ。

       #+begin_src js
       hoge () {
         // なんらかの処理
       }
       #+end_src

       ~methods~ とかいうところに書かなくていい分 Vue.js より楽ではという気もする。

***** Handlebars
      Ember.js で採用されているテンプレートエンジンです。
      変数の呼び出しに ~{{foo}}~ みたいな感じにするやつです。

      Ember.js ではコンポーネントを呼び出す時にも
      ~{{my-component}}~ みたいに使います。

      上記の書き方はインラインコンポーネントの呼び出し方で
      ブロックコンポーネントは

      #+begin_src hbs
      {{#my-block-component}}
        ...
      {{/my-block-component}}
      #+end_src

      みたいな感じになります。

      変数を渡す時は

      ~{{my-component hoge=fuga}}~

      みたいな感じ。
      Vue.js と比べて見た目以外はそんなに変わらないかなって。

***** Ember.js のフォルダ・ファイル構成
      ここでは ember-rails を前提として話します。

      | フォルダ・ファイル    | 概要                                                              |
      | adapters              | サーバとの通信周りを設定するコードを置く場所                      |
      | components            | コンポーネント定義の JS ファイルを入れるところ                    |
      | controllers           | Rails でもお馴染みの Controller                                   |
      | initializers          | 初期化用コードを入れるところ                                      |
      | instance-initializers | アプリ起動直後の初期化コードを入れるところ                        |
      | helpers               | Rails でもお馴染みに Helper                                       |
      | mixins                | Rails だと Concern にあたるものを置くところ                       |
      | models                | Rails でもお馴染みの Model                                        |
      | routes                | Controller 実行前に Model などを取得したりするところ              |
      | routor.js             | Routing を設定するところ。Vue.js の Router と似てるかも?          |
      | serializers           | サーバと通信する前に形式変換するコードを置く場所                  |
      | templates             | Handlebars という HTML テンプレートを置く場所。Rails でいう views |
      | views                 | 使わない。Ember.js@1系の名残りかと                                |

**** Ember.js アプリにアクセスした時の処理の流れ
     ざっくり書くと

     1. EMBER_ROOT/application.js.es6 のコード実行
     2. EMBER_ROOT/{APP_NAME}.module.es6
     3. initializer 実行
     4. instance-initializer 実行
     5. routor/routes の実行
        1. beforeModel()
        2. model()
        3. afterModel()
     6. Controller の実行
     7. templates のレンダリング

     という流れ。
     これは Ember.js@3.26 でも大体似てる。1,2 あたりがちょっと違うけど。

***** EMBER_ROOT/application.js.es6 のコード実行

      単にこのあたりで色々なものを require したり
      Ember.js App を呼び出したりしているのでここからスタートだよねってだけ。

      Sprockets で require した順に実行されるので、以下の順序は大事っぽい。

      #+begin_src js
      //= require ./environment
      //= require ember
      //= require ember-data
      //= require ember-rails/application
      //= require active-model-adapter
      #+end_src

***** EMBER_ROOT/{APP_NAME}.module.es6

      require でアプリケーション本体の色々なコードを読み込んだり
      設定を読み込んだりしている部分。

      require される対象は Class みたいなものなのであまり読込順は関係なさそう。

      module 化されてない場合は
      ~require router~ と ~require_self~ は最後じゃないとまずそうだけども。

***** initializer 実行

      Ember.js App の起動時に実行される処理。

      initializers フォルダに配置されていて

      #+begin_src js
      export function initializer(application) {
        ...
      }
      #+end_src

      みたいに書かれているファイルが実行される。
      アプリケーション初期化用のコード(ex: Websocket の初期化)とか
      DI で組込みたい service の injection のコードを入れておくと良いっぽい。

      initializer が複数ある場合の実行順はどうなってるかわからんけど
      [[https://guides.emberjs.com/v2.18.0/applications/initializers/#toc_specifying-initializer-order][「これより先に」「これより後で」みたいな指定]] はできる。

***** instance-initializer 実行

      Ember.js App が起動直後に動く処理。

      instance-initializers フォルダに配置されていて

      #+begin_src js
      export function instanceInitializer(application) {
        ...
      }
      #+end_src

      みたいに書かれているファイルが実行される。
      インスタンス化・起動後に動くので、
      A/B テストみたいに見ている人毎に違う条件を埋め込むとかしたい時に使うのが良いらしい。

***** routor/routes の実行

      初期化処理が済んだら routor が実行される。

      #+begin_src js
      Router.map(function () {
        this.route('root', { path: '/' })
        this.route('posts', { path: '/posts' }, function () {
          this.route('new')
        })
      })
      #+end_src

      みたいに書かれていて、
      path にマッチした route が実行されるようになっている。
      Vue Router なんかもそういう作りだよね。

      Ember.js の Router は Vue Router とは違って直接コンポーネントが呼び出されるのではなく
      routes 以下にある Route が呼び出されるようになっている。
      読まれるファイルは ~this.route~ の第一引数にマッチしたやつですね。

      上の例では ~/~ というところにアクセスした場合には
      ~routes/root.module.es6~ が実行されるという仕組み。

****** beforeModel()

       ~model()~ が実行されるより前に動く処理。
       ログイン状態チェックしてログインしてなければ別のルートに飛ばす、
       みたいに、あまりアプリケーションのModelと関係ない処理をする時に使えば良さそう。

       正直あまり出番ない。

****** model()

       その画面で使う Model を取得する処理。
       ここで return された値が Controller や Template で model としてアクセスできるようになる。

       また Promise を返した場合は、それが解決された時の戻値を model として使えるようにしてくれる。

       store.findAll などは Promise を返すが、
       Promise の解決結果を Model とする挙動のおかげで

       #+begin_src js
       model() {
         return this.store.findAll('posts')
       }
       #+end_src

       とした場合に Controller などでは ~this.get('model')~ で ~posts~ が取得できるようになっている。

******* 複数の model

        1画面で複数の Model を使いたい場合には

        #+begin_src js
        return {
          foo: hoge,
          bar: fuga
        }
        #+end_src

        みたいに書けば良い。

        Controller とかで ~this.get('model.foo')~ みたいにして扱える。

****** afterModel(model)

       model を取得した後で、画面を表示する前にやっておきたい処理を書くところ。
       第一引数で model が渡されてくるので、
       model の状態を見て別の route に飛ばすとか、controller に値を放り込むとかの処理ができる。

****** 入れ子になった Route

       上の例にも書いたけど Route はネストさせることもできる。

       例えば ~/posts/new~ という route の場合は
       画面表示的には ~/posts~ というレイアウトの中に登録フォームを表示する、
       みたいな時に使う

       このあたりは [[https://router.vuejs.org/ja/guide/essentials/nested-routes.html][Vue Router の Nested Route]] と似てるよね。
       どっちが先か知らんけど。

       で、そうやってネストさせている場合は、一番外側の Route から順に実行されるような感じになっている。

       つまり上記の例だと ~posts.module.es6~ の ~model()~ なんかが実行された後に
       ~/posts/new.module.es6~ の内容が実行される。

       上位の path の route が既に実行されているので
       下位の path で上位の model 情報を使いたい場合、
       上記の例だと ~/posts/new~ で ~posts~ の model 情報を使いたい場合には
       [[https://api.emberjs.com/ember/3.26/classes/Route/methods/modelFor?anchor=modelFor][modelFor()]] という関数で ~const posts = modelFor('posts')~ みたいに取得できる。

***** Controller の実行
      Route での処理が済んだら Controller の処理が実行される。
      というか Route から [[https://api.emberjs.com/ember/release/classes/Route/methods/setupController?anchor=setupController][setupController]] というので呼び出される。

      呼び出される Controller は route と同じように path にマッチしたやつになる。
      つまり ~/posts~ という path なら
      ~controllers/posts.module.es6~ で定義している Controller が呼び出される。

      Controller では Template で使う値を設定したり Action を定義したりする。

***** Template のレンダリング
      Controller の処理が済んだら Template のレンダリングに入る。
      呼び出される Template は Controller の path と一致する。

      つまり ~/posts~ という path なら ~templates/posts.hbs~ が呼び出される。

      Template は Handlebars 形式で記述する。

**** Ember.js の Component
     Ember.js の開発で一番弄る機会の多いのが Component です。

     components フォルダに JS のロジックが書かれたファイルが置かれ、
     対応するテンプレートは、
     templates/components フォルダに Handlebars で記述した hbs ファイルとなる。

     JS のロジックが書かれる Component は [[*EmberObject][EmberObject]] がベースなのでそれらの機能が使える。
     さらに Component 用の機能が追加されている。

***** 値の渡し方
      [[*Handlebars][Handlebars]] の方でも書いたけど
      ~{{my-component hoge=fuga}}~ というように書けば良いです。

      そうすると MyComponent 内で
      ~this.get('hoge')~ で値が取得できるようになり、
      そのテンプレート内で ~{{hoge}}~ で参照できるようになります。
***** Component のタグのカスタマイズ
      古い Ember.js では Component を呼び出すと
      Wrapper となる div が挿入されてその中に Template で書いた記述が入るようになっています。

****** tagName
       Wrapper のタグを指定する。
       ul の下にリストアイテムをコンポーネントとして配置したい時は
       ~tagName: 'li'~ とかやったりする。

****** classNames
       Wrapper タグに付与する class のリスト。
       こちらは固定の値になる。
****** classNameBindings
       Wrapper タグに、条件に応じて付与する class のリスト的な。
       Vue.js の class の Binding に似ていて

       #+begin_src js
       isActive: false
       classNameBindings: ['isActive:active']
       #+end_src

       みたいに書くと isActive が true の時に `active` というクラスが付与される。

       Vue.js だと

       #+begin_src html
       <div :class="{ active: isActive }">
       #+end_src

       となるので書き方が逆だけどね。

****** 3系では
       3.15 以降では Vue のコンポーネント同様に余計な Wrapper が入らなくなります。
       なので tagName, classNames, classNameBindings とは全ておさらばとなります。

***** Actions
      テンプレート内のボタンを叩いた時に動かしたい関数なんかを記述するところ。

      #+begin_src js
      actions: {
        hoge(){
          // なんか処理を書く
        }
      }
      #+end_src

      みたいな感じで書く。

****** Template で直接使う場合
       Template から直接アクションを呼びたい時は

       #+begin_src hbs
       <button type="}button" {{action "hoge"}}>
       #+end_src

       みたいに書くと、そのボタンを押した時に hoge アクションが動く。
       https://guides.emberjs.com/v2.18.0/components/triggering-changes-with-actions/#toc_designing-the-child-component

****** 下位のコンポーネントに渡す場合

       #+begin_src hbs
       {{child-component foo=(action "hoge")}}
       #+end_src

       というように書いて渡すと、child-component では
       foo というメソッドが定義されていて、その実体は親コンポーネントで定義した hoge アクション、という状態になる

       なので child-component 内のアクションを

       #+begin_src
       actions: {
         fuga() {
           this.get('foo')()
         }
       }
       #+end_src

       というように書いて child-component のテンプレートで fuga アクションを実行したら
       親コンポーネントの hoge アクションが実行される、みたいな挙動になる

       参考: https://guides.emberjs.com/v2.18.0/components/triggering-changes-with-actions/#toc_passing-the-action-to-the-component

***** LifeCycle Hooks
      [[https://guides.emberjs.com/v2.18.0/components/the-component-lifecycle/][なんかめっちゃ Hook が用意されている。]]

****** 初期化時
       1. init
       2. didReceiveAttrs
       3. willRender
       4. didInsertElement
       5. didRender

       init と didRender あたりは割と使うかな?
       didRender は再描画でも使うので
       両方に適用したい時に使う感じ。

       didInsertElement もたまに使う気がする。

****** 再描画時
       1. didUpdateAttrs
       2. didReceiveAttrs
       3. willUpdate
       4. willRender
       5. didUpdate
       6. didRender

       didRender は割と使う。
       didUpdate は初期化時には動かしたくないけど didRender 的に使いたい時に使う感じ。
       他はあまり使った記憶なし。

****** 破壊時
       1. willDestroyElement
       2. willClearRender
       3. disDestroyElement

       このあたりはあまり使った記憶がない

****** Hook の使い方
       使い方は2種類あって

       #+begin_src js
       init () {
         this._super(...arguments) // 通常の処理をさせておく
         // ここに特別な処理を書く
       }
       #+end_src

       というように hook 関数を Override する方法と

       #+begin_src js
       hoge: Ember.on('init', functoin () {
         // ここに特別な処理を書く
       })
       #+end_src

       というように [[https://api.emberjs.com/ember/2.18/functions/@ember%2Fobject%2Fevented/on][on メソッド]] を使う方法がある。

       Rails の Model で

       #+begin_src ruby
       after_save do
         # ここに特別な処理を書く
       end
       #+end_src

       と書くか

       #+begin_src ruby
       after_save :hoge

       private
       def hoge
         # ここに特別な処理を書く
       end
       #+end_src

       と書くかの違いみたいなものですね。

       私は後者の方が好み。
       間違えて二重定義したりしなさそうだし ~this._super(...arguments)~ を呼び忘れもしなさそうなので。

       まあ前者の方が ~this._super~ の呼び出しタイミングをズラせる自由さはあるけどね。
***** Block Component
      [[https://guides.emberjs.com/v2.18.0/components/block-params/][Block Component]] では

      my-component のテンプレートを
      #+begin_src hbs
      <div>
        {{yield}}
        ↑親から来たやつ↑
      </div>
      #+end_src

      みたいに書いてる状態で親から

      #+begin_src hbs
      {{#my-component}}
        hogehoge
      {{/my-component}}
      #+end_src

      みたいに呼び出すと

      #+begin_src html
      <div>
        hogehoge
        ↑親から来たやつ↑
      </div>
      #+end_src

      という感じになるやつ。

      Rails のテンプレートの yield と似てる気がするよね。
      あと Vue.js の slot にも似てる気がするよね。複数 Slot みたいなことはできなさそうだけども。

      本当はもうちょっと複雑なこともできるんだけど
      入門記事だしそこまで書くのはだるいので割愛。というか [[Block Component][Block Component]] のリンク先読んで。

***** フォルダ階層分け
      最新の Ember.js だと素直にいけるのに ember-rails かつ古い書き方だと苦労する問題の1つ。

      [[*ember-rails でコンポーネントをサブフォルダに配置する][ember-rails でコンポーネントをサブフォルダに配置する]] に全部書いているけど
      ざっくり書くと
      template で ~{{hoge/fuga}}~ というように呼び出した場合に
      GlobalResolver では Hoge という名前空間の Fuga というコンポーネントを探しに行くようになっている。

      つまりコンポーネントを
      ~App.HogeFugaComponent~ ではなく
      ~Hoge.FugaComponent~ として定義する必要がある。
      そして名前空間 Hoge を ~window.Hoge = Ember.Namespace.create()~ みたいにして用意しておく必要もある。だるい。

      試したことはないけど、さらに1階層増やすとしたら、また同じようにすることになりそうでさらにだるそう。

***** 3系でのテンプレートの配置
      3.15 以降では components に hbs を置けるようになるよ。
      JS ファイルと場所が近くて便利。

      さらに [[https://cli.emberjs.com/release/advanced-use/project-layouts/#podslayout][Pods layout]] という構成が使えて
      機能群毎にまとめるのが便利になる。

      Pods layout はコンポーネントだけではなくて
      model, controller とかの構成もフォルダに閉じ込められるので多分便利。
      まだ試したことないけど。

**** Model(Ember Data)
     大体 Route で Controller にセットされる子。
     Rails の Model に似せて作られている。

     [[*EmberObject][EmberObject]] ベースで作られているので、当然そのあたりの機能も使える。
     computed とかね。
***** Store の操作
      データを取得したりまとめて消したりする際に使う。
      Rails でいうと ActiveRecord モデルの Class Method を叩く感じ。

      参考: https://api.emberjs.com/ember-data/2.18/classes/DS.Store

      以下ではよく使うものをピックアップして簡単な説明をしています。

****** findAll/peekAll
       どちらも対象のレコードを全件取得するメソッド。

       違いは peekAll の方はフロントエンドの Store 内の検索に留まり、
       findAll はデータがなければサーバにまで取りに行く。

       ~store.findAll('user')~ みたいに使う。
****** findRecord/peekRecord
       findAll/peekAll のレコード単体版。違いも同じ。

       ~store.findRecord('user', 1)~ とすると
       id が 1 の User を探しに行く。
****** query/queryRecord
       findAll ではクエリパラメータを付けられないので検索画面などは作れない。
       そんな場合は query を使うとパラメータを付与してリクエストを投げられる。
       それの単体レコード版が queryRecord となる。

****** create
       #+begin_src js
       this.store.create('user', { firstName: 'Taro', lastName: 'Yamada' })
       #+end_src

       みたいな感じでデータを作成できる。

****** push/pushPayload
       push は Object から Store にレコードを作る処理。


       #+begin_src js
       store.push({
         {
           "user": {
             "id": 1,
             "first_name": "Taro",
             "last_name": "Yamada"
           }
         }
       });
       #+end_src

       とかやるとレコードが Store 上に作られる。
       無理矢理サーバから持って来たデータを Store に突っ込む時に使う。

       pushPayload はそれの便利版で

       #+begin_src
       {
         "users": [{
           "id": 1,
           "first_name": "Taro",
           "last_name": "Yamada"
         }],
         "posts": [{
           "id": 1,
           "title": "Awesome Blog Post",
           "body": "..."
         }]
       }
       #+end_src

       みたいなのを受け取ると users と posts をそれぞれ複数レコード登録してくれる。

******* 注意
        push/pushPayload の例で書いている JSON は ember-rails で使う active-model-adapter 前提で書いています。
        デフォルトだと JSON:API 形式を受け付けるようになっています。

***** Model の操作
      peekRecord などで取得した Model に対しての操作。
      更新したり削除したりはこれで行う。

      参考: https://api.emberjs.com/ember-data/2.18/classes/DS.Model

      以下ではよく使うものをピックアップして簡単な説明をしています。

****** save
       取得したデータは set で値を書き換えて save で保存できる。

       #+begin_src js
       const user = this.store.findRecord('user', 1)
       user.set('firstName', 'Taro')
       user.save()
       #+end_src

       save は Promise を返すので、保存後に何か処理をしたければ

       #+begin_src js
       user.save().then((savedUser) => { /* 保存成功時の処理 */ }, (error) => { console.log(error) })
       #+end_src

       みたいなことができる。
****** destroyRecord
       #+begin_src js
       const user = this.store.findRecord('user', 1)
       user.destroyRecord()
       #+end_src

       みたいな感じで削除できる。

       save と同様に callback も受け付けている。

****** unloadRecord
       unloadRecord はサーバの実データは消しに行かず
       フロントエンドの Store から捨てるだけ。

****** reload
       サーバからデータを読み直す。

***** Model の定義
****** attr
       ~firstName: DS.attr()~ みたいに定義するやつ。
       API から取って来た値をそのまま放り込む感じである。

****** belongsTo
       ~user: DS.belongsTo('user')~
       って書いたら ~this.get('user')~ と指定した時に userId から適切なデータを探してくる感じ。
       Rails と似てますね。

       ~user: DS.belongsTo('user', { async: false })~
       としておけばサーバには探しに行かなくなるっぽい。
       対応するエンドポイントを用意してない時なんかはそうしておいた方が良い。

****** hasMany
       ~posts: DS.hasMany('posts')~
       って書いたら関連する posts を ~this.get('posts')~ で取ってこれるようになる。
       Rails と似てますね。

       ~posts: DS.hasMany('posts, { async: false })~
       としておけばサーバには探しに行かなくなる。
       hasMany の関連先のレコードが多い時なんかは
       まとめて取らない方がいいのでこの方が便利。

       その場合、別で取得する方法を考えた方が良い。

****** 3系では
       - ~@attr firstName~
       - ~@belongsTo('user') user~
       - ~@hasMany('post') posts~

       みたいにデコレータで定義する。
       option の async などをつける場合は ~@belongsTo('user', { async: false }) user~ みたいな感じ。

**** Adapter/Serializer
     どっちも普段あまり触らないところなので簡単に。

     Adapter がサーバへのアクセス方法を色々設定するところ。
     どのホストにアクセスするかとか、どの PATH にアクセスするかとか
     HTTP Header で何か渡すならそれを設定するとか。

     Serializer がデータ形式を変換するところ。
     JS 側では camelCase のキーを、サーバに渡す時には dashlize したり
     逆に dashlize されてるキーを貰う時は camelize したり。

**** Controller
     Rails の Controller とは結構違う役割の子。
     Rails ベースで考えると混乱する。

     Route と関連する特別な Component みたいな扱いなので
     Component の扱いをベースに触った方が良い。

     Component に近い立場なので
     各種 hook だったり actions だったりが使える。

     tagName や className などは使えるか調べたこともないのでわからない。

     コンポーネントツリーの根っこの Component みたいな感じなので
     大分カオスになりがちなやつ。

     正直そのカオスをどう解消したらいいかまだ分かってないが、
     恐らくここではページ全体に関するロジックだけを詰めておき、
     Component に直接 Service Object を Inject して、
     その Service Object にロジックを詰めておいた方が良いんじゃないかなと考えている。
     どこかで試してみたい。

**** Service Object
     各 Component や Controller に Inject して使う便利な Object です。
     Vue.js でいうと Vuex ぐらいどこでも使えて便利。
     つまり無闇にあちらこちらに Inject するとそれはそれでカオスになる系。

     アプリケーション全体で使うような、例えば EC サイトだと shopping-cart を Service で実装しておいて
     各 Component で Inject する、みたいな感じで使う。

**** 色々な罠達
***** Ember.js の Guide
      ember-rails だと Ember.js@2.18 までなので
      https://guides.emberjs.com/v2.18.0/
      などの古いバージョンのガイド読みましょう。

      っていうか古いバージョンのも全部残っててありがたいよね。

      ただ ember-rails でも古い書き方をしていると
      import とか使えないのでそのあたりは読みにくいと思う。
      import とかを使ってないのは 1.10 ぐらいの書き方だから……。

***** active_model_serializers という Gem の 0.10 系で動きません><
      ember-rails では active_model_adapter というのを Ember.js 側で使っています。
      そしてそれに適合する active_model_serializers gem は 0.9系となっています。
      というわけで 0.9 系を使いましょう。

***** コンポーネント呼び出し階層が深いので Controller の Action を叩くのがしんどいです
      その Action を Controller じゃなくて Service に移動して
      Component に Service を Inject して使うようにしたら良いかもしれません。

      Vue.js でいうと Vuex をあちらこちらから叩くとカオスになるように、
      Service の Inject もやりすぎるとそれはそれでカオスになりそう。

***** mixins に色々置いて共通化ウェーイ
      それあなた Rails でも Concerns に置いて後々苦労したりしませんでしたか?
      あんまり Mixin に頼るとつらいので Service に逃がすなど検討しましょう

***** ember コマンドを使いたい
      ember-cli-rails に乗り換えましょう。
      [[*ember-rails から ember-cli-rails へ][ember-rails から ember-cli-rails へ]] でその方法書いてるので参考にどうぞ。

***** Addon を入れたい! 便利そう!
      ember-rails では無理です。
      ember-cli-rails に乗り換えましょう。

***** Webpack 使えないの?
      ember-rails なら諦めましょう。
      そうじゃない場合も諦めた方がいいです。

      [[https://github.com/embroider-build/embroider][Embroider]] というプロジェクトで Webpack とか Rollup とかと連携できるように頑張ってるみたいですが
      まだ v1 がリリースされてないのでプロダクションで使うには罠がまだまだ多そうです。

***** Ember.js の単体テストを書きたい……!
      ember-rails でしたら諦めてください。

      ember-cli なら QUnit または Mocha あたりでテストが書けるので
      ember-cli-rails に乗り換えましょう。

      Ember.js 自体に黒魔術が多いようで Jest ではテストが書けませんので Jest 派はお疲れ様でした

***** CSS も Ember.js 内で書きたい!
      ember-rails なら諦めて ~RAILS_ROOT/app/assets/stylesheets~ あたりで書きましょう。おつかれさまでした。

      ember-cli を使っていたら ~EMBER_ROOT/app/styles/~ 以下に置けるらしいよ。
      https://cli.emberjs.com/release/advanced-use/stylesheets/

***** Resolver のソースってどれ?
      ember-rails をお使いで、かつ古い書き方をしているみなさんは
      ember-source の中にある GlobalResolver をお読み下さい。以上。

      ember-cli で Ember.js アプリを構築している先進的な皆様は
      Ember.js の中にある GlobalResolver ではなくて ember-resolver という Addon を見ましょう。
      ただそいつはそいつで GlobalResolver を継承しているので
      結局 GlobalResolver のソースも読まないといけないという罠がある。

      まあ v4 あたりでは継承やめるって話あるけどね
**** 最後に
     ember-rails のまま保守し続けるよりは
     ember-cli-rails に移行して3系にした方が幸せになれそうなので是非ご検討ください。

     そのあたりの対応方法は、私が書いた記事ですが、

     - [[*ember-rails から ember-cli-rails へ][ember-rails から ember-cli-rails へ]]
     - [[*ember-cli-rails の Ember.js を 2.18 から 3.4 にアップデート][ember-cli-rails の Ember.js を 2.18 から 3.4 にアップデート]]
     - [[*Ember.js@3.4 から最新の 3.26 に上げた][Ember.js@3.4 から最新の 3.26 に上げた]]

     あたりが参考になるかもです。
*** DONE Hugo の build を GitHub Actions でやることにした     :@Hugo:@GitHub:
    CLOSED: [2021-05-29 土 23:31]
    :PROPERTIES:
    :EXPORT_FILE_NAME: hugo-build-in-github-actions
    :END:

    このサイトを構築するにあたり
    いつも手元で Hugo を build して push していたけども
    まあだるいし、そろそろ GitHub Actions にも慣れて来たし
    探したら既に Action が提供されていたので
    それを使って build を自動化しました。

    「しました」って書いているけど
    実は今書いてるこの記事自体がその実験用の記事であり、
    これを書いている時点ではまだ自動化検証中。
    なので記事に乗せられるものはほとんどない。

    一応 https://github.com/mugijiru/mugijiru.github.com/tree/master/.github/workflows/build.yml
    のあたりにそれ用の workflow が入って来る予定。

    使ってるのは [[https://github.com/marketplace/actions/hugo-setup][hugo-setup]] というやつ。
    ~run: hugo~ するだけで build してくれるようで便利そう。
    minify は差分的に微妙な感じするのでとりあえず使わないことにした

    成功可否はいつものように Slack 通知するし
    push して放置したら良いのは良さそう。

    ま、これで build しないで済むようになったらちょっと楽になりそうで楽しみ。

*** DONE GitHub Actions で使ってる Action 達                        :@GitHub:
    CLOSED: [2021-05-30 日 09:50]
    :PROPERTIES:
    :EXPORT_FILE_NAME: using-actions-in-github
    :END:

    個人リポジトリでは CI などを GitHub Actions に任せている。
    で、誰かが作ってくれた色々な Action に助けられている。

    というわけでそれらを、より多く助けられてるなってやつから紹介してみようと思う。

    正直、自分が何を使ってたかを後から調べる時に
    この記事を読めば大体済むよねってなりそうなので書いている部分が大きい。
    すーぐ忘れるもん。

**** actions/checkout
     https://github.com/marketplace/actions/checkout

     多分 GitHub Actions を使ってる人ならみんな使ってる。
     だって普通チェックアウトするもんね。使うよね。

     今のところ自分は単純に checkout するのにしか使ってないが
     何気にオプションが多い。
     それらの使い方もしっかり書かれていて良い。

     普通に使う分には

     #+begin_src yaml
     - uses: actions/checkout@v2
       with:
         ref: ${{ github.head_ref }}
         submodules: true
     #+end_src

     だけで良い。これで checkout される。楽。

     自分の場合は submodule が必要だった際に

     #+begin_src yaml
       with:
         submodules: true
     #+end_src

     としてみたり、
     pull_request で動かしたいけど、
     その hash ではなく branch をチェックアウトしたい時に

     #+begin_src yaml
       with:
         ref: ${{ github.head_ref }}
     #+end_src

     としたりなどしてた。

**** lazy-actions/slatify
     https://github.com/marketplace/actions/slatify

     Slack 通知用の Action ですね。
     オプションが結構充実している。
     CI 終了後に成功/失敗を通知するのに使っている。

     Slack の方に Incoming Webhook を用意して
     そこを使ってメッセージを飛ばせるようにするやつ。

     自分の場合はこんな感じで、
     成功失敗に関わらず通知を飛ばしていて、
     ただ失敗の場合は here mention が飛ぶようにしている。

     #+begin_src yaml
     - name: Notify slack build result
       uses: lazy-actions/slatify@master
       if: always()
       with:
         type: ${{ job.status }}
         job_name: '*Build*'
         mention: 'here'
         username: 'GitHub Actions'
         mention_if: 'failure'
         channel: '#develop'
         url: ${{ secrets.SLACK_WEBHOOK }}
         commit: true
         token: ${{ secrets.GITHUB_TOKEN }}
     #+end_src

     ここではやってないけど絵文字も指定できるので便利。
     まあ Webhook 側に仕込んでいたらあまり使わないんだけども。

     元は ~homoluctus/slatify~ だったので
     ember-rails-todo-app とかでまだその設定を残している。変更しないと〜。

**** ruby/setup-ruby
     https://github.com/ruby/setup-ruby

     Ruby やるならこれだよねってやつ。

     多数のバージョンをサポートしているし
     リポジトリに .ruby-version ファイルがあればそれを見てくれる。

     Bundler 周りも cache 使ったりとかをいい感じにしてくれてとても便利。

     というわけで今のところ自分は以下の感じで間に合ってる。

     #+begin_src yaml
     - name: Use ruby
       uses: ruby/setup-ruby@v1
       with:
         bundler-cache: true
     #+end_src

**** nanasess/setup-chromedriver
     https://github.com/marketplace/actions/setup-chromedriver

     CI で Chrome でもテストしたい時に使ってる。
     Rails で Capybara でテストする時ですね。

     chromedriver のセットアップなので Capybara 使う時はこれでいいんじゃないかなって思ってる。
     [[https://github.com/mugijiru/ember-rails-todo-app/blob/a98a66ae799eb60f16569c16165d3c456d041e76/spec/support/capybara.rb#L3-L14][rspec 側でも色々書く必要があるのでだるい]] けど、まあ Chromedriver だからなのかな。

     とりあえず workflow 側ではこんな程度でしか使ってない。
     #+begin_src yaml
     - name: use-chromedriver
       uses: nanasess/setup-chromedriver@master
     #+end_src

     他のプロジェクトだとテストどうやってるのかな。今度調べてみたいね。

**** actions/setup-node
     https://github.com/marketplace/actions/setup-node-js-environment

     Node.js をセットアップしてくれる。
     自分は以下のような単純な使い方しかしてないけど、何度もお世話になっている。

     #+begin_src yaml
     - name: Use Node.js
       uses: actions/setup-node@v1
       with:
         node-version: 14.x
     #+end_src

**** reviewdog/action-setup
     https://github.com/reviewdog/action-setup

     eslint とか Rubocop とかの結果を使って GitHub 上で指摘してくれたりする
     便利なワンちゃん。

     まあ eslint や Rubocop あたりは
     [[https://github.com/reviewdog/action-eslint][reviewdog/action-eslint]] とか
     後述の [[*reviewdog/action-rubocop][reviewdog/action-rubocop]] とかを使えたらそっちを使う方が良い。

     自分は eslint は yarn を使ってるからか
     自前の NPM ライブラリを使ってるからかで、
     action-eslint だとうまく動かせなかったので
     reviewdog/action-setup で reviewdog のセットアップだけして
     自前でコマンドを叩く方法を選択している。

     というわけで

     #+begin_src yaml
     - uses: reviewdog/action-setup@v1
       with:
         reviewdog_version: latest
     #+end_src

     でとりあえず使えるようにして

     #+begin_src yaml
     - name: Run reviewdog
       env:
         REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}
         NPM_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
       run: |
         yarn --silent run eslint -f rdjson . | reviewdog -f=rdjson -reporter=github-pr-review
     #+end_src

     みたいなことをしている。

     Ember.js のテンプレートもそのうち対応しないとなあ……。

**** reviewdog/action-rubocop
     https://github.com/marketplace/actions/run-rubocop-with-reviewdog

     最近入れてみた。
     設定にもよるけど、Rubocop で引っ掛かったところについて
     PR のチェックリスト的なやつで教えてくれたり、コメントを入れてくれたりする。
     Rubocop 先生に怒られたかったので便利。

     #+begin_src yaml
     - name: rubocop
       uses: reviewdog/action-rubocop@v1
       with:
         rubocop_version: gemfile
         rubocop_flags: -a
         rubocop_extensions: rubocop-rails:gemfile
         github_token: ${{ secrets.GITHUB_TOKEN }}
         reporter: github-pr-review
         fail_on_error: true
     #+end_src

     とりあえずこんな感じの設定で使ってる。
     基本的に Gemfile の設定を使って、
     後は何か見つかったら review として飛ばしてくれるようにしている。

     rubocop_flags の ~-a~ は要るのかな……。
     少なくとも eslint の方は ~--fix~ するとかえって思ったような挙動にならなかったような……。
     まいっか。しばらくそのまま運用しよう。
*** DONE org-todo を ivy で設定できるようにするパート2               :@Emacs:
    CLOSED: [2021-06-10 木 20:53]
    :PROPERTIES:
    :EXPORT_FILE_NAME: set-org-todo-from-ivy-part2
    :END:

    [[*org-todo を ivy で設定できるようにした][org-todo を ivy で設定できるようにした]] という記事で
    org-todo を ivy で設定できるようにしたつもりだったんですけど、ダメでした。

    何がダメだったかというと
    ~org-todo-keywords-for-agenda~ という変数を使ってるのがダメだった。

    この変数、何かよくわからんタイミングで設定されたりするっぽくて
    ほとんどの場合で空の値になっていた。

    というわけで、ちょっと例の関数だと使いたい時にその値が空になっていてばかりで
    正直使い物にならない関数になっていた。死蔵していた。

    まあ俺はそんな半端な状態で放置するような男ではない。
    嘘です。1年ぐらい放置していました。
    だけど逆にいうと1年越しでなんとか対応しました。
    というのが以下の PR になります。

    https://github.com/mugijiru/.emacs.d/pull/231

    PR の description にも書いている通り
    愚直に org-todo-keywords を加工するように変更している。

    私の設定している org-todo-keywords は現在は

    #+begin_src emacs-lisp
    ((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)"))
    #+end_src

    という感じ。

    これを

    #+begin_src emacs-lisp
    (mapcar (lambda (element)
              (replace-regexp-in-string "\(.+\)" "" element))
            (--remove (string= "|" it) (cdar org-todo-keywords)))
    #+end_src

    のような処理で

    #+begin_src emacs-lisp
    '("TODO" "DOING" "WAIT" "DONE" "SOMEDAY")
    #+end_src

    みたいな感じで、キー指定の ~(s)~ や、未完了or完了状態を区切る ~|~ とかを取り除いた文字列のリストにしている。

    org-todo-keywords は本当は

    #+begin_src emacs-lisp
    (setq org-todo-keywords
          '((sequence "TODO" "|" "DONE")
            (sequence "REPORT" "BUG" "KNOWNCAUSE" "|" "FIXED")
            (sequence "|" "CANCELED")))
    #+end_src

    みたいに複数のシーケンスを持つことができるけど
    そういう使い方はしてないので、そういうケースは無視している。

    とりあえずこれでようやく ivy で org-todo を設定できるようになった。ちょっと便利になった。
*** DONE ivy を使った自作コマンドなどをテストするようにした          :@Emacs:
    CLOSED: [2021-06-13 日 15:18]
    :PROPERTIES:
    :EXPORT_FILE_NAME: testing-my-emacs-command
    :END:

    これまで Emacs Lisp のテストコードを書いてなかった。

    というのも、自分は特にパッケージを作ってるわけでもなく、
    設定ファイルを弄ってるだけなので
    動かなくなっても困るのは自分だけ、という状況なので
    まあテストしなくてもいいかな、みたいな。

    とは思っているものの、やっぱりテストコード書いてみたいよねってことで
    設定ファイルに書いている自作の関数やコマンドをテストすることにした。

**** 自作関数のテスト

     自作コマンドの内部で使ってる関数のテストを
     https://github.com/mugijiru/.emacs.d/pull/233
     で書いてみた。

     なぜそんなものをテストしているかというと、
     リファクタリングしたかったので、ならテスト書いた方がいいよね〜みたいな。

     テストコードは以下のような感じ。
     前提条件として ~org-todo-keywords~ を用意して、
     関数を実行した時の期待する結果と、実際の結果を
     should マクロを使って合っていることを確認している。

     #+begin_src emacs-lisp
     (ert-deftest test:my/org-todo-keyword-strings ()
       "Test of `my/org-todo-keyword-strings'."
       (setq org-todo-keywords
             '((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)")))
       (should (equal '("TODO" "DOING" "WAIT" "DONE" "SOMEDAY")
                      (my/org-todo-keyword-strings))))
     #+end_src

     ま、とても簡単な例だと思う。

     ちなみにこの記事や出した PR では setq を使ってるけど、
     最新のコードでは let を使うようにテストを書き直してある。

**** ivy を使った自作コマンドのテスト

     上に示した PR では
     ivy を使った処理はテストができない(しづらい)と判断し
     コマンド内部で使ってる関数だけテストしている。

     だけどやっぱり ivy を使ってるコマンド自体もテストしてみたいよねということで
     以下の PR を作った

     https://github.com/mugijiru/.emacs.d/pull/235

***** with-simulated-input の導入

      ivy を使ってるコマンドのテストで難しそうだなと思っていたのが
      ivy の操作部分のシミュレーション。

      なのだけど
      https://github.com/DarwinAwardWinner/with-simulated-input
      を見つけて解決した。

      こいつはユーザーの入力を文字列で表現して
      その通りに操作をしてくれるようなライブラリ。

      第一引数に ~"hello SPC world RET"~ みたいに入れたら
      "hello world" と入力して Enter を叩く、みたいな入力をしてくれる。
      わかりやすい。

      入力と入力の間に wait を持たせたかったら
      ~wsi-simulate-idle-time~ という関数でミリ秒単位で wait も入れられるっぽい。
      その機能はまだ使ったことないけど便利そう。

***** cl-letf による関数の差し替え

      今回テスト対象にしているコードは内部で org-mode の ~org-todo~ 関数を呼んでいる。
      だけど別に ~org-todo~ の機能をテストしたいわけではなく
      ivy を使った絞り込みで適切に値が選択されることを検証したいのである。

      というわけで cl-letf を使って
      呼んだ先で使われている org-todo を以下のように一時的に差し替える。

      #+begin_src emacs-lisp
      (cl-letf (((symbol-function 'org-todo)
                 (lambda (keyword)
                   (setq result keyword))))
        ;; ここにテストコードを書く
        )
      #+end_src

      ちなみにこの着想に到ったのは
      https://g000001.cddddr.org/3690354344
      の記事を読んだから。

      そう。私もまた壊れた flet が欲しかったのである。

      そして世の中にいい記事があってありがたいね。

***** 実際のテストコード

      以上で説明したようなやつを使って、
      以下のようなテストコードになった。

      #+begin_src emacs-lisp
      (ert-deftest test:my/org-todo ()
        "Test of `my/org-todo'."
        (let ((org-todo-keywords '((sequence "TODO" "DOING(!)" "WAIT" "|" "DONE(!)" "SOMEDAY(s)")))
              (result))
          ;; org-mode を読まずに済むように org-todo を差し替えてテストしている
          (cl-letf (((symbol-function 'org-todo)
                     (lambda (keyword)
                       (setq result keyword))))
            (with-simulated-input "DOI RET" (my/org-todo))
            (should (equal "DOING" result)))))
      #+end_src

      ~my/org-todo~ を実行したら org-todo のキーワードが ivy に表示されて
      そこから絞り込んで選択する、ということを期待したテストである。

      今回は "DOI" まで入力して候補が DOING だけになり
      そこで Enter を押すとそれが選択されることをテストしている。

      選択された結果は org-todo を差し替えた関数で
      result という変数に束縛しているので、
      それが "DOING" という文字列と一致しているかを検証しているだけ。

**** 最後に

     ところで、
     buffer の変更のテストってどうしたらいいんでしょうかね。

     何か適当なバッファを用意して関数を実行した後に
     ~(buffer-string)~ と期待値がマッチするかを確認したらいいのかな
*** DONE key-chord を使って Sticky Shift を一部実現した              :@Emacs:
    CLOSED: [2021-07-11 日 13:42]
    :PROPERTIES:
    :EXPORT_FILE_NAME: sticky-shift-with-key-chord
    :END:
    Emacs 使っていると左手小指を酷使しますよね。

    まあそれはみんな分かり切ってるので、それぞれが色々な工夫で、
    左手小指を必要以上に使わないような対応をされていると思います。

    私もそんな中の一人で、
    最近もうシフトキーを押したくないなあという気持ちになって来ました。

    というわけで key-chord を使って Sticky Shift を一部実現して
    少しだけシフトキーを押さなくても済むような状態を作ってみました。

    とりあえず以下の文章を読むのが面倒だったら
    https://github.com/mugijiru/.emacs.d/pull/324/files#diff-9fab5d4bac36f504628abcc3cea5b2a1092d96f7bd2286944d5b822c6821bb3a
    にコードがあるのでそっちを見てもらえればと。

**** 実現したこと
***** セミコロン + アルファベットで対応する大文字を出力
      プログラムを書いているとやれ camelCase だの PascalCase だので
      ちょくちょくと大文字を入力する機会多いですよね。

      というわけで、例えば ~;a~ と素早く入力したら ~A~ が出力されるようにしてみた
      というのが以下のコードになります。

      #+begin_src emacs-lisp
      (mapc (lambda (key)
              (key-chord-define-global (concat ";" (char-to-string key)) (char-to-string (- key 32))))
            (number-sequence ?a ?z))
      #+end_src

      ~number=sequence~ で a から z までのシーケンスを作成して
      ~;~ との組み合わせを key-chord に食わせて
      対応するアルファベットの大文字を渡しているというシンプルな構成。

      ~key-chord-define-global~ などは第二引数に文字列を与えると
      それをそのまま ~define-key~ の第三引数に渡すので
      あたかもそれが入力されたかのような振舞をするのでそれを利用している。

      といいつつ Hydra とか magit の上でそれをやってもうまくいかないので
      キーボード入力とは少し違う様子。
***** セミコロン2回でシフトキーが押された状態にする

      上に書いたように Hydra とか magit とかでいい感じに動かすためにはまだ足りてない。

      が、それをいい感じに解決する方法をまだ知らないので
      以下の実装により ~;;~ と入力することで、シフトキーが押されてる状態を実現している。

      #+begin_src emacs-lisp :tangle inits/70-key-chord.el
      (key-chord-define-global ";;"
                               'event-apply-shift-modifier)

      (key-chord-define key-translation-map
                        ";;"
                        'event-apply-shift-modifier)
      #+end_src

      多分本当はこんな感じで2回似たような事を書かなくてもいいやり方があるんだろうけど
      今のところこれで動くから良しとしている。

      ここで使っている ~event-apply-shift-modifier~ という関数がシフトを入力している状態にしてくれるやつで、
      類似品に ~event-apply-control-modifier~ など、修飾キー系は全部用意されている。

      これらの ~event-apply-*-modifier~ 系の関数は ~C-x @ S~ などと叩くと呼ばれたりするので
      iTerm とかの中で Emacs を動かしている勢が無理やり修飾キー入力を実現したりするために何やら設定するのにも使っているが
      今回のように sticky 的な機能を実現するのに便利なやつだったりします。
      [[https://github.com/martialboniou/emacs-revival/blob/master/sticky-control.el][sticky-control]] でも使われているしね。


**** 今後対応していきたいこと
***** セミコロン + 数字キーや記号キーの対応
      今回はとりあえずアルファベットだけ Sticky Shift に対応しているが
      やはり記号系のキーとか数字系のキーも対応できてないと
      Shift を押す機会を減らせないので
      今後はそのあたりも対応していきたい。

      なお rubikitch 氏の [[https://www.emacswiki.org/emacs/sticky.el][sticky.el]] では実現できていそうなので
      似たようなことをすれば良さそう。
***** セミコロン + アルファベットでその文字を入力したことにしたい
      今回の実装では「セミコロン+アルファベット」で **大文字をバッファに出力** できるように対応しているが
      **大文字を入力したこと** にはできてない。

      この2つの何が違うかというと
      前者しか実現できてない現状だと
      例えば magit を操作している時に ~P~ の代わりに ~;p~ を入力した場合には
      ~Quit transient!~ と表示されるだけで Pull の操作ができない状態である。

      ~;;~ で ~event-apply-shift-modifier~ しているので、
      ~;;p~ とすれば Pull の操作もできるのだが
      やはりできる限り簡単なキー入力でやりたいことを実現できるようになりたい。
*** DONE ember-cli-rails アプリで Rails6 の Deprecation Warning が出ないようにした :@Rails:@Ember_js:
    CLOSED: [2021-08-22 日 00:50]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-cli-rails-with-rails6-without-deprecation-warning
    :END:

    ember-cli-rails なアプリを Rails6 対応にしてみた。
    が、リリースされている Gem をそのまま使うと

    #+begin_quote
    DEPRECATION WARNING: Initialization autoloaded the constants ActionText::ContentHelper, ActionText::TagHelper, and EmberCliRailsAssetsHelper.

    Being able to do this is deprecated. Autoloading during initialization is going
    to be an error condition in future versions of Rails.

    Reloading does not reboot the application, and therefore code executed during
    initialization does not run again. So, if you reload ActionText::ContentHelper, for example,
    the expected changes won't be reflected in that stale Module object.

    These autoloaded constants have been unloaded.

    Please, check the "Autoloading and Reloading Constants" guide for solutions.
    (called from <top (required)> at /app/config/environment.rb:5)
    #+end_quote

    という Deprecation Warning が出てつらかった。
**** 原因
     [[https://github.com/thoughtbot/ember-cli-rails/tree/v0.11.0][ember-cli-rails@0.11.0]] 及び
     それが依存している [[https://github.com/seanpdoyle/ember-cli-rails-assets/tree/v0.6.2][ember-cli-rails-assets@0.6.2]] では
     まだ Rails6 の Deprecation Warning への対応が入っていなかった。
**** 解決方法
     よくよく調べると
     ember-cli-rails の方は既にマージされている
     https://github.com/thoughtbot/ember-cli-rails/pull/587
     で対応がされていて、
     ember-cli-rails-assets の方は
     https://github.com/seanpdoyle/ember-cli-rails-assets/pull/12
     に対応ブランチが用意されていた。

     というわけで、
     ember-cli-rails の方は master から
     ember-cli-rails-assets は上のプルリクエストのブランチを使うように
     Gemfile を書き換えるだけで済んだ。

     が、とりあえず master を見るのはいつか知らない間に更新が入りそうで怖いので
     ember-cli-rails は現在の最新の ref を取るようにしている。

     というわけで以下のような書き方になった。

     #+begin_src ruby
     gem 'ember-cli-rails', github: 'thoughtbot/ember-cli-rails', ref: '1e56a03fb8437f52dfd450454c71cffda2981d66'
     gem 'ember-cli-rails-assets', github: 'seanpdoyle/ember-cli-rails-assets', branch: 'rely-on-engine-to-load-helper'
     #+end_src

     ということを ember-cli-rails-app というリポジトリの
     https://github.com/mugijiru/ember-rails-todo-app/pull/109
     で対応した。

     なお Rails6 には
     https://github.com/mugijiru/ember-rails-todo-app/pull/106/files
     でアップグレードしている。
     結果的にはこのプルリクエストでは rails app:update して load_defaults を 6.0 にして
     関係ない Warning を潰しただけになっていたりする。
**** その他
     ember-cli-rails は
     Ruby 3.0 対応のプルリクエストも含めて結構なプルリクエストや Issue が放置されてるので
     このまま使い続けるのは厳しそうな雰囲気。

     いずれ ember-cli-rails も捨てて ember-cli 単体で動かすようにした方が良さそう
*** DONE Emacs のロックファイルと Webpack dev server の設定 :@Emacs:@Frontend:
    CLOSED: [2021-09-16 木 10:22]
    :PROPERTIES:
    :EXPORT_FILE_NAME: configure-webpack-dev-server-with-emacs
    :END:
    また同じ罠を踏んだ時に同じ対応ができるようにということでメモ。

    プライベートで vue-cli とかを使って
    ~npm run serve~ とかしている時に
    ファイルを変更する度に

    #+begin_example
    [Error: ENOENT: no such file or directory, stat '/path/to/src/components/.#HelloWorld.vue']
    #+end_example

    とか怒られて辛かった。
    Emacs のロックファイルである。

    ロックファイルを生成しないというのもアリかもしれないが
    正常に保存されれば自動で消えるファイルだし
    そこに手を入れるよりは、監視対象ファイルを制限した方が良さそう、と判断して調べた。

    ~npm run serve~ では裏側で webpack-dev-server が動いているようなので
    そこで watch 対象からロックファイルを外すべく
    ~vue.config.js~ を以下のように設定した。

    #+begin_src js
    module.exports = {
      configureWebpack: {
        devServer: {
          watchOptions: {
            ignored: ['node_modules', 'public', '**/.#*'],
          }
        }
      }
    }
    #+end_src

    肝は ~'**/.#*'~ である。
    Emacs のロックファイルは ~.#~ の後にオリジナルのファイル名がくっついてくる形なので
    そいつを全部無視する、というだけ。

    これでファイルを変更しても怒られなくなってハッピー。

    ちなみに同じ問題が React の開発の時にも発生するので
    多分同じような方法で直せる。まだ試してないけど。
*** DONE Storybook の SCSS 対応でハマった                         :@Frontend:
    CLOSED: [2021-09-17 金 12:07]
    :PROPERTIES:
    :EXPORT_FILE_NAME: entry/storybook-with-scss
    :END:
    この記事は、2021年9月16日に起きたことなので、
    多分賞味期限は凄く短かい内容だけど、自分用にメモとして書いています。

    それは置いといて、汎用的なコンポーネントライブラリみたいなのを作ってみたくなったので
    趣味で Storybook を動かしてみている。

    なのでそこで流行りっぽい Storybook で作ってみているのだが
    素の CSS だと面倒なので SCSS を採用することにした。

    SCSS なのは Brace は欲しかったのと、
    ライブラリの更新が頻繁なので、更新間隔が空きがちな Stylus より良さそうと思ったから。

    というわけで ~@storybook/html~ の ~6.3.8~ を入れてるわけだけど
    そこに scss が使えるようにということで

    #+begin_example
    npm install --save-dev css-loader sass-loader style-loader
    #+end_example

    とかしたら

    #+begin_example
    npm ERR! code ERESOLVE
    npm ERR! ERESOLVE could not resolve
    #+end_example

    などと言われてしまう。

    適当に ~--legacy-peer-deps~ で突っ込んでも
    で突っ込んでも、結局は起動時にエラーになってしまう。

    で、面倒なら真面目に調べると、
    Storybook の内部で使われてる Webpack が 4 系で、
    最新の sass-loader, css-loader, style-loader だと Webpack 5 でしか動かないので
    そこで依存関係が解決できないってことがわかった。
    npm の依存関係のエラー読みにくいでござる。

    というわけで Webpack4 のサポートをしていたバージョンである

    - style-loader@2
    - css-loader@5
    - sass-loader@10

    を入れることで解決した。

    Storybook って Issue が 1300 件ぐらいそのままになってるし、
    Webpack5 対応にもなってなさそうなので、本当に使って大丈夫なのかは心配……。
*** DONE 銀座Rails#37に参加した                                      :@Rails:
    CLOSED: [2021-09-26 日 13:09]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ginza-rails-37
    :END:
    ブログ書くまでが勉強会って話もあるのでブログに残しておきます。
    正直そういうのサボりがちだけどね……。

    一昨日の夜にオンライン開催していた [[https://ginza-rails.connpass.com/event/223078/][銀座Rails#37]] に参加しました。

    今回話されたテーマは

    - Google Play IAB(In-App Billing) 〜Railsでのサーバサイド対応のすべて〜
    - Kaigi on Rails 2021タイムテーブル完全解説
    - Ruby/Railsと遠隔講義：受講者評点がリモートでも伸びた理由
    - 既存のRESTful なRails プロジェクトに、GraphQLの導入を検討した話

    の4本立てと、リンクアンドモチベーション様及び DeNA 様のスポンサーセッション。
**** Google Play IAB(In-App Billing) 〜Railsでのサーバサイド対応のすべて〜
     この話は正直私の能力不足で「なんか知らんがすごそうだ」って感じでした。
     決済周りも Google Play 周りも Android も全然わからん……。

     TL を見てると Google Play IAB は筋が良さそうみたいな雰囲気を感じた。
     あと、テーブル設計も含めた大分具体的な話もしているので
     このあたりに手を出す人にはとても役立ちそうな雰囲気を感じたので
     資料をチェックしておくと良さそう

     https://speakerdeck.com/mitsuboshi/google-play-iab-in-app-billing-railsdefalsesabasaidodui-ying-falsesubete
**** Kaigi on Rails 2021タイムテーブル完全解説
     [[https://kaigionrails.org/2021/][Kaigi on Rails 2021]] の各発表のタイムテーブル、
     つまりそれぞれの時間でどういう話がされるのかを
     制限時間内に解説してくれていた。[[https://kaigionrails.org/2021/timetable/#day1][タイムテーブルはこちらから]]

     色々興味深い話がありそうなので私も参加登録しておきました。イエイ。
     金曜日は有休を取ろうと思います。

     その前に業務としての参加を上司に打診しようかな。
     業務に役立ちそうな内容がたくさんあるのでチーム全員参加してもらいたい。

     参加登録は https://kaigionrails.doorkeeper.jp/events/127662 で受付中。
**** Ruby/Railsと遠隔講義：受講者評点がリモートでも伸びた理由
     資料が探せなかったので記憶頼りの記述になるけど
     講義の地道な改善で評点が上がったというお話でした。
     情報のインプットはオンデマンドでできるようにして
     講義では課題を実施してもらうとか。

     Kaigi on Rails 2021 でも yasulab さんの発表があるので
     関係した話が聞けるかも?
     https://kaigionrails.org/2021/talks/yasulab/
**** 既存のRESTful なRails プロジェクトに、GraphQLの導入を検討した話
     最終的には GraphQL の導入は一旦見送りにしたよという発表でした。
     今回の発表で、私はこの発表が一番好きでした。

     色々な課題があるのでそれを解決するために GraphQL が良さそうだなということで
     それを導入しようとチャレンジして、色々検討した結果、
     最終的に GraphQL の導入は見送って、ただ解決したい課題は一部解決したよというお話。

     導入に向けて検討していって、課題解決ができないことに気付いて、
     導入を取り止めるという判断が下されるまでの経緯が描かれていてとても良い発表でした。
     ちゃんと「導入を見送る」って判断ができてる点もとても良い。

     弊社でも似たような課題を抱えていて GraphQL には興味があるけど……みたいな状態なので
     導入しなかった理由が知れるのはとても嬉しい。

     そんな嬉しい内容が書かれている [[https://speakerdeck.com/hiroyaiizuka/ji-cun-falserestful-na-railspuroziekutonigraphqldao-ru-wojian-tao-sitahua][登壇資料はこちら]]

     ちなみに弊社で導入してないのは、
     Schema 駆動で十分開発がまだ成り立っているからかな。
     フロントエンドとサーバサイドも担当がキレイに分かれてないし。
     GraphQL に関する知見がないというのもあるけどね。

     GraphQL 導入するなら多分最初は
     graphql-ruby を使って、管理系の画面でお試しかな〜とかは思っているが
     話が脱線しているのでこの程度で。
**** スポンサーセッション: リンクアンドモチベーション様
     2021/09/29 19:30 スタートの
     [[https://lmi.connpass.com/event/223245/][進化するエンジニアキャリアパスの在り方【クラスメソッド×リンクアンドモチベーション】]]
     というイベントのご紹介などなど。

     キャリアに悩んでるエンジニア向けイベントですね。
     先着順で50名まで、そして 2021/09/26 12:00 時点で 8 割以上枠が埋まってるので
     気になる方はお早めに。
**** スポンサーセッション: DeNA 様
     [[https://kencom.jp/][kencom]] というサービスのご紹介と
     2021/09/29 開催イベント [[https://techcon2021.dena.dev/autumn][DeNA TechCon 2021 Autumn]] のご案内。

     kencom は会社が加入している健康保健組合等が導入していれば無料で利用できるサービスで
     健診データの推移をチェックできたりするみたい。
     裏側ではそうやって集めたデータを分析したりしているみたい。すごそう。

     DeNA TechCon 2021 Autumn は開催日が 2021/09/29 と
     リンクアンドモチベーション様のイベントと開催日が重なっているけど
     幸い時間はズレているので両方参加することは可能。

     過去配信が YouTube なので恐らくこのイベントの配信も YouTube なのかな?
**** 懇親会
     オンライン勉強会の懇親会の雰囲気を味わってみたくて聞いていた。
     Podcast みたいな感覚で聞けるんですね。なるほどって感じでした。

     内容そんなに覚えてないけど、
     本編でも少し出ていた採用技術と人材採用のお話はあるあるだな〜という感想があった。

     時代遅れの技術を使い続けてると採用で敬遠されるとか、
     導入している技術が覇権争いに勝てず、それを使って開発できる人が確保できないとか、
     それが使える数少ない人が辞めれない問題とかありましたね。

     私も「ember-rails アプリを保守できる人がいない」問題対応のため
     [[*ember-rails アプリケーション保守入門][ember-rails アプリケーション保守入門]] を書いたり、
     そもそも ember-cli-rails にした方がいいよねってことで
     [[*ember-rails から ember-cli-rails へ][ember-rails から ember-cli-rails へ]] を書いたりしていますが、
     ちょっと状況がマシになっただけで解決はできてない。困ったもんです。
**** その他
     今回から銀座 Rails はシーズン2、つまり運営が新しい方に受け継がれている。
     https://techracho.bpsinc.jp/morimorihoge/2021_09_02/111210

     引き継いで、準備を頑張っていたのが Tweet でも伺えて
     そして実際当日とてもスムーズに進行できていた。すごい。
     トラブルなく配信してくれた運営に感謝……!
*** DONE ThinkPad P14s Gen 2 (第11世代インテル) に Manjaro Linux を入れてみている :@Linux:Manjaro:config:skk:
    CLOSED: [2021-10-10 日 19:01]
    :PROPERTIES:
    :EXPORT_FILE_NAME: thinkpad-p14s-gen2-intel-with-manjaro-linux
    :END:
    先月、「えいやっ」で
    [[https://www.lenovo.com/jp/ja/notebooks/thinkpad/p-series/ThinkPad-P14s-Gen-2-14%E2%80%9D-Intel/p/22WSP14P4S2][Lenovo ThinkPad P14s Gen 2 (第11世代インテル)]] を購入した。
    詳細は面倒だから省くけどそれなりの構成にしている。
    なお AMD 版にしなかったのは Linux をちゃんと動かせるか不安だったから。

    で、そのマシンに Manjaro Linux を載せて色々設定している。
    この記事は、そのあたりでどういう設定を書いているかの備忘録的なそれです。

    だってさ〜、絶対忘れるじゃん。だからある程度書いておこうかなって。
    そしてその上でまた後で入れ直ししてそれを見ながらセットアップし直そうかなと。
    そしたら多分その時に見逃していた部分も修正できそうだし。

    というわけでなんか適当につらつらと書いていく。

    ま、Twitter につぶやいていたことを記憶で補完しながら書いている感じだけどね。

    Twitter でのつぶやきだと Twilog で
    - https://twilog.org/mugijiru/date-211003
    - https://twilog.org/mugijiru/date-211009
    あたりに該当する部分。
    まだ2日しか触れてないのよな。うん。

**** Manjaro Linux のインストール
     https://manjaro.org/download/ から Xfce 版のやつをダウンロードして
     Windows PC で DVD に iso ファイルを書き込んで
     それを使ってセットアップしてた。

     その際に
     https://www.mimir.yokohama/useful/0023-installing-manjaro.html
     を参考にした。
     まあパーティションどうしたらいいんだっけ以外は特に悩まなかったけど。

     あとは光学ドライブは大昔に購入した外付けのやつなので
     荷物の奥底から引っ張り出して
     「うわー USB type B のケーブルはどこだ〜!」
     「電源アダプタもねえぞー!」とか一人で騒いでた。
     みんなも機器を仕舞う時はそれに使うケーブルなども一緒に仕舞うようにしような。

     あとパーティションは自動で切ってるけど
     swap 領域はメモリ拡張すると足らないのでなんとかする必要がありそう。
**** Font 設定
     デフォルトの Terminal である xfce4-terminal のフォントが
     何故か文字間が広くて気持ち悪いので Sazanami と IPA フォントを入れた記憶がある。

     history を漁ると

     #+begin_example
     $ pacman -S ttf-sazanami
     $ pacman -S otf-ipafont
     #+end_example

     が出て来たのでとりあえずそうやって入れているっぽい。

     多分 Sazanami を入れてるのは
     https://applecom.blog.jp/archives/31595846.html
     の影響かな。
     日本語環境構築したかったから見ていた記憶がある。

     で、その記事でも後から IPA フォントを入れてるから
     その流れに乗って両方を入れてる感じがある。
***** やってないことだけど補足
      今 Arch Wiki のフォントのページ
      https://wiki.archlinux.jp/index.php/%E3%83%95%E3%82%A9%E3%83%B3%E3%83%88#.E6.97.A5.E6.9C.AC.E8.AA.9E
      を調べてると otf-ipaexfont とか良さそうな雰囲気あるな。

      あとはコーディングする上では ttf-mplus を入れておけば
      とりあず固定幅で使えそうなので一安心できそう。

      ちなみに普段他の環境では Ricty diminished を使っているので
      そこに戻る可能性もあるけど、新しい環境ということで新しいフォントにしてみるのも面白そうなので、
      どうするかはわからない。

**** Terminal(xfce4-terminal) の設定
     上に書いたようにフォントが気に食わなくて別のフォントを入れて
     その後適当に弄ってたけど、
     結局 Monospace 16 に戻った上で文字間は悪くない感じになってしまった。

     あれ、これ最初の設定だよね?? なんで文字間の無駄に広いのが直ったの?? ってなってるけど
     まあ悪くないのでそのままで。

     あとは背景が半透明だったけど
     個人的には半透明な Terminal は、
     カッコいいけど後ろ側が気になってしょうがないので

     - 背景
       - 指定なし(単色を使用する)

     という設定にすることで透明度をゼロにしている。

     あと背景が透けるようにすると処理が重くなるってのもあるよね。

**** Web ブラウザ周りの調整
     Manjaro の Xfce 版には標準で Firefox が入っていた。
     私の普段使いの Web ブラウザも Firefox なので丁度良い。

     まずは言語設定がアメリカ英語だったので日本語に変更。
     英語設定のまま使い続けられるほど強くないのです。

     次にフォントを IPA Pゴシックを基本的に使うように変更。

     そして Firefox Sync で同期をすると
     いつも使ってるアドオンが入っていい感じ。

     多分それ以上は何もしてないかな。
     ここは楽だった。

     なおその後アップデートしたら言語設定が吹っ飛んでてまた設定し直すことになった。

**** 日本語入力(fcitx5-skk)
     日本語入力周りは最近の Linux では fcitx というのを使うらしいので
     それの中の SKK を使うやつを選択した。

     というわけで
     http://neko-mac.blogspot.com/2021/06/archlinuxskk.html
     を参考に設定をした。

     #+begin_example
     $ sudo pacman -S fcitx5-skk
     #+end_example

     あとは fcitx5-configtool も必要なので入れた。

     #+begin_example
     $ sudo pacman -S fcitx5-configtool
     #+end_example

     これを別途入れないと設定ツールが起動できないのだが、
     Not Found 的なエラーが出るわけでもなく単に起動できないだけなので
     何が問題なのか気付きにくかった。
     別途インストールが必要だったが、それに気付くまで2,3時間溶かした気がする。

     そんでもって fcitx5-configtool を

     #+begin_example
     $ fcitx5-configtool
     #+end_example

     で起動して
     右側の Available Input Method から SKK を探して
     左側の Current Input Method に入るようにすると
     Ctrl + SPC で日本語を SKK で入力できるようになる。

     さらに StickyShift を愛用しているのでそのあたりの設定もしている。
     設定ファイルについては先に紹介した記事の内容そのままなので割愛。
     後で GitHub にも設定ファイルを上げるので
     ここに書いてなくても困らないはずだし。

     設定ファイルの準備ができたら
     configtool を再度立ち上げて
     Addons タブ内の Input Method ってところの SKK の設定ボタンをクリックし、
     Rule を Default から先程作った StickyShift に切り替える。

     このあたりの手順も先に紹介した記事にある手順そのままだけど
     まあ人の記事は消えることもあるのでちょっとここにも書かせてもらいました。
     向こうの方が画像キャプチャもあって親切なんだけどね。

     まあともかくこれで日本語でもググることができるようになった。

     あとはよくわからんけど [[https://github.com/mugijiru/dotfiles/blob/ead701cd58dc2596d8fb883641a1d793ccddd3ed/.xprofile#L1-L4][.xprofile]] に

     #+begin_example
     export DefaultIMModule=fcitx
     export GTK_IM_MODULE=fcitx
     export QT_IM_MODULE=fcitx
     export XMODIFIERS="@im=fcitx"
     #+end_example

     とか書いているな。

     [[https://wiki.archlinux.jp/index.php/Fcitx5#.E3.82.A4.E3.83.B3.E3.83.97.E3.83.83.E3.83.88.E3.83.A1.E3.82.BD.E3.83.83.E3.83.89.E3.83.A2.E3.82.B8.E3.83.A5.E3.83.BC.E3.83.AB.E3.81.AE.E7.92.B0.E5.A2.83.E5.A4.89.E6.95.B0.E3.81.AE.E8.A8.AD.E5.AE.9A][ArchWiki の Fcitx5 の記事内にあるインプットメソッドモジュールの環境変数の設定]]
     での記述を見てると、俺が書いてる場所や内容がちょっと違うのでなんか俺が間違えてるかも。

     [[https://wiki.archlinux.jp/index.php/Fcitx#.E3.82.A4.E3.83.B3.E3.83.97.E3.83.83.E3.83.88.E3.83.A1.E3.82.BD.E3.83.83.E3.83.89.E3.83.A2.E3.82.B8.E3.83.A5.E3.83.BC.E3.83.AB.E3.81.AE.E7.92.B0.E5.A2.83.E5.A4.89.E6.95.B0.E3.81.AE.E8.A8.AD.E5.AE.9A][ArchWiki の Fcitx の記事内にあるインプットメソッドモジュールの環境変数の設定]]
     の方の記述に似ているけど、これ ~Fcitx5~ じゃなくて ~Fcitx~ の記事だから多分古いんだよな……。
**** i3wm の導入
     ちゃんとしたタイル型WMを使いたい、というのが Linux にした理由の1つ。
     というわけで i3wm を入れることにした。
     正確には i3-gaps なので fork 版なのだけども。

     実は昔使っていた Awesome にしようかとも思っていたのだけど
     最終更新が一昨年だったのであまり活発じゃないのかな〜と思って
     i3 にすることにした。

     i3wm を使うならコミュニティで提供されている i3 版をインスコした方が良いのではというのもあるんだけど
     気付くのが遅かったのと、
     そっちの設定でミスって起動しなくなった時に Xfce を動かすことでとりあえず乗り切る、みたいなことも考えている。

     でまあそんなわけで i3 周りを入れることにしたので、以下をインストールしてある。

     #+begin_example
     $ sudo pacman -S i3-gaps
     $ sudo pacman -S i3status
     $ sudo pacman -S i3blocks
     $ sudo pacman -S i3lock
     $ sudo pacman -S dmenu
     #+end_example

***** i3-gaps
      i3 の fork 版で i3 より機能が豊富らしい。
      違いがどこにあるかはまだ認識してない。

      Mod キーとの組み合わせで色々な操作ができたりして、操作感は Awesome と似ているかな。
      Awesome を使っていたころも Windows キーを Mod キーとして使っていたので。

      設定ファイルである ~~/.config/i3/config~ は今度 GitHub に上げておこう。

      変更点は、初期設定だと ~jkl;~ を左下上右としていたのが気に食わなかったので
      Vim と同じ hjkl にして、
      その影響で h が従来の目的では使えなくなったので
      水平分割、垂直分割をそれぞれ ~:~ とか ~;~ にしている。
      けど ~-~ ~|~ にした方がわかりやすいかもね

      あとはファイル末尾で exec しているあたりが変更点だが、
      この記事の後の記述でそのあたりについては触れているのでここでは取り上げない。

***** i3status
      ステータスバーに表示されるやつで、デフォルトはこいつみたい。
      デフォルト設定だと文字だらけの表示で正直わかりやすくはないかなと思う。
      一応少しはカスタマイズを試みるつもりだが、すぐ乗り換えそうな気もしている。

***** i3blocks
      なんかあるから入れただけで何も設定してない。
      i3status の代わりに使うと良いらしい。
      i3status のデフォルト表示はあまり気に入ってないのでそのうち使うことになりそう。

***** i3lock
      画面ロック機能を提供してくれるやつ。
      xss-lock と一緒に使うものらしくて
      xss-lock を入れてない状態だとエラーを吐いていたので

      #+begin_example
      $ sudo pacman -S xss-lock
      #+end_example

      としたらロックされるようになった。

      ロック画面は真っ白な画面で
      そこで適当にキーを叩いたりすると真ん中に丸が出て来るというよくわからない感じ。

      真ん中に丸が出てない状態でパスワードを入力して Enter するとロックが解除されるっぽい。
      が、わかりづらいのもあって
      今は指紋認証でロック解除できるようにしてある。
      その詳細は後程。

***** dmenu
      デフォルト設定だと Mod + d で起動するランチャ。
      画面上部のバーに横並びで候補が表示されてそこから絞り込むことができるが
      あまり見易くはない。

      あとは解像度を高めにしているから文字が小さくて困ってるけど
      https://wiki.archlinux.jp/index.php/Dmenu#.E3.83.95.E3.82.A9.E3.83.B3.E3.83.88
      を見るとそこは変更できそう。

      でも [[https://github.com/davatorium/rofi][rofi]] とかに乗り換える方が良いかもしれない。

***** 気になるけどやってないこと
      Alt + Tab での切替を Mac でも Windows でもやってるので
      どうしても手癖でそれをやってしまう。

      というわけでそれを実現できそうな以下の記事が気になる。
      https://scrapbox.io/tamago324vim/i3wm_%E3%81%A7_Alt+Tab_%E3%81%A7%E3%82%A6%E3%82%A3%E3%83%B3%E3%83%89%E3%82%A6%E3%82%92%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B

      が、優先度は低いかなと思って放置中。

**** キーバインドの調整
     とりあえず一旦は CapsLock が a の左隣にあるのが使いにくいし
     まあそもそもそんなに使わない機能なので

     #+begin_example
     $ setxkbmap -option "ctrl:nocaps"
     #+end_example

     で CapsLock を Ctrl に置き換えている。

     そして [[https://github.com/mugijiru/dotfiles/blob/ead701cd58dc2596d8fb883641a1d793ccddd3ed/.xprofile#L6-L7][それを永続化するために .xprofile に書いてる]] ので
     起動直後からもう CapsLock は Ctrl になってる。
     とりあえず最低限これがないとつらい。
***** やれてないこと
      本当にやりたいのは

      1. ESC をバッククォートにして、 Shift 押しながらだとチルダが入力される
      2. CapsLock を Ctrl にする
      3. 左 Ctrl を ESC にする

      だったりする。

      これは今愛用しているキーボード [[https://archisite.co.jp/products/mistel/md650l-barocco/][BAROCCO MD650L]] のキーの都合で
      通常のキーボードだとファンクションキーが並ぶ行がまるっとなくて
      チルダがある部分、つまり1の左隣が Esc になっているのが理由で
      Windows, Mac だとそれに合わせてキー配置を上述のようにしているので
      Linux でもそういう配置にしたいなという願望。

      ESC が左 Ctrl の位置だと押したい時に
      あまりホームポジションから離れずに左手親指で押せるのも便利。

**** キーリピートの調整
     デフォルトだとキーを押しっぱなしにした時にリピート入力が始まるのと
     そのリピート速度が遅くてイラッとしたので

     #+begin_example
     $ xset r rate 200 25
     #+end_example

     としている

     r は repeat, rate は比率設定で
     200 は delay つまりリピート入力が始まるのがどのぐらい押してからかで
     最後の 25 は1秒間に何回入力されるかの設定。

     なので、キーを押して 0.2 秒経過したら毎秒25回の速度でそのキーが連続入力されるってわけ。

     正直毎秒25回は多過ぎるかもとかは思ってるが
     まあ使ってる間に調整していけばいいかなと思っている。

     これもまた [[https://github.com/mugijiru/dotfiles/blob/ead701cd58dc2596d8fb883641a1d793ccddd3ed/.xprofile#L9-L10][永続化のために .xprofile に書いている]]

**** タッチパッドでのカーソル移動の調整
     デフォルトだとどうもカーソルの移動が遅くて、
     触りたいところに移動するのが大変だったので
     これも速度を上げている。

     #+begin_example
     $ xinput set-prop <device_id> <prop_id> 0.5
     #+end_example

     的な感じなのだが永続化はしてなさそう……。
     あとでやらなきゃ。

     ちなみに今は Accel Speed は 0.7 にしている。
     細かい所にカーソル合わせるのが大変なので難しい。

**** 解像度の固定
     ひとまずマシン単体で使う場合に最適化しつつ
     最低限、いつも使う外部ディスプレイに繋いでる場合にも配置だけはいい感じになるように
     [[https://github.com/mugijiru/dotfiles/blob/ead701cd58dc2596d8fb883641a1d793ccddd3ed/.xprofile#L12-L13][.xprofile に以下のように書いている]]

     #+begin_example
     $ xrandr --output eDP-1 --mode 2880x1620 --right-of DP-2
     #+end_example

     eDP-1 がノートPC自体のディスプレイなので
     そいつの解像度を指定しつつ
     DP-2 という外部ディスプレイの右側に配置されるように指定している。

     DP-2 なのは単にコネクタ的にたまたまそうなってるだけの可能性も高いが。

     そうそう。
     P14s Gen 2 は USB Type-C のポートが複数あって
     そこに HDMI ポートもある USB Type-C の USB ハブを繋いでも使えるので
     仕事用の Macbook Pro で使ってるハブがそのまま使えて便利。

***** autorandor
      [[https://github.com/phillipberndt/autorandr][autorandr]] というのもあって
      なんか解像度設定を保存したりできるっぽいやつがある。

      https://tech.buty4649.net/entry/2018/12/19/224128 の記事を見るとまだつらそうだけど
      ちゃんと試してみる価値はありそう。
**** 指紋認証でログイン、ロック解除、sudo に対応できるようにした
     i3lock でのロック解除画面は「本当にちゃんとキー入力できてるんだっけ？」って不安になったりするし、
     セットアップ中は sudo を多用するけど、その度にパスワード入れるのもだるいし、
     っていうかパスワード入力なんて今時じゃないな〜ってことで
     指紋認証でそのあたりができるようにした。

     P14s Gen 2 で搭載されている指紋認証機器は fprintd のサポートに含まれているので
     まあ普通にやればできたという感じ。

     普通にというのは Arch Wiki に書かれてるのを見ながら設定したらできた。
     https://wiki.archlinux.jp/index.php/Fprint
***** 指紋認証機器が使えるかの確認
      まず

      #+begin_example
      $ lsusb
      #+end_example

      で指紋認証のやつを探して、
      https://fprint.freedesktop.org/supported-devices.html
      の中の USB ID と一致する機器があるか調べたら運良く含まれていて
      Synaptics Sensors という Driver が使われるようだった
***** fprintd のインストール
      というわけでほぼ間違いなく使えるなということで

      #+begin_example
      $ sudo pacman -S fprintd
      #+end_example

      ここで ~fprintd~ ではなくグループとして定義されている ~fprint~ を入れようとすると一瞬入りそうな気配になるんだけど
      このグループには互いに競合するパッケージが含まれてるから無理やでみたいになるので注意。
***** 認証エージェントを動かす。
      fprintd が入れられたので「じゃあ指紋登録しましょっか」ってことで

      #+begin_example
      $ fprintd-enroll
      #+end_example

      するとなんか知らんが

      #+begin_example
      EnrollStart failed: GDBus.Error:net.reactivated.Fprint.Error.PermissionDenied: Not Authorized: net.reactivated.fprint.device.enroll
      #+end_example

      と怒られる。

      調べてるとなんか認証エージェントを動かす必要があるとか書いていた
      認証エージェントとはなんぞやとなりつつも
      https://wiki.archlinux.jp/index.php/Polkit#.E8.AA.8D.E8.A8.BC.E3.82.A8.E3.83.BC.E3.82.B8.E3.82.A7.E3.83.B3.E3.83.88
      とかを見て「ははーん polkit とかいうのが名前に入ってるやつが必要なんだな」と察して

      #+begin_example
      $ pacman -Ss polkit
      #+end_example

      した時に polkit-gnome がインストール済になっていた。
      ついでにいうと polkit-qt5 もインストール済だったけど、とりあえず gnome の方でいいやということで
      それについてくる agent を自動起動するように i3 の config で

      #+begin_example
      exec --no-startup-id /usr/lib/polkit-gnome/polkit-gnome-authentication-agent-1 &
      #+end_example

      とか書いた。
***** 指紋登録
      認証エージェントも動いたので再度 ~fprintd-enroll~ をすると

      #+begin_example
      Using device /net/reactivated/Fprint/Device/0
      Enrolling right-index-finger finger.
      #+end_example

      と Terminal に表示された上で
      ポップアッププロンプトが出て来てパスワード入力が求められるので
      素直にパスワードを入れると。

      すると今度はポップアッププロンプトは消えて

      #+begin_example
      Enroll result: enroll-stage-passed
      #+end_example

      とか表示されて、何やら待ってる雰囲気になるので
      指紋センサーの上に指を乗せたら、同じ行がまた表示されたので
      そんじゃあまた指を乗せてってのを数度繰り返すと

      #+begin_example
      Enroll result: enroll-completed
      #+end_example

      と表示されて、指紋登録が完了する。
***** 指紋認証の動作確認
      指紋の登録は完了したので fprint-verify で登録したやつが使えるよねって確認を取る。
      スキャンした指を乗せるとちゃんと認証できたみたいな雰囲気になる。

      #+begin_example
      $ fprintd-verify mugijiru
      Using device /net/reactivated/Fprint/Device/0
      Listing enrolled fingers:
      - #0: right-index-finger
      Verify result: verify-match (done)
      #+end_example
***** pam.d の設定変更

      その後は [[https://wiki.archlinux.jp/index.php/Fprint#.E3.83.AD.E3.82.B0.E3.82.A4.E3.83.B3.E8.A8.AD.E5.AE.9A][Arch Wiki のログイン設定の説明]] に従い
      ~/etc/pam.d/system-local-login~ の auth とか書かれている行の上に

      #+begin_example
      auth      sufficient pam_fprintd.so
      #+end_example

      を追加したり
      同じく ~/etc/pam.d/~ にある i3lock, lightdm, sudo の各ファイルに同じものを仕込んだ。

      以上で sudo の時もロック画面の解除の時もログインする時も指紋センサーに指を置けば OK となった。便利。

      ログイン画面は認証 OK になったらパスワード入力欄が非表示になるので、
      その状態で Enter を叩くか「ログイン」ボタンをクリックする必要があるけどね。
      まあ起動する WM を選択可能だからそういう手順が必要なんだろう。
**** ssh 鍵の生成及び GitHub への登録
     各設定ファイルを GitHub に登録しているので
     そこにアクセスしたいよねということで
     Manjaro Linux で鍵を生成して GitHub に登録しておいた。

     ここらあたりはまあわざわざ細かく書かなくても、
     再セットアップの時にそんなに僕は困らないだろうなということで、記述はこんなもんにしておく。
     書いておいたら忘れないよね、ぐらいな感覚。

     ファイル名を指定して鍵を作ったので
     それが次の hub コマンド周りに影響がある気はする。

**** hub コマンドの設定
     これも pacman でインスコできたのでそれを使ってる。
     今時は gh コマンドって気もするが hub コマンドの方が慣れていて……すみません。

     で、 hub コマンドを入れて適当なところで ~hub clone dotfiles~ とかすると
     ユーザー名とパスワードを聞かれて、
     それを入力すると自動でパーソナルアクセストークンを生成してきてそれを使うように設定されるはずなんだけど、
     なぜか Not Found しか言わなくて困った。

     最終的には PAT を自分で GitHub に作って
     さらに自分で ~~/.config/hub~ という設定ファイルを生成して

     #+begin_example
     ---
     github.com:
     - protocol: https
       user: mugijiru
       oauth_token: MY_PERSONAL_ACCESS_TOKEN
     #+end_example

     みたいな感じで MY_PERSONAL_ACCESS_TOKEN のところに先程生成した PAT を突っ込んでおいたら
     ~hub clone~ が成功するようになった。

     というわけで設定ファイルを拾ってきたりできるようになってハッピーになった。

**** ssh-agent の自動起動
     設定ファイルを GitHub に上げたりできるようになったのはいいんだけど
     鍵を作る時にパスフレーズも入れたので
     push したり pull したりする度にそれを入力するのがだるいんですわ。

     ってことで ssh-agent を使うことにした。

     で、どうやら systemd さんに ~--user~ オプションを渡すことで
     ユーザー権限でそういうものを動かすことができるらしい。便利な世の中じゃ。

     というわけで
     https://wiki.archlinux.jp/index.php/SSH_%E9%8D%B5#systemd_.E3.83.A6.E3.83.BC.E3.82.B6.E3.83.BC.E3.81.A7_ssh-agent_.E3.82.92.E8.B5.B7.E5.8B.95
     に従い ~~/.config/systemd/user/ssh-agent.service~ に

     #+begin_example
     [Unit]
     Description=SSH key agent

     [Service]
     Type=forking
     Environment=SSH_AUTH_SOCK=%t/ssh-agent.socket
     ExecStart=/usr/bin/ssh-agent -a $SSH_AUTH_SOCK

     [Install]
     WantedBy=default.target
     #+end_example

     という内容のファイルを置いて

     #+begin_example
     $ systemctl --user enable ssh-agent
     #+end_example

     とかすることでログイン時に ssh-agent が動くようにした。

     さらに
     https://github.com/mugijiru/dotfiles/blob/ead701cd58dc2596d8fb883641a1d793ccddd3ed/.zshrc#L157-L160
     に書いてるように .zshrc に末尾に

     #+begin_example
     # use ssh agent with systemd
     if [ -e "$XDG_RUNTIME_DIR/ssh-agent.socket" ]; then
       export SSH_AUTH_SOCK="$XDG_RUNTIME_DIR/ssh-agent.socket"
     fi
     #+end_example

     と書くことで
     自動起動した ssh-agent に繋がるようになった。
     https://github.com/mugijiru/dotfiles/pull/11

     その状態で

     #+begin_example
     $ ssh-add hoge_key
     #+end_example

     みたいにすることで鍵を登録できるので
     そのセッションでは ssh 鍵のパスフレーズを入力しないで済むようになって便利になった。

**** zsh の設定
     mugijiru/dotfiles を clone してきてあるので

     #+begin_example
     $ ln -s /path/to/dotfiles/.zshrc ~/.zshrc
     #+end_example

     するだけで OK

**** fzf の設定
     最近 fzf を使いだすようになったので
     Manjaro でもそれを使いたいということで

     #+begin_example
     $ sudo pacman -S fzf
     #+end_example

     でインストール。

     さらに dotfiles に ~.fzf.zsh~ も置いてるので

     #+begin_example
     $ ln -s /path/to/dotfiles/.fzf.zsh ~/.fzf.zsh
     #+end_example

     したら OK

     まあ本当はセットアップの時はその記述がちょっと環境と合ってなくて
     ~/usr/share~ にファイルがある場合はそれを読むように変更している。
     https://github.com/mugijiru/dotfiles/pull/8

     まあもうこの調整を push してあるので次回はハマらないはずだ。

**** その他
     - w3m はあると便利なのでとりあえず入れている
     - tmux も入れておいた
       - tmuxinator は入れてないし tmux の設定ファイルも反映してない

**** 対応できてないこと
     と、それなりに時間をかけていくつか設定してきたけど
     まだまだやれてないことはある。

     以下はぱっと思い付く、やりたいけどやれてないこと。

     - ログイン画面の解像度変更はうまくいってない
       - 解像度が高過ぎて文字が米粒みたいでちょっと困ってる。
     - 音が出ないっぽい
       - まあ音なんかそんなに必要じゃないので後回しにしている。
       - Xfce に戻したら鳴りそうな気もしている
     - Emacs 周りの調整
       - 大変そうなので後回し中
     - 起動する Terminal 差し替え
       - 今はまだ xfce4-terminal を動かしているが urxvt にした方が軽くて良さそうだなと思っている

     ここにリストアップした以外にも文章中にもそういうのが書かれてるし
     ぱっとは思い付いてない何かもありそうなので
     まだまだ設定には時間がかかりそう。楽しいねえ。
*** DONE Manjaro Linux のディスプレイ周りの設定を弄った :@Linux:Manjaro:config:display:
    CLOSED: [2021-11-24 水 14:01]
    :PROPERTIES:
    :EXPORT_FILE_NAME: xrandr-and-autorandr-on-manjaro
    :END:
    Manjaro Linux の設定を弄ってる系の記事です。
    まあまだ2記事目だけど。

    家には外部ディスプレイが存在するけど
    まあ必ずいつも繋いでるわけでもないので、
    両方の状態に対応できるようにしたいよねって思ってた。

    それをするには [[https://www.x.org/wiki/Projects/XRandR/][XRandR]] と
    それの設定を保存したりするのに [[https://github.com/phillipberndt/autorandr][autorandr]] を使えばいいというのがわかった。
    ありがとう [[https://wiki.archlinux.jp/index.php/Xrandr][Arch Wiki]]。
    今確認していると autorandr ではなくて [[https://github.com/alex-courtis/xlayoutdisplay][xlayoutdisplay]] とやらでも良さそうだがね……。

    まあそれはさておき、
    ひとまずはディスプレイに繋いでる状態をなんとかしたかったので
    最初は

    #+begin_src sh
    xrandr --output eDP-1 --mode 2880x1620 --right-of DP-2
    #+end_src

    というコードを .xprofile に書いていた。
    eDP-1 がノート PC のディスプレイで DP-2 が外部接続しているディスプレイである。
    つまり eDP-1 は 2880x1620 の解像度で出力し
    DP-2 の右側に配置する、といった感じである。

    DP-2 自体の設定はどこかにいったが、まあ解像度を弄ってるぐらいなのでとりあえずヨシ。

    とりあえずこれにより、ディスプレイを繋いでる状態は良かったんだけども
    ディスプレイを切り離した時に、
    仮想デスクトップ2が切り離した方に表示されてるような認識をされていたので
    困ってしまった。

    調べたところ

    #+begin_src sh
    xrandr --output eDP-1 --mode 2880x1620 --output DP-2 --off
    #+end_src

    を実行することで DP-2 つまり外部ディスプレイをオフにできることがわかった。

    というわけで、手動でコマンドを叩く前提にはなるが一旦解決はした。

    そしてこれらそれぞれの状態を autorandr で保存するため
    まずは繋いでる状態で

    #+begin_src sh
    autorandr --save docked
    #+end_src

    として保存し、
    切り離して先のコマンドを実行し、ノートのディスプレイだけを使える状態にした上で

    #+begin_src sh
    autorandr --save mobile
    #+end_src

    と実行することで、それぞれの状態を

    - docked
    - mobile

    として記録しておいた。

    これにより、ディスプレイを繋いだり外したりした時に
    望んだ通りの設定に自動で切り替わるようになった(切り替わりは今記事を書きながら試した)

    というわけで、切り離した時に表示調整を自分でする必要がなくなった。便利。
*** DONE Manjaro Linux にペンタブレット(XP-PEN Star G640S)を設定した :@Linux:Manjaro:config:pentablet:
    CLOSED: [2021-11-24 水 15:58]
    :PROPERTIES:
    :EXPORT_FILE_NAME: xp-pen-star-g640s-with-manjaro
    :END:
    今年の前半ぐらいに購入しておいて放置していた
    XP-PEN の Star G640S を
    Manjaro Linux 環境で使えるか試してみたらとりあえずあっさり動いたというメモ。

    まず最初は単に接続して使えるかを試したら、とりあえず動いた。

    そんでもって、設定を変更したいな〜と思ったら
    [[https://www.xp-pen.jp/download-166.html][公式にドライバがある]]し、
    [[https://aur.archlinux.org/packages/xp-pen-tablet][AUR にはそれにパッチを当てたやつ]]が転がっていた

    というわけで

    #+begin_src sh
    yay -S xp-pen-tablet
    #+end_src

    したらそれが入って来た。

    その上で ~pentablet~ というのを rofi から起動すると
    XP PEN の設定ソフトが起動したので
    それを使って適当に設定したらその通りに動いて良かった。
    具体的には、配置の関係上、上下さかさまで使うように設定した。
    USB ケーブルの位置がね……。

    ちなみに ~xp-pen~ というのも AUR には転がってるけども
    ベースとなってるバージョンがちょびっとだけ古いのと
    人気度的に ~xp-pen-tablet~ の方が上だったので、そっちを選んでいる。

    他にも [[https://krita.org/jp/][Krita]] ってソフトで試したんだけど、
    筆圧もちゃんと検知するみたいだしこれは良さそう。
    とはいえ絵を描いたりはしないので、筆圧は実は要らないんだけども。

    まあ普通に使えて良かったので今後使うかもしれない。うん。
*** DONE 退職しました                                                 :@雑記:
    CLOSED: [2021-11-30 火 19:28]
    :PROPERTIES:
    :EXPORT_FILE_NAME: retirement-2021
    :END:
    約5年前、沖縄から出て来て東京の会社に就職しましたが、
    今年で退職することにしました。

    最終出社は11月で、12月いっぱいは有休消化なので一ヶ月まるまる休みになります。
    一ヶ月ずっと休みなので、ちゃんと社会復帰ができるか若干心配ではあります。

**** これまでの5年間
     約5年前、東京のとあるスタートアップ企業に
     Rails エンジニア(サーバサイドもフロントもやるよ)ということで入社しました。

     入社当時、開発者は私を含めて片手で数えられる程度しかいない小規模なチームでした。
     数えるのに二進数を使って片手で31までとかいうのは無しな。

     小規模ではあるものの、その前の職場と比較すると、
     CI が整備されていてコードレビュー文化があるなど
     モダンなチーム開発ができる環境だな〜と思って入社しました。
     あ、でも CI は前の職場でもしれっと Jenkins 立ててたか自分で。

     入社してしばらくは、人見知りと沖縄なまりを発揮しながらプロダクトの機能開発に従事しつつ、
     ごちゃっていた CSS を少々マシにしたりといった活動をしてました。

     私が入社した後も業務委託のエンジニアが参画したりで
     気付いたら片手では数えられないほどの人数になったためサブチームに分割され、
     その片方を引っ張る立場になったりしました。
     開発チーム全体からするとサブリーダー的な感じなのかな。
     ちなみにこの時が多分一番ゴリゴリ開発してた。

     その後は元のリーダーがいなくなったのもあってリーダーに繰り上がったりしました。
     確かリーダーになった時はまだ割と普通に開発してたけど、
     その後は色々な事情も重なって、段々と開発からは離れていって
     いわゆる上流工程だとか管理だとかそういったものの比重が少しずつ増えて行きました。

     というわけで、開発というか実装するのに飢えたりしてたので、
     開発したいなあとか思いながら転職サイトを眺めたりしていたら
     結果辞める方向になりました。

     書いてて結構適当だな、まいっか。

**** これからどうするのか
     上述の通り、転職サイトを眺めていて、
     その時に東京のとある会社とマッチングしたため、来年1月からはそちらにお世話になる予定です。
     そこでも Rails とフロントエンドに携わる予定となっています。

     12月いっぱいは有休消化の長期休暇となるため社会復帰が困難かとは思いますが、
     頑張ってちゃんと働こうと思っています。
     ちゃんと働けるように休み中も午前には起きるようにするね。

     ちなみに休みの間は沖縄に帰省したりするので沖縄にいる方々はよろしくな。
     あと帰省前は東京にいるから東京にいる方々もよろしくな。
     あくまで帰省するだけで U ターンするわけではないので来年も引き続き都内にいます。
     大体家の中だけど。

     あとは、遠方だったりで直接会ったりできないけど新しい門出を祝いたい方や応援したい方向けに
     Wishlist を用意しておきましたのでよろしくお願いします^^
     https://www.amazon.co.jp/hz/wishlist/ls/2DVSD4OJ72M7V

*** DONE el-get-lock の情報を使ってパッケージの更新確認ができるようにした :@Emacs:
    CLOSED: [2022-03-06 日 23:36]
    :PROPERTIES:
    :EXPORT_FILE_NAME: check-updates-emacs-packages-with-el-get-lock
    :END:
    変なこだわりがあったり時代の波に乗れてなかったりで
    use-package を使わずに el-get を使い続けている麦汁です。

    このところは [[https://github.com/tarao/el-get-lock][el-get-lock]] で今入れているバージョンがわかるようにしつつ
    定期的に el-get-update-all 的なことをしていました。
    そこもまあ非同期でまとめて更新処理がかかると変なことになるので
    適当なスクリプト組んでたけども。

    で、なんでそんなことをしているかというと
    今入れているバージョンとアップデートしたバージョンの差分をチェックしたいから。

    まあ Emacs 界隈では基本的にそんな差分チェックとかしてないで入れてしまう世界っぽいのですが、
    個人的な妙なこだわりで差分チェックをしたくって、この運用を続けていた。

    なのだけどまとめて更新すると
    https://github.com/mugijiru/.emacs.d/pull/396/files
    こんな感じになって差分を調べるのがマジ大変。
    そしてちょっとサボるとめっちゃ溜まるのでめっちゃ大変。

    というわけでそれがしんどくなったので
    el-get-lock の lock ファイルの情報から
    [[https://github.com/mugijiru/.emacs.d/blob/a447ee75a0159af6361fe654462626e08e19c679/el-get-lock-update-check.el][更新があるパッケージの情報がわかる更新チェックスクリプト]]を書いてみた。

    [[https://github.com/mugijiru/.emacs.d/blob/a447ee75a0159af6361fe654462626e08e19c679/el-get.lock][自前の el-get の初期化ファイル]] に依存しているので動かすにはこちらも必要だし
    当然自分の el-get.lock ファイルも必要なのだけど
    自分用に書いたスクリプトなのでそのあたりはそんなに気にしてない。

**** 使い方
***** 更新のあるパッケージの数が知りたい場合
      #+begin_example
      $ emacs --batch -Q -l /home/mugijiru/.emacs.d//el-get-lock-update-check.el --eval=(el-get-lock-update-check-execute t)
      #+end_example

      と叩けばその数を出力してくれる。
      ~el-get-lock-update-check-execute~ の第一引数が t だと
      更新が必要なパッケージの数だけ表示するようになっている。

      まあ作りが雑なので標準エラー出力にもごちゃごちゃ吐かれるから

      #+begin_example
      $ emacs --batch -Q -l /home/mugijiru/.emacs.d//el-get-lock-update-check.el --eval=(el-get-lock-update-check-execute t) 2> /dev/null
      #+end_example

      としてそのあたりの情報は捨てた方がいい

***** 更新のあるパッケージがどれなのか知りたい場合

      #+begin_example
      $ emacs --batch -Q -l /home/mugijiru/.emacs.d//el-get-lock-update-check.el --eval=(el-get-lock-update-check-execute)
      #+end_example

      と叩けばどのパッケージが更新可能なのか吐いてくれる。
      どのパッケージが更新可能か分かれば後は ~(el-get-update hoge-package)~ とか実行してあげれば良い。
      https://github.com/mugijiru/.emacs.d/pull/467 などはそうやって更新して
      el-get.lock の checksum の差分から GitHub の compare を見たりしている。

      このパターンでは他にもいくつかの情報を吐くけど後で説明する。

**** 仕組み
     el-get.lock では例えば Git 管理のパッケージの場合だと
     checkout した revision の hash 値を el-get.lock に記録するので
     remote の最新コミットと比較して違う値だったら孤雲があると判定するだけ

**** 制限
***** Git/GitHub 以外のパッケージの更新チェックはできない
      EmacsWiki とか CSV とかのパッケージの更新チェックはできません。
      el-get.lock でもそのあたりは checksum は記録するけどロックはできないのでしてなかったりするし
      まあ今の世の中大体は GitHub かそうじゃなくても Git で管理されてるので
      このスクリプトでは一旦そこだけサポートするようにした。
      自分用だしテキトーで良い。

      ちなみに EmacsWiki に入ってるようなやつは大体
      https://github.com/emacsmirror とか https://github.com/emacsorphanage?type=source あたりにあるので
      そっちを使うように recipe を書けば解決する。
      https://github.com/mugijiru/.emacs.d/pull/476 みたいな感じで。
***** (el-get-bundle XXX/YYY) 形式で入れているパッケージは更新チェックできない
      レシピファイルの情報をチェックするので
      ~(el-get-bundle XXX/YYY)~ で直接 GitHub のリポジトリを指定していて
      レシピファイルが存在しない場合はこれもまた更新チェックができません。

      まあレシピファイルさえ書けば解決するのでそれでいいかってなってる
***** main がデフォルトブランチの場合はレシピファイルでそれを指定する必要がある
      どちらかというと el-get-lock 側の制限な気もするけど
      el-get-lock では branch の指定がなければ
      master ブランチの情報で固定するようになっているので
      その場合もまたレシピファイルを追加して回避した方がいい。
      ox-hugo が master から main に切り替えられてるっぽいのだけど
      手元は古い状態で止まってしまってた……。

      そのため main ブランチがあるかどうかを調べられる関数も仕込んでいる。
      ~el-get-lock-update-check-use-main-p~ という関数がその役割で

      #+begin_src emacs-lisp
      (dolist (version (cdr el-get-lock-package-versions))
        (let ((package (replace-regexp-in-string "\\\\\\\." "\\\." (symbol-name (car version)))))
          (el-get-lock-update-check-use-main-p package)))
      #+end_src

      みたいに叩くとインストール済のやつでかつ main ブランチを使ってるやつがわかるようになっている。
      雑な作りだけどね。

**** i3blocks との連携
     i3blocks の設定ファイルに

     #+begin_example
     [emacs-update]
     command=emacs --batch -Q -l ~/.emacs.d//el-get-lock-update-check.el --eval='(el-get-lock-update-check-execute t)' 2> /dev/null
     label=Emacs:
     interval=1800
     #+end_example

     とか書いておけば30分毎に更新チェックのスクリプトが実行されるので
     更新情報がすぐ分かって便利かもしれない。

**** 更新があるパッケージ以外の情報
     更新のあるパッケージのリスト表示の時は他の情報も出力すると上に書いていたけど
     じゃあ何を出すかというと
     「EmacsWiki から入れているパッケージはこいつらだよ〜」とか、
     「hash 値が取れないパッケージはこれこれだよ〜」とか表示するようにしている。
     更新チェックができないやつも分かるようにしたかったので。

**** 最後に
     とりあえず自分のやりたい更新差分チェックが
     1パッケージ毎にチェックできるようになったので確認が楽になりました。

     今回のスクリプトは[[https://github.com/mugijiru/.emacs.d/pull/405][2週間ぐらい前から作っていて]]
     その時点のやつでも最低限のチェックはできたので
     2週間前から1つずつ更新しつつスクリプトを直したりしました。

     けど更新をサボっていたから長かった……。
     今日でやっと更新も全部対応できた……。

     今後は更新をサボらないようにしたいです……!
     まあ今1つ更新があるのは無視して明日対応するけどな。

*** DONE Kibela の記事を検索できる Ivy 拡張を作った                  :@Emacs:@Kibela:
    CLOSED: [2022-08-29 月 09:53]
    :PROPERTIES:
    :EXPORT_FILE_NAME: release-ivy-kibela
    :END:
    Emacs の [[https://github.com/abo-abo/swiper][ivy]] を使って [[https://kibe.la/][Kibela]] の記事を検索できる拡張 [[https://github.com/mugijiru/ivy-kibela][ivy-kibela]] を作りました。

    まあ自分用に作っただけなので Melpa にも登録してなかったりと、
    ちゃんとしてない部分は色々ありますが。
**** 作った理由
     現職では情報共有ツールとして Kibela を使っています。
     そして Kibela の記事を探したい時ってのは大体 Emacs でプログラムを書いている時なので
     Emacs 内からさくっと検索できると便利だな〜と思って作りました。

**** インストール方法
     README に一応書いているけど、
     さらっとしすぎているので一旦こっちに厚めに書きます。
***** el-get

      多分

      #+begin_src emacs-lisp
      (el-get-bundle mugijiru/ivy-kibela)
      #+end_src

      で入れられるんじゃないかな。
      もしダメだったら

      https://github.com/mugijiru/.emacs.d/blob/master/recipes/ivy-kibela.rcp

      に el-get 用のレシピを置いてるのでそれを使ってください。

***** マニュアルインストール
      依存関係に

      - request
      - graphql
      - ivy

      があるのでそれらを事前に入れておいてください。
      そして

      #+begin_example
      $ git clone git@github.com:mugijiru/ivy-kibela.git
      #+end_example

      で Clone してきて

      #+begin_src emacs-lisp
      (add-to-list 'load-path "CloneしたPATH")
      #+end_src

      みたいな感じで load-path に突っ込んだら使えるようになるはずです
***** その他
      Melpa への登録は大変そうだったので登録していません。
      なので package.el とかは使えません。

      登録したい気持ちはなくはないけど、頑張る気力がない……。
**** 使い方
     設定とかは [[https://github.com/mugijiru/ivy-kibela#%E8%A8%AD%E5%AE%9A][README]] に割とちゃんと書いているつもりなので省略。

     コマンドは

     - ivy-kibela
     - ivy-kibela-recent
     - ivy-kibela-search

     の3つを用意しています。

***** ivy-kibela
      ivy-kibela はデフォルトでは ivy-kibela-recent と同じ動作をします。
      設定でその動作を ivy-search と同じ動作をするように切り替えられます。
      よく使う方の動作を設定しておくと便利かもしれません。

      裏事情的には、単に実装当初は ivy-kibela-recent 相当の処理しかなかったので
      互換性のために用意されているだけだったりはします。
***** ivy-kibela-recent
      ivy-kibela-recent は直近投稿された記事情報を取得して絞り込むためのコマンドです。
      直近 100 件の記事を取得し、そこから ivy のインターフェースで絞り込んで Enter を叩くと
      ブラウザでその記事を開きます。

      情報を取得してから絞り込むので、
      API を叩くのは1回で済むし、絞り込み時に wait が発生しません。
      そのため、直近の記事を検索する時はこちらを利用するのをオススメします。

      また [[https://github.com/ROCKTAKEY/ivy-migemo][ivy-migemo]] を導入していたら

      #+begin_src emacs-lisp
      (with-eval-after-load 'ivy-kibela
        (add-to-list 'ivy-re-builders-alist '(ivy-kibela . ivy-migemo--regex-plus) t))
      #+end_src

      とかしておくと migemo も使えます。
      [[https://github.com/ROCKTAKEY/ivy-migemo][ivy-migemo]] 便利。

***** ivy-kibela-search
      ivy-kibela-search は ivy のインターフェースから
      Kibela の検索 API を叩くコマンドです。
      3文字以上入力した場合に検索 API にリクエストを飛ばし、
      その結果から記事・コメントを選択し Enter を叩くとブラウザで選択した記事・コメントを開きます。

      3文字以上を入力した場合に API を叩くようになっているため
      例えば "React" と type した場合には "Rea", "Reac", "React" と
      3回 API を叩くことになり、
      [[https://github.com/kibela/kibela-api-v1-document#1%E6%99%82%E9%96%93%E3%81%94%E3%81%A8%E3%81%AB%E6%B6%88%E8%B2%BB%E3%81%A7%E3%81%8D%E3%82%8B%E3%82%B3%E3%82%B9%E3%83%88][検索コスト]] を多く消費するかもしれません。

      また、検索には Kibela の API を使う関係上
      ivy-migemo は利用できません。

***** ivy-kibela-recent と ivy-kibela-search の使い分け
      私は
      「最近書かれたあのあたりの記事を開きたいな〜」という時に ivy-kibela-recent を使い、
      「あーあの記事古いよな」って時には ivy-kibela-search を使う、という感じで使い分けています。

      ivy-kibela-recent を使うと
      ローカルでの絞り込みなのでストレスが少ないのと ivy-migemo も使えるので絞り込みやすくて便利。
      「今開発しているやつの情報」は大体新しいのでこっちで十分だったりする。

      ただし直近 100 件しか取れないので、
      古い記事を調べたい時は ivy-kibela-search を使う、という感じの使い方をしています。

      記事を探すのが楽になったので自分的には便利。
*** TODO Dropbox を使えるようにした                     :@Linux:Manjaro:i3wm:
    :PROPERTIES:
    :EXPORT_FILE_NAME: dropbox-on-i3wm-on-manjaro
    :END:
    個人的なメモファイルを org-mode で管理していて
    それを WebDAV でサーバに上げて [[https://beorgapp.com/][beorg]] という iPhone アプリと共有している。

    が、WebDAV に都度上げる必要があって、それを怠ると beorg 側に反映されなくてつらいし、
    逆に WebDAV から取得するのを忘れてもつらいことになる。コンフリクトしたりね。

    というわけで辛みが増してきたので、
    Dropbox で同期取るように切り替えた方が良さそうだな〜と思って
    とりあえず動かせるようにしてみた。

    とは言っても [[https://wiki.archlinux.jp/index.php/Dropbox][ArchWiki の Dropbox の記事]] に書いている通りにやったらできただけなんだけども。

    テスト

*** DONE Emacs で動く Kibela クライアントを作ってる          :@Emacs:@Kibela:
    CLOSED: [2023-03-18 土 15:58]
    :PROPERTIES:
    :EXPORT_FILE_NAME: introduction-kibela-el
    :END:
    最近 Emacs 上で動く Kibela のクライアントを作り始めたからちょっと紹介してみる

**** Kibela とは
     [[https://kibe.la/][Kibela]] は知識共有やドキュメント管理を目的とした SaaS 型のナレッジ管理ツールの一種。

     記事を書く時は Markdown エディタで書くこともできるしリッチテキストエディタで書くこともできるので
     Markdown に不慣れな方も Markdown で書きたい人も同じ記事をそれぞれが好きなエディタで編集することができるあたり便利。

     無料で使えるコミュニティプランもあるので個人でも気軽に試せるのも便利。

     そして [[https://support.kibe.la/hc/ja/articles/360035089312-Kibela%E3%81%AEWeb-API%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6][API が公開されている]] ので、自分でクライアントも作れるわけですよ。

**** Emacs で動く Kibela クライアント kibela.el
     [[https://github.com/mugijiru/emacs-kibela][kibela.el]] は Emacs 上で動く Kibela クライアントです。
     Kibela を普段使ってるので、それを Emacs から触れると便利だなあと思って作っています。

     上述の通り Kibela は API を公開しているのでそれを利用しています。

***** 機能
      今の kibela.el は以下の機能を備えています。
      使い方は README に書いているはず

      - デフォルトグループの記事一覧表示
        - 40件毎の表示します。
        - ~<~, ~>~ でのページ送りに対応
      - 記事の新規作成
        - 記事テンプレートから作成することもできます。
        - 投稿先の変更機能は未実装です
      - 記事の閲覧・編集
        - 記事一覧から閲覧画面へ遷移し、閲覧画面から編集モードに遷移できます。
        - 閲覧画面で ~C-c C-c C-o~ と入力することで記事をブラウザで開くこともできます。
          - kibela.el ではできないこともブラウザで開いたら操作できる、という逃げ。
        - こちらも投稿先の変更機能は未実装です
      - チームの切り替え

***** 動画キャプチャ
      ivy を入れている環境なので補完には ivy が使われていますが、実際に動いている様子を撮影しました。

****** テンプレートからの記事の投稿
       {{{youtube(_FaUlP1rHMw)}}}

****** 記事一覧から閲覧・編集
       {{{youtube(BNsHa4peUmY)}}}

***** 今後やりたいこと
      自分が普段使う上で「これができると Emacs 上でいつもの作業が済んで楽だな〜」ということから作っていくつもりです。

      今ぱっと思い付くのはこのあたりかな

      - いいね! の表示/投稿
        - これができると新しい記事を適当に眺めてリアクションしていくことができて便利
      - グループ一覧の表示とデフォルトグループ以外の記事一覧表示
        - これができると各グループの記事を追えて便利
      - 通知の表示
        - メンション飛ばされているのとかも Emacs から確認できると便利そうなので
      - 検索
        - 古い記事は記事一覧からは流石に探せないので
      - 埋め込み画像の表示
        - 対応が面倒なので後回しにしていますが表示したい
        - 動画についてはあまり考えてない
      - フォルダツリー
        - あったらフォルダから記事を絞り込むことができて便利かも
      - 絵文字の表示や補完
        - あると記事書く時に使えて便利。まあなくてもさほど困らないけど
      - 下書き保存・編集
        - あったら便利。なくてもまあいいけど

      ま、飽きるまでやるつもり。すぐ飽きそうな気もするけど。

*** DONE 少し構成が複雑なアプリの Code Coverage を Code Climate で表示する :@Rails:@Frontend:
    CLOSED: [2023-06-03 土 11:47]
    :PROPERTIES:
    :EXPORT_FILE_NAME: show-code-coverage-on-code-climate-complexity-app
    :END:
    https://github.com/mugijiru/ember-rails-todo-app のカバレッジを取るためにやったことです。

    書いたコードは
    https://github.com/mugijiru/ember-rails-todo-app/blob/712e6ca7e2b1135ba11c56c8c3e9ca870f020ec2/.github/workflows/ci.yml#L58-L98
    にあるので、それだけ見れば十分かとは思うけど、それで済ませるのも寂しいので少しテキストも書いておきます。

**** アプリの構成
     単一の Rails アプリケーション上で
     複数の Ember.js アプリケーションを動かせるようにするために
     Ember.js のアプリケーションは ember/todo-app という位置に作成しています。

     #+begin_example
     RAILS_ROOT
     ├── ember/todo-app
     │    ├── package.json
     │    └── yarn.lock
     └── spec
     #+end_example

     そのためテストを実行するディレクトリが異なるという状況です。

     rspec の方は

     #+begin_example
     $ rspec spec
     #+end_example

     で済むけど Ember.js のテストは

     #+begin_example
     $ cd ember/todo-app && yarn test
     #+end_example

     しないといけないみたいな。

**** 複数テストスイートのカバレッジを取る
     今回は上記のように若干構成が複雑なので手を入れていますが、
     どちらも同じ階層でテストを実行できるのであれば
     https://docs.codeclimate.com/docs/configuring-test-coverage#multiple-test-suites
     に書いていることをやれば問題ないはずです。

     なのですが今回は若干構成が複雑なため、そのままではダメでした。いい感じに統合してくれなかった。

     じゃあどうしたかというと

     #+begin_src yaml
       - name: Format ember test result
         run: cd ember/todo-app && ../../cc-test-reporter format-coverage -o ../../tmp/cc.ember.json --add-prefix ember/todo-app
     #+end_src
     という感じで、深い階層にある Ember.js 側のカバレッジのフォーマットを取得する時にちょっと調整している。

     まず ~cd ember/todo-app~ で Ember.js アプリケーションの階層に移動して、
     ~cc-test-reporter format-coverage~ を実行する際に
     ~-o~ オプションを使って後で扱いやすい出力先を指定して
     ~--add-prefix~ で移動先である ~ember/todo-app~ を指定している。

     この ~--add-prefix~ は Code Climate の公式ドキュメントにある [[https://docs.codeclimate.com/docs/configuring-test-coverage#list-of-subcommands][List of subcommands]] という項目には載ってないんですよね。。。
     あと ~--debug~ もそこには載ってないけど使えるみたい
     https://github.com/codeclimate/test-reporter/blob/master/man/cc-test-reporter.1.md

     それはともかく、そんな感じで format 時の出力を調整したら
     後段の sum-coverage の際に良い感じにまとめてくれるようになる。
