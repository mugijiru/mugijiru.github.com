#+TODO: TODO(t) | DONE(o)
#+HUGO_BASE_DIR: ./
#+HUGO_SECTION: ./
#+title: 麦汁三昧
#+author: mugijiru

* 麦汁三昧
** DONE About
   CLOSED: [2020-12-20 日 11:59]
   :PROPERTIES:
   :EXPORT_FILE_NAME: about
   :END:

   この Web サイトは Web プログラマである麦汁の個人サイトです。

   気が向いたらブログ記事を更新したりするはず。

** DONE Profile
   CLOSED: [2020-12-20 日 12:15]
   :PROPERTIES:
   :EXPORT_FILE_NAME: profile
   :END:

   都内で Ruby on Rails と Vue.js を使った Web アプリケーションを開発している Web プログラマ。
   一部インフラ(AWS)もかじっている。

   最近は実装よりも、仕様策定や全体の進捗管理、調査、その他雑用をしていることが多い。

   好きなエディタは Emacs。サブで Vim も使っている。

   1983年生まれ。沖縄出身。

*** 経歴
    - 2009年 :: 沖縄の IT ベンチャー企業に就職しWebプログラマとして活動
    - 2012年 :: 別の沖縄の IT ベンチャー企業に転職し引き続きWebプログラマとして活動
    - 2016年 :: 都内 IT ベンチャー企業に転職しWebプログラマとして活動
    - 現在   :: リードエンジニアとして活動中

*** SNSなど
    - Twitter :: [[https://twitter.com/mugijiru][@mugijiru]]
    - GitHub :: [[https://github.com/mugijiru][mugijiru]]
    - 旧Blog :: [[http://mugijiru.seesaa.net][麦汁三昧]]

** Blog
   :PROPERTIES:
   :EXPORT_HUGO_SECTION: posts
   :END:
*** DONE Hugo 始めました                                              :@雑記:
    CLOSED: [2020-12-20 日 15:22]
    :PROPERTIES:
    :EXPORT_FILE_NAME: starting-hugo
    :END:

    Hugo はなんか Emacs 界隈で流行ってるし、
    自分のサイトだっせーなーって思ってたので
    Hugo を使って、公開されてるテンプレートを適用して
    Web サイトを再構築してみることにした。

    <!--more-->

    他の静的サイトジェネレータもちょっと検討したけど
    機能面とかも考慮した上で Hugo がいいかなって。
    主な理由は「流行ってるから」ですが。
    ほら、流行りに乗りたいじゃん。ちょっと乗り遅れてる気もするけど。

    今、とりあえず作ってる最中なんだけど、
    つい BBS とかチャットとかリンク集とか置きたくなる。
    90年代または2000年代脳である。
    お絵描き BBS も置いたろうかって気持ちになる。
*** DONE 新年明けましておめでとうございます                           :@雑記:
    CLOSED: [2021-01-02 土 20:31]
    :PROPERTIES:
    :EXPORT_FILE_NAME: happy-new-year-2021
    :END:

    新年明けましておめでとうございます。麦汁です。
    昨年の終わり頃、世間では AdventCalendar で賑ってる頃に、
    ふと「サイトのリニューアルしたいなあ」なんてことを思って、
    リニューアルに着手しましたが、ようやくそれが実りそうです。

    <!--more-->

    なんでそんなことをしてるかというと
    前の記事 [[*Hugo 始めました][Hugo 始めました]] でも書いたように
    「自分が作ったサイトだっせー」ってのが1つあります。

    それを構築した時には
    「デザインとかも全部自分でやっちまおう」ということで全部やろうとしていたのですが
    デザインセンスが壊滅的だったとか時間がろくに取れないとかやる気が他に吸われていったとかで
    イマイチなまま放置していました。よくないですねえ。

    あと、そことは別にブログサービスを借りて使ってるのですが
    そっちはそっちで更新がだるいなってのもあって
    リニューアルと同時に今後のブログ更新はこっちにしてしまおう、というのもあったりします。

    Hugo でブログもやってしまう方が [[https://ox-hugo.scripter.co/][ox-hugo]] も使って記事を書き出せるので
    org-mode 使い的には幸せになれそうですし。

    あとは折角リニューアルしたんだからモチベーションが続くことを願っています。

    というわけで 2021 年の抱負は「月に2回はブログを更新する」とします。

    結構、緩めな抱負ですが、仕事じゃないのでこのぐらいの方が良かろう……。
*** DONE browse-at-remote を導入した                                 :@Emacs:
    CLOSED: [2021-01-23 土 23:18]
    :PROPERTIES:
    :EXPORT_FILE_NAME: add-browse-at-remote
    :END:

    仕事中、プルリクのレビューをする際に、
    「ここのコードがこんな感じになってるから〜」みたいな感じで
    既存コードへのリンクを張ることがちょくちょくある。

    そういうことをする時、まずそもそも差し示したいコードを確認するんだけど
    その時は Emacs の中で探す方が早い。
    で、探して確認するまではいいんだけど、そこから GitHub 上のコードへのリンクを取得しようとするとちょっと面倒。

    これまでは、GitHub のリポジトリのトップからディレクトリを辿って行って
    当該コードを再度探していました。めんどくさいねっ。

    というわけで解決する手段を探していて
    最近導入したのが [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] というやつ。

    こいつを入れてる状態で、GitHub のリポジトリに突っ込んであるコードの上で
    ~M-x browse-at-remote~ を実行すると
    GitHub でのリポジトリでのコードの位置でブラウザを開いてくれる。

    コードの上でと書いたけど、リージョンを選択していればその範囲が選択された状態で実行すると
    選択した行がハイライトされた状態で開いて便利。

    その状態から GitHub 上で ~Copy permalink~ をしておいて
    PR のコメントにコピーしたリンクを貼り付けるとコードも表示されて便利。

    で、結構よく使うコマンドとなったので
    Hydra から即呼び出せるようにしてある。

    Global に使うコマンドを突っ込んでる Hydra は key-chord で ~jk~ を叩くと呼べるようにしていて
    その中で ~B~ を叩けば browse-at-point が呼ばれるようにしてある。

    というわけで、導入と Hydra の設定を追加しているプルリクが以下になります。
    https://github.com/mugijiru/.emacs.d/pull/205

    という使い方をしているけど、
    実は似た機能を提供している [[https://github.com/sshaw/git-link][git-link]] で ~git-link-use-commit~ のフラグを立てておいて
    他にもいくつか設定を入れたりしたらもっといい感じのことができるのかもしれない。
    今度試すか……。

*** DONE 2021年にもなって ember-rails で新規アプリを書いてみてる :@Rails:@Ember_js:
    CLOSED: [2021-02-13 土 01:15]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-in-2021
    :END:

    少し思うところがあって、
    2021 年になったというのに [[https://github.com/emberjs/ember-rails][ember-rails]] を使って新規で Web アプリを書いている。

**** ember-rails とは?

     ember-rails は
     Ember.js という Web フロントエンド MVC なフレームワークを
     Rails といい感じに連携してくれて快適な Web アプリケーション開発体験を提供してくれるものであった。

     過去形なのは、ember-rails は Rails3 とか 4 とかの時代に主に使われていて
     既にメンテナンスされてないのと、
     今はそれよりも良い [[https://github.com/thoughtbot/ember-cli-rails][ember-cli-rails]] というのがあるから。

**** 今 ember-rails を使うと何がつらいか

     色々つらい。

***** まずメンテナンスが止まってる
      なので Rails 6 で動くかがわからない。
      多分、試している人はいないし、自分もそこまで試す気力はない。

***** Ember.js のサポートが 2.18.2 までとなっている。
      より詳細に話すと
      ember-rails が依存している Gem である ember-source で
      本当は 3.0.0.beta.2 まで出てるんだけど、β版のことは無視する。
      https://rubygems.org/gems/ember-source/versions/2.18.2

      で、その 2.18.2 は既にサポートされてないバージョンである。

      サポートされてないバージョンを使うのはセキュリティ面でもまずいし
      もはや情報もあまり落ちてないので苦行である。

      Ember.js 公式サイトのドキュメントが
      過去のバージョンのものも残されているのでそれを頼りにするしかない。
      というか公式で残しててくれてありがとう。それがないと何もできないよ。

***** ember-rails だと Ember.js の addon が導入できない
      例えば Handlebars でロジックを書く上で
      とても基本的な比較用のヘルパーを提供してくれる [[https://github.com/jmurphyau/ember-truth-helpers][ember-truth-helper]] が使えない。
      これが使えないはめっちゃ不便で、
      それをなんとかするために同じようなコードを自前で用意するハメになる。

      他にも [[https://github.com/ember-community-russia/awesome-ember][ember-community-russia/awesome-ember]] に載っている色々なものが使えないわけだ。
      つらいどころか悲しくなってくる。

***** 自動テストが書けない
      Ember.js は QUnit で自動テストができるようになっているのだが
      ember-rails だとそれも使えない。
      すなわちフロントエンドのコンポーネントの単体テストが書けないのである。

**** それでも ember-rails を使いたい方には

     どうして素直に ember-cli-rails や ember-cli そのものを使おうとしないのかはわからないけど
     どうしても ember-rails の世界に住みたいのであれば
     [[https://github.com/discourse/discourse][discourse]] のソースを参考にしたら良いと思う。

     どうやら [[https://github.com/discourse/discourse/pull/11932][ember-cli に乗り換える方針で動いているよう]] だが
     今日時点の Gemfile には未だに discourse-ember-source などの記述が残っている状態であり、
     まだ完全移行はできてない様子。

     [[https://rubygems.org/gems/discourse-ember-source/versions/3.12.2.2][discourse-ember-source]] は 3.12 系まで追従していたようなので
     そこまでは discourse の真似をすれば使えるだろう。

     また彼らは ember-rails を使いながら qunit でのテストもできるようにしているようである。
     正直マジか頑張ったなって気持ち。
     ちょっとどうやって動かしているのかはわからない。
     あんまり調べる気力もない。
     なんとなくわかったことは ES6 の module システムを活用して頑張ってる雰囲気があることである。

     他にも addon も使えるようにしている様子でもあるが、
     これもちょっとよくわかってない。
     あまり adoon が使われてる気もしないが……。

     ともかく ember-rails を独自に拡張した上で色々頑張っているようである。すごい。
     それでももう ember-cli-rails に乗り換えようとしているようなので
     今から ember-rails の世界に住もうとするのはやめた方がいいはず。

     あ、よく見ると Rails は 6.0 系だ。
     ってことは少なくとも discourse-ember-rails なら Rails 6.0 でも動くわけか。なるほど。

**** で、なぜ自分は ember-rails で新規アプリを書いているか

     マゾなので、敢えてその環境で新規アプリを用意しておいて
     そこから ember-cli-rails に移行する、みたいなことをしてみたいから。

     本当は自分で ember-rails なアプリを書くつもりはなかったんだけど
     サンプルになるようなアプリが探せなかったってのもある。
     これが Yak Shaving か〜と思いながら粛々と小さなアプリを書いていくのであった

     できたらまた記事にする。
     アプリ自体は公開しないけど、ソースは GitHub に上げるつもり。

*** DONE ember-rails で書いた Web アプリを GitHub で公開した :@Rails:@Ember_js:
    CLOSED: [2021-02-21 日 15:40]
    :PROPERTIES:
    :EXPORT_FILE_NAME: publish-ember-rails-app
    :END:

    [[*2021年にもなって ember-rails で新規アプリを書いてみてる][この間の記事]] で書いたように
    ember-rails で簡単なアプリケーションを作ってた。
    よくある TODO アプリである。

    [[file:images/screenshot-ember-rails-todo-app.png]]

    先週時点では「テストとかなくてもいいから動けばいいだろ」って気持ちだったけど
    なんとなーくテストを追加したくなったり
    あんまり慣れてない docker-compose 対応してみたりしていたのと
    平日はこのプログラムに触れてなかったので、結構日が空いてしまった。

    まあ、それはともかくとして、
    とりあえず [[https://github.com/mugijiru/ember-rails-todo-app/]] に置いておいた
    現時点の最新コミットで [[https://github.com/mugijiru/ember-rails-todo-app/tree/v1.1.1][v1.1.1]] のタグを振ってるやつは
    自分の知ってる一番古いスタイルで書かれてる状態にしてある。

**** 使ってる Gem

     - Ember.js 関係
       - ember-rails
       - ember-source
       - jquery-rails
         - Ember.js は 2 系まで jquery に依存しているので
           - よく見ると ember-rails の依存に入ってるから書かなくて良かったな……
       - active_model_serializers 0.9
         - 0.9 系じゃないとうまく動かないっぽい
     - CSS framework
       - bootstrap-sass
         - レガシー感の演出のため敢えてこれにしている
     - テスト関係
       - rspec-rails
       - factory_bot_rails
       - database_rewinder
       - capybara
       - selenium-webdriver

     あたり。

**** レガシー感の演出

     レガシー感を出すために bootstrap-sass(Bootstrap3系になる)を使ったりはしているが
     あまり特別なものは使ってない。

     また ember-rails で ember アプリのソースコードを generate すると
     es6 module を使ったようなコードが出力されるけど、
     これも敢えてレガシー感を出すために module を使わない形式に書き直している。

     よりレガシー感を出すために CoffeeScript にするという手もあったけど、
     さすがにそこまでは頑張りたくないw
     もう何年も触ってないよ CoffeeScript...

     そしてページ全体を Ember.js にはしないで
     ページの一部を Ember.js にする [[https://guides.emberjs.com/v2.18.0/configuring-ember/embedding-applications/][埋め込み]] 形式を採用している。
     既存のアプリに Ember.js を後乗せした感の演出である。
     実際、構築時には一時的に普通の Rails App として動くようにしていた。

     他にこだわったところは、今回は単一のアプリケーションしか動かしてないけど
     [[https://github.com/emberjs/ember-rails#multiple-ember-application][Multiple Ember Application]]
     の作法に則って、Ember アプリケーションを追加で乗せられるようにしている。
     これにより「この画面も Ember 化しようず」という流れで
     Ember アプリが複数動いてる状態により近くなったんじゃないかなと。
     実際今回動いてるのは1つだから、ちょっと違うけどね。。。

**** 最後に

     ここから段々と最新の Ember.js を使えるように寄せていくつもり。

*** DONE 古い ember-rails App で一部ファイルを ES6 Module 化 :@Rails:@Ember_js:
    CLOSED: [2021-02-21 日 22:41]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-partial-modulize
    :END:
**** これは何?
     ember-rails を古いスタイルで書いておいて
     それをモダン化していく企画の第一弾の記事。

**** 何をしたのか
     今回は ES6 module を使ってない ember-rails アプリケーションで
     一部のファイルだけ ES6 Module にしてみた。

**** 何が嬉しい?
     今回扱ってるアプリケーションのサイズはとても小さいので
     まとめて置き換えることも可能というか、
     ぶっちゃけ [[https://github.com/mugijiru/ember-rails-todo-app/pull/7][古いスタイルに書き換えた PR]] を revert するだけで
     ES6 Module 化できたりする。

     しかし、世の中に潜んでいる、レガシー化した ember-rails のプロジェクトでは
     全部まとめて ES6 Module にするのはファイル数が多過ぎて困難かと考え、
     敢えて一部のファイルだけ ES6 Module 化する方法を探してみた。

**** どうやったらできるの?

     簡単に言うと
     ES6 Module 形式で書いたやつを import して
     Ember.js Application の Namespace に放り込めばいいだけ。

***** Example
      まずはコンポーネントなどを
      ~app/assets/javascripts/ember-app/components/foo.module.es6~ ってファイル名で

      #+begin_src js
      import Ember from 'ember';

      export default Ember.Component.extend({});
      #+end_src

      のように書いておく。
      拡張子が ~.module.es6~ というのがポイントで、
      そうしておくと
      [[https://github.com/tricknotes/ember-es6_template][ember-es6_template]] という Gem が
      自動的に ES6 の module として判定してくれるようになっている
      https://github.com/tricknotes/ember-es6_template/blob/c1c7b8d23be7669a0aa6c5f9c71b916a3799f9a6/lib/ember/es6_template/sprockets.rb#L10

      そして ~app/assets/javascripts/ember-app/application.js.es6~ の末尾にでも

      #+begin_src js
      import FooComponent from 'ember-app/components/foo';

      EmberApp.FooComponent = FooComponent;
      #+end_src

      のように書いたら、
      一応 module 形式で書けるし、
      それを window.EmberApp で用意した Ember.js Application で使えるって感じ。

**** ファイルの数と同じ量の import 書くの?

     だるいよね。
     なので import 処理は
     ~app/assets/javascripts/ember-app/import-modules.js.es6.erb~
     という erb template でも分離して

     #+begin_src erb
     <% module_dir = Rails.root.join('app/assets/javascripts/ember-app/modules') %>
     <% Dir.each_child(module_dir) do |dir| %>
       <% next unless FileTest.directory?("#{module_dir}/#{dir}") %>
       <% Dir.glob('*.module.es6', base: "#{module_dir}/#{dir}") do |module_file| %>
         <% module_name = File.basename(module_file, '.module.es6') %>
         <% klass_name = "#{module_name.underscore.camelize}#{dir.underscore.singularize.camelize}" %>
     import <%= klass_name %> from 'ember-app/modules/<%= dir %>/<%= module_name %>';
     EmberApp.<%= klass_name %> = <%= klass_name %>;
       <% end %>
     <% end %>
     #+end_src

     とでも書いておけば全部いい感じに読んでくれる。

**** 関連 PR

     実際に動くコードは以下の PR で用意した。
     https://github.com/mugijiru/ember-rails-todo-app/pull/8
     https://github.com/mugijiru/ember-rails-todo-app/pull/9

     最初の PR で ~modules~ フォルダにさらに components フォルダを掘って
     その中にファイルを配置している。

     その方が全部移行できた後にまるっと置き換えするのに楽そうだからだ。

     また import して Namespace に放り込む処理も別ファイルに追い出している。
     これも、完全移行が済んだら不要になるファイルなので
     消しやすさを重視して分割しておいた。

     さらに後続の PR で、
     複数のタイプが来ても対応できるように書き換えている。
     Model は対応できてないけど、ま、Model は移行してないのでとりあえず放置。

     CI でテストも通しているしバッチリだと思う。
     デプロイできるようにはしてないからサーバで動くかは確認してないけど、ま、大丈夫だろ

*** DONE 古い ember-rails App で ES6 Module 化を完了した   :@Rails:@Ember_js:
    CLOSED: [2021-02-23 火 20:45]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-complete-modulize
    :END:

    - [[https://github.com/mugijiru/ember-rails-todo-app/pull/10][#10 サブフォルダのファイルを全て module に移行した]]
    - [[https://github.com/mugijiru/ember-rails-todo-app/pull/11][#11 残りのファイルも module 化した]]

    でやってることで全てだけど
    [[*古い ember-rails App で一部ファイルを ES6 Module 化][前回の記事]] でやってた内容を完了まで持って行った。

**** サブフォルダ以下の ES6 Module 化
     https://github.com/mugijiru/ember-rails-todo-app/pull/10 でやったこと。

     これは基本的に単純で、
     ほぼ前回の記事でやってることを全部のフォルダに適用しただけ。

     Model だけ命名規則が他と違うので
     import 関連の処理をそこだけ分岐している

     #+begin_src erb
     <% if dir == 'models' %>
       <% klass_name = module_name.underscore.camelize %>
     <% else %>
       <% klass_name = "#{module_name.underscore.camelize}#{dir.underscore.singularize.camelize}" %>
     <% end %>
     import <%= klass_name %> from 'todo-app/modules/<%= dir %>/<%= module_name %>';
     TodoApp.<%= klass_name %> = <%= klass_name %>;
     #+end_src

     Model は ~models/hoge.module.es6~ とあったら ~Hoge~ として使われるようにして、
     他は例えば Component だと ~components/fuga.module.es6~ とあったら ~FugaComponent~ として使われるようにしているだけ。

     あとはそれぞれのファイルを ~*.js.es6~ から ~*.module.es6~ に rename して import, export に書き換えるだけ。
     とても簡単だし、全部まとめて変更する必要もないので楽。

     ただこれをやってる時に気付いたのが
     ~import-modules.js.es6.erb~ が cache されてるおかげで
     module 化対象のファイルだけ変更・移動しても import 文が変更されなくて
     うまく読み込まれない問題があるということ。
     何故か rspec は通ったりするけど。

     まあその時は ~rails tmp:cache:clear~ して cache を消すか
     ~import-modules.js.es6.erb~ に適当に空行でも加えて cache を使われないようにしたら解決する。

**** router.js.es6, <APP_NAME>.js.es6, environment.js.es6 の ES6 Module 化
     https://github.com/mugijiru/ember-rails-todo-app/pull/11 でやったこと。

     サブフォルダのファイルを全部 module にしたら
     後は変更しないといけないファイルはこれぐらい。

     変更の流れは大体以下の感じ

     1. router.js.es6 をこれまでのファイルと同じように module 化
     2. environment.js.es6 も同様に module 化
     3. <APP_NAME>.js.es6 の module 化とそれに伴うファイル移動等

***** router.js.es6 をこれまでのファイルと同じように module 化
      https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/359520f6656920ac8ef3fe623d15f2368cc66a78

      この commit でやってることそのもの。

      拡張子を module.es6 に変更して中身を module っぽく書いて
      require される順番を最後に移動し、最後に他のファイルみたいに import してあげるだけ。

***** environment.js.es6 も同様に module 化
      実はこのファイルをまともに使ってなかったので PR では後ろに回したんだけど、
      多分ちゃんとやるならこのタイミングかなって。

      これもさっきの手順と同じ感じだと思う。
      require するタイミングは ~//= require ./todo-app~ の直前になる。
      そのタイミングになる理由はよく知らんけど
      ember-rails で generate したらそこに来るからそこでいいんだろ(適当)

      実際 import して使われるタイミングは application.js.es6 の中で明示的に import することになるので
      require_self するより前ならどこでも良さそうな気はする。

      あと、多分、古いスタイルに書き換える時に適当にやってたので
      そもそも古いスタイルでの environment の置き方が正しくなさそうな気もする。

      一応 https://guides.emberjs.com/v1.10.0/configuring-ember/ に

      #+begin_quote
      Note that the above code must be evaluated before Ember.js loads.
      #+end_quote
      と書いてるのでそれに従って対応してたつもりだけどね。

      ま、古いスタイルの正しいやりかたを必要としている人はいないだろうし
      新しい形式でちゃんと動けば良かろう。ちゃんと動くか知らんけど。

***** <APP_NAME>.js.es6 の module 化とそれに伴うファイル移動等

      https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/d3673bfa455906abd0ff6d31d1d3f4f083bd4a71
      の commit でやってることだけど、ここが結構まとめて色々やらないといけなさそう。

      <APP_NAME>.js.es6 を ES6 Module 化をするんだけど
      ここが一番色々書き変わるところ。

      事前に Namespace を用意する必要がなくなったので require_self を一番最後にしたり、
      ~import Application from 'ember-rails/application~ しておいて
      そこから extend して export して、みたいな。
      まあ [[https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/d3673bfa455906abd0ff6d31d1d3f4f083bd4a71#diff-7aa5fb21bec5b1e11d78f1b7c34b3b92f05b293d97a99ed2af713f81ea5dab82][ファイル]] を見た方が早いか。

      で、こいつを ES6 Module にすると ember-rails での自動 import が動くようになる。
      なので、事前に module 化していたファイルを全部本来の位置に戻した上で
      これまでお世話になってきた ~import-modules.js.es6.erb~ にさよならすることになる。
      ま、そいつは消しやすいように別ファイルに分離していたんだけども。

      あと当然 application.js.es6 も、
      他のファイルが全部 module 化された前提で書き換える必要がある。
      まあほとんど <APP_NAME>.js.es6 を import して create するだけなんだけど。

      以上でほぼ終わりだけど、
      不要になった modules フォルダを消して require_tree する処理を消すのを忘れずに。
      麦汁さんはそれを忘れて [[https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/0f90fda419f9c23f844ba2e53dc1c2fa2e9b5d51][commit を積むことになった]]

**** ここまでやると何ができるようになるか

     ember-rails で書いた上で最も最新の記述に変更できた状態となる。
     というわけで、これでようやく ember-cli-rails 移行する準備ができました! やったね!

     まあぶっちゃけ ember-cli-rails 移行と module 化を同時にやっちゃうという手もあるけど、
     1回1回の変更差分を小さくするには、バラバラがいいかなってことで分けてやっている。

     だって、そうじゃないと「はい変更の多い PR はリジェクト〜wwww」ってされかねない^^

*** DONE ember-rails でコンポーネントを共通ライブラリとして切り出す :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 10:45]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-extract-common-libs
    :END:

    ember-rails を使って1つの Rails アプリの上に
    複数の Ember.js アプリケーションを動かしていると
    各アプリで同じようなコンポーネントを使っていたり、
    あるいは同じようなコンポーネントが必要だというのに気付いて
    共通ライブラリとして実装したくなることがある。あるんだよ。

    というわけで、その共通化を2パターンでやってみた。
    2パターンというのは 旧来の書き方の場合と
    ES6 Module 対応版の場合とである。

    なおいずれのパターンもサーバへのデプロイはやってないので
    もしかしたらサーバ環境では動かないかもしれないがご容赦を。

**** 旧来版
     先に答えを出すと
     https://github.com/mugijiru/ember-rails-todo-app/pull/13
     に実装した通りである。

***** template からの呼び出し
      template で ~{{ember-libs/button}}~ と書いた場合に
      Resolver には ~component:ember-libs/button~ として解釈するように要求されるっぽい。
      これはソースからではなく、挙動的に確かめただけ。

***** コンポーネントの探索
      旧来の書き方の場合に探索に使われるのが GlobalsResolver というやつ。

      この GlobalsResolver というやつは [[https://github.com/emberjs/ember.js/blob/e2007b6ecb046fd06f6b43c381e8a1128914ad43/packages/%40ember/application/globals-resolver.js#L59-L76][コメント]] にも書かれてるように
      ~component:ember-libs/button~ と渡されたら、
      GlobalsResolver は ~EmberLibs.ButtonComponent~ として解釈するようになっている。
      つまり EmberLibs という名前空間の ButtonComponent を探しに行くようになっている。

***** 名前空間の定義
      というわけで、まずは [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-e1803bb0635866bc90975a1321dbfa6d20be59e76ec3d7b80c8acc4656f8af9fR6][ember-libs/ember-libs.js.es6]] に書いてるように

      #+begin_src js
      window.EmberLibs = Ember.Namespace.create()
      #+end_src
      と書くことで
      EmberLibs という名前空間を定義してやる。

      一応 ~ember-libs/ember-libs.js.es6~ では require の順番として
      ember はそこで定義している実装を使うので先に require して
      そのファイルで定義している名前空間を components で使うので components を require するより前に
      require_self をしている。

***** 共通コンポーネントの記述
      各コンポーネントはその名前空間の下に入るように書けばいい。
      例えば [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-9f9be147342dc470d8f0cba8a06a55a210550e01b22502bd6e0aff0d029ae38cR1][ember-libs/components/button.js.es6]] に書いてるように

      #+begin_src js
      EmberLibs.ButtonComponent = Ember.Component.extend()
      #+end_src

      というように書いてやれば動く。

***** config.handlerbars.templates_root の設定

      templates を ember-libs/templates に入れるので
      Rails 側の設定で ~config.handlebars.templates_root~ に ~ember-libs/templates~ を追加するのを忘れずに。
      ember-rails の設定例に従っていれば [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-c1fd91cb1911a0512578b99f657554526f3e1421decdb9e908712beab57e10f9R34][config/application.rb]] に設定があるはず。

***** 利用側の設定
      あとは [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-2cb7f9d0c761533d0e2b01e0b7e6f4a34529c7b52f9a13c7493b2629251bccd8R9][todo-app/application.js.es6]] に書いてるように
      この共通コンポーネントを使いたいアプリ側で

      #+begin_src js
      //= require ember-libs/ember-libs
      #+end_src

      としてやるだけでさくっと使えるようになる。

***** 他の type について
      試してないけど mixin や service ぐらいなら同じノリでいけるんじゃないかなと思ってる。
      model もいけそう。
      名前空間が変わるだけだし、その呼び出しも難しくないし、大体なんとかなりそう。

***** 余談: 名前空間を分けない場合

      上のようなやりかたをしているのは、名前空間を分けたいってのが先だったので、
      各アプリで名前空間を分ける必要がなければ、全部のアプリで

      #+begin_src js
      window App = Ember.Application.create()
      #+end_src

      とかしちゃって

      ~ember-libs/components/button.js.es6~ では普通に書く場合と同じように

      #+begin_src js
      App.ButtonComponent = Ember.Component.extend()
      #+end_src

      みたいにしておいて require したら ~{{button}}~ で使える。
      個人的には、名前空間が混ざるとどっちかが上書きされたりしそうで怖くて嫌だけど。

**** ES6 Module 対応版の場合
     最初に答えを出すと
     https://github.com/mugijiru/ember-rails-todo-app/pull/12
     で実装したやつ。

***** コンポーネントの探索
      ES6 Module で書かれている Ember Application では
      基本的に単一の名前空間しか持たないようである。
      また、使用される Resolver が [[https://github.com/ember-cli/ember-resolver/tree/v0.1.21][ember-resolver@0.1.21]] となっている。

      こいつは ~component:ember-libs/button~ と渡って来た時の解釈が GlobalsResolver と異なっている。
      この ember-resolver の場合は、アプリケーションの下の ~components/ember-libs/button~ を探しに行く。

      なのだけど今回はそんなところを探しに行って欲しくないので、
      regsiter を Ember.js で自動的に解決して対応してもらうのではなく
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-029812c538a995224fcf19bfa24f65558246c054aea77c95ec1f4a404b4f5256R1][ember-libs/ember-libs.module.es6]] に書いているように、
      自前で

      #+begin_src js
      application.register()
      #+end_src

      して対応することにした。

***** コンポーネントの register
      基本的には以下のように書いておけば Button コンポーネントは動くようになる。

      #+begin_src js
      import Button from './components/button';

      application.register('component:ember-libs/button', Button);
      #+end_src

      が、コンポーネントが増えていった際に全部そうやって書くのはアホらしい。
      というわけで、自動的に解決するようにした。

***** コンポーネントの auto register

      ES6 Module 対応して import している場合に ember-rails では実際はどんな形に transpile されるかというと
      どうやら requirejs の機能で読み込んだりしているらしい。

      で export されているファイルは ~requirejs.entries~ に含まれているので
      そこから必要なものを探し出して
      ~application.register~ に対し、解釈してほしい名前で渡してクラスを渡しておけば
      template で ~{{ember-libs/button}}~ とした時に require したクラスのインスタンスとして動いてもらえる。

      という感じで自動的に register する処理を [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-029812c538a995224fcf19bfa24f65558246c054aea77c95ec1f4a404b4f5256R4][メソッドにして]] おけば、
      利用側はそれを呼び出すだけでセットアップが済む

***** config.handlebars.templates_root の設定
      やはりこちらの場合も templates を ~ember-libs/templates~ に入れるので
      Rails 側の設定で ~config.handlebars.templates_root~ に ~ember-libs/templates~ を追加するのを忘れずに。
      ember-rails の設定例に従っていれば [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-c1fd91cb1911a0512578b99f657554526f3e1421decdb9e908712beab57e10f9R34][config/application.rb]] に設定があるはず。

***** 利用側の設定
      アプリ側では [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-97468a821d4c12c1b223617fba29257a5b1e00553a1b8e8f403ee99864756ebaR4][initializers/resolve-common-libs に書いている]] ように
      initializer で

      #+begin_src js
      EmberLibs.registerAll()
      #+end_src

      を叩くだけでいい感じに使えるようになる。

***** 他の type について
      試してないけど、component でやってみた所感。

      mixin はどうせ明示的に import して使うので関係なさそう。
      service は、component と同じやりかたでいけそうな気がする。
      model もいけそうなので user model を共通化するような用途がありそう。

      controller もいけそうだけどそれに付随する route からどう呼ばれるかが難しそう。

***** 余談: 他の方法について
      多分 EmberEngine とか EmberAddon の仕組みを使って
      似たようなことはできそうな気はする。

      だけど ember-rails で Engine や Addon を使うというのは
      それはそれでかなり大変かと思われるので今回はそれを動かすようなことはしてない。

      より正確にいうと、
      それしか方法がないかもと思って途中まで調べたけど、
      厳しそうだったので今回は上述の方法にしておいた。

**** 最後に

     旧来版と ES6 Module 対応版とで実装方法は異なるが
     どちらでも同じような使い勝手でコンポーネントを共通ライブラリとすることができることがわかった。

     両方のパターンが使えることがわかったので、
     ES6 Module 対応版への移行がまだでも躊躇せずライブラリを分割できそう。

*** DONE ember-rails でコンポーネントをサブフォルダに配置する :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 11:19]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-component-in-subfolder
    :END:
    Ember.js に限らずコンポーネントは増えてくると
    サブフォルダに分割して管理したくなるよね。
    ということでそのあたりの記事。

    これも、ES6 Module 対応版と旧来版の両方を書く。
    ES6 Module 対応版は何も考えることがないので、
    この記事は旧来版のためにあるようなものだけど。

**** ES6 Module 対応版の場合
     上に書いたように
     これは https://github.com/mugijiru/ember-rails-todo-app/pull/14 に実装してあるけど
     とっても簡単

***** component をサブフォルダに移動
      ~components~ の下に適当なフォルダを掘って
      その中に移動するだけ。

***** template をサブフォルダに移動
      ~templates/components~ の下に適当なフォルダを掘って
      その中に移動するだけ。

***** template からの呼び出し
      template, component をそれぞれ

      - template :: ~templates/components/hoge/fuga.hbs~
      - component :: ~components/hoge/fuga.module.es6~

      と配置した場合は
      ~{{hoge/fuga}}~ と書いて呼び出せばいい感じに動く。以上。

      こういう感じで動くように [[https://github.com/ember-cli/ember-resolver/tree/v0.1.21][ember-resolver@0.1.21]] が作られてるっぽいのでとても楽。

      Ember.js のドキュメントなどを見ている感じだと
      多分もっと新しいバージョンでも同じ感じで動くっぽい。
      というわけで Ember.js@3 にしても多分動きそうなので安心感がある。

**** 旧来版の場合
     これは GlobalsResolver の挙動のおかげでちょっと大変。

     と言っても
     https://github.com/mugijiru/ember-rails-todo-app/pull/15
     で実装してある。

     今回やりたかったことは、
     テンプレートとコンポーネントをサブフォルダに移動して扱えるようにすることなので、
     その実現方法を書いておく

***** template からの呼び出し
      ~{{hoge/fuga}}~ と呼び出した際に [[https://github.com/emberjs/ember.js/tree/v2.18.2/packages/ember-application/lib/system/resolver.js#L34][GlobalsResolver]] でどう解釈されるとかというと
      [[*ember-rails でコンポーネントを共通ライブラリとして切り出す][前の記事]] にも書いたように
      Hoge という名前空間の FugaComponent を探しに行くようになってるというのが前提。

***** component をサブフォルダに移動

      GlobalsRegister の解釈に合わせて
      FugaCompnent を Hoge 名前空間に所属させればいいので

      #+begin_src js
      Hoge.FugaComponent = Ember.Compnent.extend()
      #+end_src

      という形で定義しておけばいい。

      旧来方式だとファイル自体は components の中にあればファイル名も位置も何でもいいはずなので
      人間がわかりやすいように ~components/hoge/fuga.js.es6~ として配置したら良い。

      また、事前に Hoge という名前空間は必要なので
      ~components/hoge.js.es6~ とファイルで

      #+begin_src js
      window.Hoge = Ember.Namespace.create()
      #+end_src

      としておく。

      前回の共通ライブラリ切り出しと大体似たお話ですね。

***** template をサブフォルダに移動
      これは難しいことは何もなくて
      ~templates/components/<名前空間>/<コンポーネント名>.hbs~
      みたいに配置したら良い。

      つまり ~Hoge.FugaComponent~ の場合は
      ~templates/components/hoge/fuga.hbs~
      と置けばいい。

***** さらにネストさせたい場合
      試してないけど、
      [[https://github.com/emberjs/ember.js/blob/e2007b6ecb046fd06f6b43c381e8a1128914ad43/packages/%40ember/application/globals-resolver.js#L221][GlobalsRegister の実装]] を見ている感じだと、多分

      #+begin_src js
      window.Hoge = Ember.Namesupace.create()
      #+end_src

      #+begin_src js
      Hoge.Fuga = Ember.Namesupace.create()
      #+end_src

      #+begin_src js
      Hoge.Fuga.PiyoComponent = Ember.Component.extend()
      #+end_src

      にみたいな感じに名前空間をネストさせれば大丈夫そう。

**** 最後に
     前回の共通ライブラリ切り出しよりは簡単でしたね。

     ES6 Module 対応版では直感的にやるだけで終わるし、
     旧来版でも共通ライブラリと大体やること一緒というか、
     それよりも手順が少ないので、サブフォルダへの移動を先にやった方が良かったかも。

     あと、今回も両パターンでやってるので、
     ES6 Module 移行前にこちらを実施しても簡単な修正で対応できることがわかりました。やったね。

*** DONE ember-rails でユーザー情報を Rails から inject    :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 13:10]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-inject-from-rails
    :END:

    フロントエンドのフレームワークを使っていて、
    そのフレームワークで Server Side Rendering をしてない時に
    API 経由でデータ渡すよりも表示用の HTML 経由で直接データを渡したい時がある。

    ember-rails を使ってる時もそれはあって、
    今回は Haml 経由で Ember.js に情報を渡して表示する方法を書いてみた。
    もちろん旧来版と ES6 Module 対応版の両方で実装している。

**** 旧来版
     https://github.com/mugijiru/ember-rails-todo-app/pull/16 で実装したやつ。


***** おおまかな実装内容
      こちらは名前空間に Ember.js の外からアクセスできるので
      Haml 内に JavaScript を埋め込んで Ember に渡すというちょっと乱暴なことができる。

      今回は email を todo-items テンプレート内で表示したかったので
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/16/files#diff-69c2e4b0a6040f2873e963c79265340fd97c099e1ea1a7fbf579902259126e3fR1][Ember.js の呼び出し元の haml]] 内で

      #+begin_src js
      :javascript
        TodoApp.register('session:current-user', Ember.Object.extend({ email: '#{current_user.email}' }));
        TodoApp.inject('controller:todo-items', 'current-user', 'session:current-user');
      #+end_src

      と書いてみた。

      以下にもう少し詳細に書いてみる。

***** ユーザー情報の登録
      #+begin_src js
      TodoApp.register('session:current-user', Ember.Object.extend({ email: '#{current_user.email}' }));
      #+end_src

      という記述で JavaScript の中に Haml での Ruby のコード呼び出し機能を用いて
      email を EmberObject を継承したクラスにぶち込んでいる。

      正直 ~:javascript~ で書いて Ruby のコードを呼び出すのは結構乱暴だとは思うけど
      できちゃうのでやっちゃった。

***** コントローラへの inject

      アプリケーションに ~session:current-user~ として登録できたので、後はもう

     #+begin_src js
     TodoApp.inject('controller:todo-items', 'current-user', 'session:current-user');
     #+end_src

     として controller に inject することができる。

***** template での表示

      inject された controller の template で ~{{current-user.email}}~ と記述するだけで
      そのユーザーのメアドが表示される。以上。

**** ES6 Module 対応版
     https://github.com/mugijiru/ember-rails-todo-app/pull/17 で実装したやつ。

***** おおまかな実装内容
      こちらは旧来版とは違って名前空間は隠蔽されているため
      Haml で JavaScript を書いて埋め込むなんて荒技はできない。

      だけどまあそんなことをしなくても
      data 属性に情報を埋めておいて
      それを initializer で取得して使えばいいだけである。

***** Haml へのデータ埋め込み
      Haml の方では

      #+begin_src haml
      #todo-app{ data: { email: current_user.email } }
      #+end_src

      こんな感じにデータを埋めておく。
      それを Ember.js の initializer で取得して処理してあげれば良い。

***** initializer でのデータの取得
      まずはデータを

      #+begin_src js
      const currentUser = Ember.Object.extend({
        email: document.querySelector(application.rootElement).dataset.email
      });
      #+end_src

      という感じで取得して適当な変数に放り込んでおく。
      ま、大体普通の JavaScript なので何も難しいことはない。

***** アプリケーションへの登録
      上で取得したデータをアプリケーションから見れるように登録してあげる必要があるので
      以下のように ~application.register()~ でデータを登録する。

      #+begin_src js
      application.register('session:current-user', currentUser);
      #+end_src

***** controller への inject
      上に書いた感じで application に登録してしまえば、後は旧来版と同じように

      #+begin_src js
      application.inject('controller:todo-items', 'current-user', 'session:current-user');
      #+end_src

      という感じで設定できる。

***** template での表示
      あとは旧来版と同じく
      inject された controller の template で ~{{current-user.email}}~ と記述するだけで
      そのユーザーのメアドが表示されると。うん、簡単でしたね。

**** 最後に
     API を経由せずに Ember.js にデータを渡す方法が
     旧来版と ES6 Module 対応版の両方で書けることがわかったので、
     旧来版から移行しようとした時もすぐ書き直せそうで安心。

     ES6 Module 対応版の方は、
     ember-rails から ember-cli-rails とかに乗り換えてもそのまま使えそうだしね。

*** DONE ember-rails から ember-cli-rails へ               :@Rails:@Ember_js:
    CLOSED: [2021-03-06 土 17:05]
    :PROPERTIES:
    :EXPORT_FILE_NAME: migrate-ember-rails-to-ember-cli-rails
    :END:

    Ember.js 関係で最も書きたかった記事にやっと辿り着いた。
    表題の通りで、
    ember-rails から ember-cli-rails に置き換える、という記事です。
    多分長くなる。

    やったことはいつも通り [[https://github.com/mugijiru/ember-rails-todo-app/pull/18][GitHub の PR]] にしています。

    PR の Description で「Rails 側ではこうした」「Ember 側ではこうした」みたいに書いているので
    ここではある程度時系列に沿ったような書き方にしようかな。

    完全に時系列通りには書かないので、
    正確な時系列でどうしたか知りたかったら PR のコミットログを追ってください

**** アプリの前提

     これまで作って来た https://github.com/mugijiru/ember-rails-todo-app が前提になります。
     ざっくり内容を書くと

     - ember-rails で Ember.js 2.18 の環境を動かしている
     - Sprockets での ES6 Module 対応済
     - 現実世界の複雑さを持ち込むために敢えて以下の手法を導入
       - Embedded Ember App
       - Multiple で動かせる構成
       - 一部コンポーネントの共通ライブラリ化
         - ember-libs という名前で別フォルダに切り出している
       - Bootstrap の利用
     - 複雑さでは以下もありうるが面倒などの理由でやってない
       - i18n.js での多言語対応
       - コンポーネント以外の共通ライブラリ化

     という感じ。

**** ember-rails 用の JS のコードが読まれないようにコメントアウト
     https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/8dd44540bd7d352e497f87a9a12df5ad3cf6efbb
     のあたりのコミット。

     本当は後からやった手順だけど、
     ここで読まれてるコードが邪魔になるので
     先にコメントアウトしておく方が後の手順でハマらなくて済むので
     ここに置いといた。

     まあ実は ember-cli-rails のアプリが読まれるところで
     ember-rails が require されてなければいいだけなので
     application.js で require_tree とかをしなければ良かったりはする。

**** Docker 環境への ember-cli の導入
     Docker でアプリが動くようにしているので、
     ember-cli も Docker で動くようにしている。

***** Docker で最新 LTS の Node.js が使われるように設定

      ember-cli と直接は関係ないけど、Node.js は入れる必要があるのでやってる手順。

      とりあえず最新の LTS を入れておく。
      Ubuntu で普通に apt から入れると 10 系が入っちゃうので
      yarn の apt リポジトリを登録してそこからインストールする。

      #+begin_src Dockerfile
      RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \
      && echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list

      RUN apt-get update -qq && apt-get install -y nodejs yarn
      #+end_src

***** ember-cli を Global に導入

      ember-rails で動いているアプリは Ember.js 2.18.2 で動いているので
      ember-cli も 2.18.2 を導入する。

      #+begin_src Dockerfile
      RUN yarn global add ember-cli@2.18.2
      #+end_src

**** アプリの初期構築

     上記手順で導入した ember-cli を使って改めて Ember.js アプリを構築する。
     ゼロから作っておく方が、より ember-cli-rails に向いた形になるとの判断。

***** ember-cli で移植先のアプリの雛形を構築

      ~RAILS_ROOT/ember/todo-app~ に構築する。

      ember-cli-rails の README だと ~RAILS_ROOT/frontend~ に構築するように書かれているが、
      複数の Ember.js アプリを平等に扱える形にしたいのと
      Ember.js アプリのコード置場を ~RAILS_ROOT/frontend~ にしていると
      Ember.js から別のフレームワークに差し替えが決まって、その移行作業をしている間に

      - frontend に新しいフレームワークで構築しようと思ったら既に Ember.js がいた
      - 新しいフレームワークでの実装を修正しようと思って frontend 以下を探していて時間を潰した

      ということが起こりそうなので、フレームワーク名は明示しておきたいお気持ち。
      というわけで ~ember~ というフォルダの下に更にフォルダを掘っているが、
      この考え方、あまり合意を得られた試しはない。みんな移行は発生しないつもりなのかな。

      ま、とりあえず以下のコマンドを実行したら ~RAILS_ROOT/ember/todo-app~ に雛形が作成される。

      #+begin_example
      $ ember new todo-app --no-welcome --skip-git --yarn --dir ember/todo-app
      #+end_example

      なお、面倒なので ~docker-compose run~ とかは省略している。
      ここより下の部分でも同様に省略しているので、
      そのあたりは読みながら脳内で補完とかしてください。

****** オプションについて
       - ~--no-welcome~ :: どうせ後で消すファイルが作られるだけなので出す必要なし
       - ~--skip-git~ :: Rails アプリと同じリポジトリに作るので git init は不要
       - ~--yarn~ :: yarn を使い慣れてるからそれを指定。ただ ~yarn link~ に問題があるから ~npm~ を使う方がいいかも?
       - ~--dir ember/todo-app~ :: ember というフォルダの中に構築するので指定する必要あり

***** ember-cli-rails-addon の導入

      ember-cli-rails と連携して ember-cli app を動かす時には
      ember-cli app 側に [[https://github.com/rondale-sc/ember-cli-rails-addon][ember-cli-rails-addon]] を入れておく必要があるので、
      早い段階で追加しておく

      #+begin_example
      $ cd ember/todo-app && ember install ember-cli-rails-addon
      #+end_example

      これを入れておくと CSRF Token のことを意識しないで済むし、
      ファイルを更新するだけで Rails から読めるように Ember.js app を build してくれたりする。
      というか、入れてないとそれらがうまく動かなくてハマる。

***** active-model-adapter の導入

      [[https://github.com/ember-data/active-model-adapter][active-model-adapter]] は
      ActiveModelSerializer の出力をいい感じに Ember.js で扱えるようにする Addon で
      ember-rails でも使われている。

      というわけでこいつも Rails でいい感じに Ember.js を使うためには必要なので先に入れておく

      #+begin_example
      $ cd ember/todo-app && ember install active-model-adapter
      #+end_example

**** ember-cli-rails の導入と設定

     ここは Rails 側の作業。
     ひとまず ember-cli-rails の導入に留め、
     ember-rails は一旦そのままにしておく。

***** ember-cli-rails の導入
      これは単に Gemfile に記載して ~bundle install~ を叩くだけである

      #+begin_src ruby
      gem 'ember-cli-rails'
      #+end_src

      #+begin_example
      $ bundle
      #+end_example

***** config/initializers/ember.rb で ember-rails の設定

      ember-cli-rails で generate コマンドが用意されているので
      まずはそれでファイルを生成する

      #+begin_example
      $ rails generate ember:init
      #+end_example

      これで ~config/initializers/ember.rb~ が作られるの。
      初期状態は以下の通り。

      #+begin_src ruby
      EmberCli.configure do |c|
        c.app :frontend
      end
      #+end_src

      それに変更を加えて、以下のようにする

      #+begin_src ruby
      EmberCli.configure do |c|
        c.app :todo_app, name: 'todo-app', path: Rails.root.join('ember', 'todo-app'), yarn: true
      end
      #+end_src

****** 引数について
       - 第一引数 :: あとで mount する時に使う値
       - name :: ハイフン繋ぎにしたかったので指定しているが、多分なんでもいい
       - path :: ~ember/todo-app~ に構築しているのでそれを見てもらえるように指定
       - yarn :: yarn を使い慣れてるので指定。ただ yarn link がうまく動かないのでやめた方がいいかも

***** config/routes.rb で Ember.js App を Mount

      Embedded Ember.js App というわけで
      Controller を自前で用意するので、contoller としてそれを指定する。

      #+begin_src ruby
      mount_ember_app :todo_app, to: '/ember_cli_todo_items', controller: 'ember_cli_todo_items', action: 'index'
      #+end_src

***** Controller 等の用意
      移植途中で元のアプリに戻せなくなるのは移行失敗時のリカバリを考えると嫌なのと
      元の挙動を確認したくなった時のために
      元の PATH で動く状態にすぐ戻せるようにしておきたい。
      というわけで別の PATH を用意して、ember-cli で構築したアプリはそこで動くようにする。

      #+begin_example
      $ rails g controller ember_cli_todo_items index
      #+end_example

      あとは ember-rails 実装での Controller, View を参考にしたりして以下の感じに。

****** Controller
       特にサーバから何かを View に渡す必要はないので基本的に空っぽ。

       #+begin_src ruby
       class EmberCliTodoItemsController < ApplicationController
         def index
         end
       end
       #+end_src

****** View
       rootElement を用意して、そこに initializer に渡す data 属性を置いておく。

       さらに ember-cli で生成する JS/CSS が読まれるように設定する。
       (今回 CSS は書かないけど……)

       #+begin_src haml
       #ember-cli-todo-app{ data: { email: current_user.email } }

       %base{ href: '/ember_cli_todo_items/' }
       = include_ember_script_tags :todo_app
       = include_ember_stylesheet_tags :todo_app
       #+end_src

       ~%base~ は Ember.js のアプリケーションを動かす PATH に合わせる必要があるのと
       最後の ~/~ が抜けていると script や stylesheet で正しく PATH 解決できないので注意。

       [[https://github.com/seanpdoyle/ember-cli-rails-assets][ember-cli-rails-assets]] の README を見ていると
       include_ember_script_tags とかに追加の引数で
       ~prepend: '/ember_cli_todo_items/'~ とか書いていれば ~%base~ は使わなくて良さそうだけど
       まだ試してはいない

**** ember-cli で作ったアプリが Rails 上で動くようにする
     Rails 側の設定はここまでで完了しているはずなので
     次は ember-cli 側の設定を進めて Rails 上で動くようにしていく。

***** config/environement.js の設定
      まず config/environment.js で以下を指定している

      #+begin_src js
      modulePrefix: 'todo-app',
      rootURL: '/',
      locationType: 'hash',
      #+end_src

      rootURL は ember-cli-rails の README 通りに設定していると
      ~/ember_cli_todo_app~ になりそうだが
      それを指定すると Ember.js App が読まれた時に URL が
      ~http://localhost:3000/ember_cli_todo_app/ember_cli_todo_app~ というように
      ~ember_cli_todo_app~ が二重に表示されてしまう。

      ちゃんと調べられていないが、恐らく README の記載では SPA として Ember が動く想定であって、
      ~include_ember_script_tags~ で読み込まれる Embedded App という想定ではないからと思われる。

      locationType は多分 hash にしておく方が
      ember-rails からの移行だと URL が変わらなくて良さそう、
      と思いつつ、深い PATH とかにしてないからか検証はできてない

***** app.js の設定
      あとは app.js の方でも config/environemt から読むようにしたり
      rootElement を指定したりしている。

      rootElement は config/environment で指定して、
      app.js ではそれを利用するのが正しい気はするが、一旦放置。

      #+begin_src js
      const TodoApp = Application.extend({
        rootElement: '#todo-app',
        modulePrefix: config.modulePrefix,
        podModulePrefix: config.podModulePrefix,
        locationType: config.locationType,
        rootUrl: config.rootUrl,
        Resolver
      });
      #+end_src

**** アプリの移植

     これまでの手順ではとりあえず ember-cli で構築した空っぽの Ember.js アプリが
     Rails の指定した PATH 上でとりあえず動くことを主眼に当ててやってきている。

     ここからはようやく、既存アプリの実装の移植。
     いくつかの段階に分かれるから、ここからも長いんだけどね。

***** 共通化してない機能のみで起動するようにする
      ember-libs というフォルダに切り出している部分までまとめて対応しようとすると
      えらく面倒なので、
      そのあたりを呼び出している部分はコメントアウトなどで呼び出されないようにして、
      とりあえず最低限の表示がされる程度を目指して移植するフェーズ。

      やってることは
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/3c31b5bcf86d68ac5db0eca9bb4af410df31c2f1
      のコミットが全てである。

      ざっくり説明すると

      - ember-rails で作っていた adapter, component, controller, initializer, model, route, template 等を ember-cli で作ったアプリの適切なディレクトリに配置
        - router.js は ember-cli 自動生成の雛形に必要な部分だけ移植している
        - adapter は ActiveModelAdapter を active-model-adapter addon から import するように変更している
      - 共通ライブラリに持って行った component の呼び出し部分をコメントアウト

      という感じ。
      これをすることで、不完全ながらも元のアプリと同じものが動くようになる

      ちなみにもっと複雑なアプリだと mixin を使っていたりなどするが
      それもテキトーに読み込まれないようにするなどで対処したらなんとなーく動く感じになるはず。なんとなーく。

      そうそう。ember-cli 対応することで各ファイルの単体テストなんかを書けるようになってるはずだけど
      元々そんなものを書いてないので、今回もそこまで頑張る必要はないと判断して
      フロントエンドのテストは一切書いていません。自動生成されたファイルはそのまま追加しているけど。

      一応、動作保証は system spec である程度担保しているつもり。
      ember-rails の時はそこでしか保証してないしね。

***** 共通ライブラリの Addon 化

      上までの段階だと共通ライブラリにした部分が全然動かないので、
      当然それを動く状態に持って行く必要がある。

      で、その際には、共通ライブラリを addon として構築し直すことをオススメする。
      なぜなら、なんか無理やり自前の仕組みで動くようにするより
      公式に提供されてる仕組みに乗っかる方が後々楽そうだからだ。

      ember-rails で動かしていた時に自前で解決していたのは
      ember-rails だと addon がサポートされてないからというだけの理由だしね。

      Addon 化の手順は大体以下の感じ

      1. ember-cli で Addon を generate
      2. 共通ライブラリのコンポーネントを Addon に移植
         - もし共通ライブラリに mixin とかも作っていたら同様に移植すること
      3. Addon をアプリ側で使えるように変更

      なお今回の手順では App と同様に Addon のテストを書く、みたいな丁寧な暮らしはしていない。
      元々書いてないんだし、そこまで頑張る必要もないという判断。

      あとやってることは [[https://cli.emberjs.com/release/writing-addons/intro-tutorial/][Addon 作成のチュートリアル]] に書いていることをベースにしている

****** ember-cli で Addon を generate
       https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/4d6713abfbed3217d65f7382e1f46d341c11d6aa
       でやっていることである

       #+begin_example
       $ cd ember && ember addon my-components --skip-git --yarn
       #+end_example

       というように適当な名前の Addon を作ってるだけ。

****** 共通ライブラリのコンポーネントを Addon に移植
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/cde30b30727d6eb9507b835d009d85759ddff5ee
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/4ad2f8a59ccc846a63e6ff31c8f8b53df81d8e42
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/30439f21f0659044bb4d2ea80ce68a2f8e0011b7

       あたりでやってる作業。

       実際の作業では1つ目を移植してみた段階で、
       動作確認のためにアプリ側で Addon が使えるように設定していたりする。

       ちなみに ember の addon は
       app/components のファイルから addon/components のファイルを import してやるみたいなお作法がある。

****** Addon をアプリ側で使えるように変更
       まずは上の手順で作った my-components という addon を
       App 側で読み込めるように package.json の dependencies に以下を書き加える

       #+begin_src json
       "my-components": "link:../my-components"
       #+end_src

       ember-cli の公式ドキュメントだと
       「yarn link を使う」というように書いているが
       それだとうまくいかないみたいな Issue が何個か立っているので
       ドキュメント通りのやりかたは諦めて、それらの Issue の中に書かれている方法を選択した。

       npm link だとうまくいきそうな雰囲気もあるので
       yarn を使わず npm link にしておけばいい可能性はある。未検証。

       まあそれらは置いといて、とにかく Addon が使える状態になったら
       各コンポーネントでコメントアウトとかで読めなくしていた
       共通ライブラリの呼び出しを元に戻したり記述を直したりして、
       元のように動くようにしましょう。

***** ember-bootstrap の導入と bootstrap を使った機能を移植
      ここまでやって、麦汁さんは「わーい動いた〜」と思っていたけど
      ボタンとかをクリックしてみると、Bootstrap 関係のやつが動かない。

      そう。元の記述のままだと Bootstrap 関係のやつはメソッド呼び出しでエラーになって動かないのです。
      というわけでそれらも動くようにしないといけない。

      というところで、どうやるのが手っ取り早いかというと
      [[https://github.com/kaliber5/ember-bootstrap][ember-bootstrap]] という Addon が転がっているので
      それをインストールして使うように変更するのが多分手っ取り早い。

****** ember-boostrap のインストール・初期設定
       最新版は ember-cli-rails@2.18.2 をサポートしていないので3系を使う必要がある。

       #+begin_example
       $ cd ember/todo-app && ember install ember-bootstrap@3.1.4
       #+end_example

       その上で、元々使っている Bootstrap のバージョンに合わせて
       ember-bootstrap でも3系が使われるように設定する。

       #+begin_example
       $ cd ember/todo-app && ember generate ember-bootstrap --bootstrap-version=3
       #+end_example

****** Bootstrap を使ってる機能の移植
       https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/22a3bff502ce993c2f2288623b061a4f38652a29
       でやっていることである。

       基本的には、自前で bootstrap 用に DOM を組み立てていたところを
       ember-bootstrap の Modal コンポーネント用に書き換えて、
       開いたりするための挙動を修正するだけである。

       ember-boostrap の公式ドキュメントでは Handlebars の書き方が
       ~<BsModal>~ みたいになっていて
       3.4 以降でサポートされた Angle Bracket 方式の表記になっているが、
       ~<>~ は ~{{}}~ に置き換えて
       PascalCase を snake-cake にしたりするぐらいで動くので、
       落ち着いて移植しよう。

***** 既存の system spec が新しい PATH で動くことを確認
      ここまでやると、全機能を手動で確認できる状態になってるので
      既存の system spec がアクセスするポイントを
      新しく作ったアプリの方に変更しテストが通ることを確認すると、
      ちゃんと移植できたんだなって安心できる

      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/0c59057ec458edb7cda0febd15585dfc0a916bc1

**** 元の PATH で動くようにする
***** 元の PATH への再移植
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/334ce5052564a1499de03fb5a6630af3a339af21
      でやっていること。

      1. EmberCliTodoItemsController と TodoItemsController に移植
      2. app/views/ember_cli_todo_items/index.html.haml を app/views/todo_items/index.html.haml に移植
         - rootElement に使う ID も ~todo-app~ に変更
         - ~%base~ の href 属性も ~/todo_items/~ に変更
      3. resources :ember_cli_todo_items を削除
         - 同時に controller, view も消す
      4. mount_ember_app で ~to~ と ~controller~ の指定を変更
         - ~to~ を ~/todo_items~ に変更
         - ~controller~ を ~todo_items~ に変更
      5. Ember.js 側で rootElement を ~#todo-app~ にする

***** テストの PATH を戻す
      これは
      [[*既存の system spec が新しい PATH で動くことを確認][既存の system spec が新しい PATH で動くことを確認]] でやったことを revert して
      テストが通ることを確認したら OK
**** ember-rails 関連の削除
***** ember-rails 用のコードの削除
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/138ac7b8a76ec0f299edb2d626c9252927647229
      でやってるように
      app/assets/javascripts の下にある
      ember-rails 関連のコードを全部消すだけ。

***** ember-rails 用の設定を削除
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/9e036017b7ebee1a84b6f6847d5079a61ca5177c
      でやってるように

      - ~config/application.rb~
      - ~config/initializers/assets.rb~

      の中に ember-rails のために書いた設定を丸っと消しましょう。もう不要なので。

***** ember-rails 及びその関連 Gem と決別
      設定も消せたら ember-rails, ember-source も要らないので
      さっくり Gemfile から消して bundle install し直しましょう。イエイ。

**** GitHub Actions の修正
     あとはやり残しとしては
     CI でもちゃんとテストが通るようにすること。

     このプロジェクトでは GitHub Actions を使ってるので
     そのワークフローを修正する

***** 最新 LTS の Node.js を使うようにする
      Dockerfile のところでもやりましたね。同じようなことをしましょう。
      とは言っても setup-node という action が公式に提供されているし
      [[https://docs.github.com/ja/actions/guides/building-and-testing-nodejs][公式ドキュメント]] もあるので、それに従って設定するだけで使えるようになる。

      #+begin_src yaml
      - name: Use Node.js
        uses: actions/setup-node@v1
        with:
          node-version: 14.x
      #+end_src

***** ember-cli をインストール

      これも似たようなことを Dockerfile でやってるので同じ感じに。

      #+begin_src yaml
      - name: install ember-cli
        run: yarn global add ember-cli
      #+end_src

***** Ember Addon 及び Ember App で yarn install

      こちらも依存を解決してやる必要があるので。

      #+begin_src yaml
      - name: Setup Ember.js Addon
        run: |
          cd ember/my-components
          yarn
      - name: Setup Ember.js App
        run: |
          cd ember/todo-app
          yarn
      #+end_src

      ここまでやると
      GitHub Actions でもテストが通るし
      普通に使えるようになる。やったね。

**** 最後に

     以上の手順で ember-rails から ember-cli-rails への置き換えができます。

     現実世界のアプリケーションはこのケースよりもっと複雑でしょうけども、
     やってやれないことはないはず。

     それに ember-cli が使えるようにしておかないと
     3系に移行ができないし、つまり、サポート切れのフレームワークを使い続けることになるので
     もしまだ ember-rails のアプリが残っていたら頑張ってやっていきましょ。
     別フレームワークに置き換えるよりは労力はかからないはずですし。

*** DONE Ember.js の共通コンポーネントの NPM への分離      :@Rails:@Ember_js:
    CLOSED: [2021-03-24 水 13:04]
    :PROPERTIES:
    :EXPORT_FILE_NAME: my-ember-libs-to-npm
    :END:

    相変わらず Rails における Ember.js 関連で遊んでいます。

    今回の記事で書くのは
    「Ember.js Addon を別リポジトリに分離して NPM パッケージにして利用する」
    なんだけど、
    後追いで出す「分離したリポジトリを Gem としても使えるようにし ember-rails 環境で動かす」
    という感じに記事の前振りです。

    本当は1つの記事にしたかったけど記述量が増えたから分割……。

**** 目的

     なんでこんなことをしているかというと
     「単一ソースで ember-cli にも ember-rails にも対応したい」
     「じゃあ NPM と Gem で公開してインスコしたらいいんじゃね」
     という考えから。

     というのも、
     この一連の記事は ember-rails から ember-cli-rails に
     徐々に移行していく手段を確立することが目的なので、
     1つの Rails の中に複数の Ember.js アプリがあって
     ember-rails と ember-cli-rails が混在している状況も有り得るかなあと。

     そういう時に、
     共通コンポーネントは単一ソースで使いたいよね〜と思って
     両対応ができるようにしてみている。

     まあ今回は ember-cli-rails だけの対応なんだけども。

**** 実践

     ember-cli-rails に移行した時に
     元々 ~RAILS_ROOT/app/assets/javascripts/ember-libs~ というところに
     共通コンポーネントとして置いていたファイル群を
     ~RAILS_ROOT/ember/my-components~ というところに
     Ember.js のアドオンという形で設置していました。

     正直そのままの方が、同一リポジトリなので改修とかしやすいんだけど
     「他のプロジェクトでも使いたい」
     といった時には分離も必要になるかなと。
     まあ今回の目的は別のところにあるけども。

***** 従来の実装を ember-components に移植

      https://github.com/mugijiru/ember-components/commit/847981e9732385d08db4f5f703813196622b80d2

      でやっていること。

      基本的には、元々のソースを addons 以下に置いているだけ。
      なんとなく、コンポーネントの prefix を my- から mg- に変えてるけど。

      あとは ember-cli-htmlbars を dependencies にも移動する必要あり。

      https://github.com/mugijiru/ember-components/commit/922d1f7ed5f6b3372b1d1551792f4e9739f5b1e3

      他にも [[https://github.com/mugijiru/ember-components/commit/30b3257227dab623c86dedfab032b85f32414e42][Docker で動かせるようにしたり]]
      [[https://github.com/mugijiru/ember-components/commit/34e81e2905e32dd2878b95fb9d5c7eb3b3a0b463][GitHub Actions でテストできるようにしたり]]
      ちょっと細かい修正をしたりしている。

      ここまでの差分は
      https://github.com/mugijiru/ember-components/compare/bbaf38aa0f6c99ebbc7e0cb7ee5ac2c201706bc6...34e81e2905e32dd2878b95fb9d5c7eb3b3a0b463
      で確認可能。

***** GitHub Packages の NPM Package の公開

      まず [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#publishing-a-package][パッケージを公開する]] に従って以下の変更をしている。

      パッケージ名を ~@mugijiru/ember-components~ にしたり、

      #+begin_src json
        "name": "@mugijiru/ember-components",
      #+end_src

      publishConfig の registry に GitHub Packages の URL を入れることでそこで公開できるようにしている。

      #+begin_src json
        "publishConfig": {
          "access": "restricted",
          "registry": "https://npm.pkg.github.com"
        },
      #+end_src

      access は GitHub 側の記載は何もないが
      https://tech.plaid.co.jp/npm-private-registry-to-github-packages-registry/
      を参考にして restricted にすることで、許可された人だけが使えるようにしている。

      今は公開リポジトリにしているから public でもいい気もするけど、
      実装当時はより業務でやりそうな雰囲気にしたかったので、
      非公開リポジトリかつ限定的な公開で進めていたので、このようになっている。

      さらに、今後 GitHub Packages に複数パッケージ公開するかもしれないので
      [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#publishing-multiple-packages-to-the-same-repository][同じリポジトリへの複数パッケージの公開]] に従って registory を指定したりしている

      #+begin_src json
        "repository": "git://github.com/mugijiru/ember-components.git",
      #+end_src

      その上で
      https://github.com/mugijiru/ember-components/blob/main/.github/workflows/release.yml
      のようなワークフローを用意すると
      Tag を打って push して
      GitHub 上でそのタグを使って Release を作成すると
      NPM Package として公開されるようになっている。

      上にも出した https://tech.plaid.co.jp/npm-private-registry-to-github-packages-registry/ を真似すると
      もっとスマートな感じになりそうだけど、一旦これでいいやってなってる。

***** 公開したパッケージを利用する

      https://github.com/mugijiru/ember-rails-todo-app/pull/48 の PR でやったこと。

      元々は ~RAILS_ROOT/ember/my-components~ に置いていたやつを NPM Package にしているので
      my-components 関連のやつをさっくり消してあげている。

      具体的には ~ember/my-components~ は全部消して
      package.json の devDependencies に入れていた
      ~"my-components": "link:../my-components"~ を削除している。

      今思ったけどこれ devDependencies だと多分 production 環境だと動かなかったな。
      まあ 2.18 なので公開する気がゼロだったからすっかり気付かなかったんだけど。

      まあそれは置いといて
      公開したパッケージを入れるため dependencies に以下のように記述する。

      #+begin_src json
        "dependencies": {
          "@mugijiru/ember-components": "^0.0.1"
        },
      #+end_src

      あとはプライベートなパッケージを入れられるように
      ~RAILS_ROOT/ember/todo-app/.npmrc~ に以下のような設定を入れている。

      #+begin_example
      @mugijiru:registry=https://npm.pkg.github.com
      #+end_example

      この設定は [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#installing-a-package][パッケージをインストールする]] の通りだとなんかうまく動かなかったので
      [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#installing-packages-from-other-organizations][他のOrganizationからのパッケージのインストール]] のやり方を採用している。
      あとでまた検証した方がいいかもなあ。。。

      それと [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages][GitHub Packages への認証を行う]] に従って

      #+begin_example
      //npm.pkg.github.com/:_authToken=${NPM_TOKEN}
      #+end_example

      としている。
      NPM_TOKEN には GitHub のパーソナルアクセストークンが入るので環境変数にしている。

      なので GitHub Actions で CI を回す際のパッケージのインストール時に

      #+begin_src yaml
      env:
        NPM_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
      #+end_src

      みたいに環境変数に PAT を入れてあげる必要あり。

      他には、これまた公開したパッケージを使う上で本質的ではないんだけど、
      移植した際に ~my-button~ から ~mg-button~ みたいに全部
      ~my-~ prefix だったのを ~mg-~ prefix にしているので
      利用箇所でそれらの修正の必要あり。
      命名を適当にやってたのでここでそれが仇になってる。つらい。

      以上で GitHub Packages に NPM として公開した Ember.js の Addon を
      ember-cli-rails で使えるようになりますよっと。
      正直 NPM とかに慣れてる人ならさっくりできそうな内容。。。

      まあ Ember.js の Addon も実際は NPM Package なので
      普通に NPM Package として公開するだけで使えたりするってだけですね。
      .ember-cli-build.js を活用したらまたちょっと話は違うはずだけど
      今回のはそこまでのやつじゃないし……。

*** DONE 自作の Ember.js Addon を ember-rails 用に無理やり Gem 化した :@Rails:@Ember_js:
    CLOSED: [2021-03-26 金 01:49]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-components-addon-as-gem
    :END:

    [[*Ember.js の共通コンポーネントの NPM への分離][前回の記事]] で Ember.js の共通コンポーネントを詰めた Addon を
    NPM package にしたわけですが、
    今度はそいつを割と無理やり Gem 化して
    ember-rails でも使えるようにしたよ、というお話です。

**** 目的
     Ember.js の Addon として切り出した共通コンポーネントを
     同一ソースで ember-rails でも使いたいな〜、使えるようにしたいな〜、という目的。

     ほら。
     ember-rails で1つの Rails アプリケーションの上に
     複数の Ember.js アプリを動かしていて
     一部ずつ ember-cli-rails 移行を進めていたら
     どうしても混ざる時期あるじゃないですか。

     そういう時に共通コンポーネントは同一ソースで両方で動かせると多分便利じゃないですか。

**** ember-components の Gem 化

     Gem にして ember-rails でも使えるようにするために色々やりました。
     こんなにやらないといけないのかってぐらいやった気がします。。。

***** Component の書き方を古い方式に戻した

      ember-rails だとどうも

      #+begin_src js
      import Component from '@ember/component'

      export default Component.extend({})
      #+end_src

      という書き方だと読み込んでくれないようなので
      全部以下のように書き換えている。

      #+begin_src js
      import Ember from 'ember

      export default Ember.Component.extend({})
      #+end_src

      で、この変更を加えると eslint に怒られるので
      新しい記述を要求する eslint のルールをオフにしてあげる必要がある。悲しい。

      #+begin_src js
        rules: {
          'ember/new-module-imports': 'off'
        },
      #+end_src

***** components を ember-rails で読み込めるようにする

      ember-libs というフォルダに共通コンポーネントとして分割した時も同じようなことをしたんだけど
      ember-rails に components を読み込ませるためのコードを
      このリポジトリに用意してある。

      [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/lib/ember/components/templates/ember-components.js][lib/ember/components/templates/ember-components.js]]

      やってることは、
      requirejs で読み込まれてるファイルを調べて component を見つけ次第
      ~application.register~ するだけのコードである。
      このコードは後で利用側から実行されるようにする。

***** addon 以下のファイルを vendor/assets 以下にコピー、変更する Raketask 作成

      ここでやってることは

      - 上で用意した ember-rails に読み込ませるためのコードをコピー。
      - Rails が読んでくれるところにファイルを置きたいのでaddon 以下のファイルを vendor/assets/javascripts 以下にコピー
      - ember-rails で module として読み込んでほしいので拡張子を ~.module.es6~ に変更
      - ~import layout~ などの Addon 用記述があるとエラーになるのでそれらの記述を強制排除

      となっている。

      後者2つは実装都合上、まとめてやっている

****** ファイルのコピー

       addon 以下に入っていても Rails 的には通常読み込めないので
       ~vendor/assets/javascripts~ 以下にファイルをコピーしてあげている。
       あと上の手順で作った ember-rails に読み込ませるためのコードもコピーしている。

       https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/Rakefile#L14-L18
       #+begin_src ruby
         path = 'vendor/assets/javascripts/ember-components'
         FileUtils.mkdir_p(path)
         FileUtils.cp('lib/ember/components/templates/ember-components.js', "#{path}.module.es6")
         FileUtils.cp_r('addon/templates', path)
         FileUtils.cp_r('addon/components', path)
       #+end_src

       多分 ~app/assets/javascripts~ 以下でもいいんだろう。
       というかそっちの方が良さそうな気もするけど、
       ~app~ は Ember.js 側で使っているので、それと混ざると嫌だなということで避けている。

****** addon 用の記述削除 & 拡張子の変更

       component に関しては addon での component 作成のお作法に従い
       ~import layout~ とか書いているけど
       ember-rails ではその記述はむしろ不要になるというか
       hbs を import できない問題が発生するので
       それらの行を強制的に削除する処理を入れている。

       また、それと同時に ember-rails で ES6 module として読み込めるように
       拡張子を ~.module.es6~ にしている。

       方法としては、ファイルを ~.js~ から ~.module.es6~ にコピーしつつ不要な行を消して
       それが済んだら ~.js~ ファイルを消すという手法を取ってる。
       結構、無理やり感がある。

       https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/Rakefile#L19-L33
       #+begin_src ruby
       Dir["#{path}/components/*.js"].each do |file_path|
         File.open(file_path, 'r')
         basename = File.basename(file_path, '.js')
         File.open("#{path}/components/#{basename}.module.es6", 'w') do |write_f|
           File.open(file_path, 'r') do |read_f|
             read_f.each do |line|
               next if line =~ /^\s*import layout/
               next if line =~ /^\s*layout,/

               write_f.puts line
             end
           end
         end
       end
       FileUtils.rm(Dir.glob("#{path}/components/*.js"))
       #+end_src

***** Rails Engine 化

      Rails Engine として組み込んで使えるように
      ~lib~ 以下にちょろちょろコードを書いている。

      - [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/lib/ember/components.rb][lib/ember/components.rb]]
      - [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/lib/ember/components/version.rb][lib/ember/components/version.rb]]
      - [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/lib/ember/components/engine.rb][lib/ember/components/engine.rb]]

      ほとんど「Rails Engine のお作法」ってだけのコードだけど
      上に書いたファイルをコピーしたりする時の
      PATH を取得するための便利メソッドとして以下を生やしている。

      #+begin_src ruby
      def self.root
        Pathname(__FILE__).join('../../..')
      end
      #+end_src

***** gemspec 修正

      Gem として GitHub Packages に登録するので当然 .gemspec ファイルを用意している。
      [[https://github.com/mugijiru/ember-components/blob/bfbcda1c31a8bdf0efcb6aeaa0fb15efaccc5a7a/ember-components.gemspec][ember-components.gemspec]]

      一応 GitHub Packages に出すためのお作法として

      #+begin_src ruby
      spec.metadata["allowed_push_host"] = "https://rubygems.pkg.github.com"
      #+end_src

      というように push できるホストをしていしたり

      #+begin_src ruby
      spec.metadata["github_repo"] = "ssh://github.com/mugijiru/ember-components.git"
      spec.metadata["git_repo"] = "ssh://github.com/mugijiru/ember-components.git"
      #+end_src

      というようにリポジトリを指定していたりする。

      [[https://docs.github.com/ja/packages/guides/configuring-rubygems-for-use-with-github-packages#publishing-multiple-packages-to-the-same-repository][同じリポジトリへの複数パッケージ公開]] の記述を読む限り
      github_repo だけ指定あれば良さそうな気もするが
      git_repo があっても特に害もないだろうということでとりあえず入れている。

      あとは gem に含めたいファイルとして

      #+begin_src ruby
      spec.files = Dir[
        'lib/**/*',
        'vendor/**/*',
        'README.md',
        'LICENSE.md'
      ]
      #+end_src

      としている。
      lib 以下は Rails Engine として組込むために必要だし
      vendor 以下には ember-rails で読み込める形に変換したファイルがあるので
      gem に含める必要がある。

***** GitHub Actions での Gem 登録

      [[*Ember.js の共通コンポーネントの NPM への分離][NPM Package にした時]] と同様に
      Tag を打ってそれからリリースを作ったら Gem が登録されるように
      GitHub Actions を設定している。

****** Gem の build

       publish する前に以下のようにして Rake Task を実行している。

       #+begin_src yaml
       - name: Build gem
         run: |
           bundle exec rake clean_assets generate_assets build
       #+end_src

       clean_assets は説明してなかったけど ~vendor/assets/javascripts~ 以下を
       真っ新にするだけの処理。

       で、generate_assets が
       [[*addon 以下のファイルを vendor/assets 以下にコピー、変更する Raketask 作成][addon 以下のファイルを vendor/assets 以下にコピー、変更する Raketask 作成]]
       のあたりで書いた、コピーしたり中身を弄ったりしている処理。

       最後の build は Gem を作ったことある人ならわかるはずだけど
       gemspec の記述に従って gem ファイルを生成する処理。
       これを実行する pkg 以下に ~ember-components-x.y.z.gem~ みたいなファイルが作られる。

****** Publish

       上の手順で gem はできたので、あとはそれを GitHub Packages に登録するだけである。
       そのための step が以下。

       #+begin_src yaml
       - name: Publish to RubyGems
         run: |
           mkdir -p $HOME/.gem
           touch $HOME/.gem/credentials
           chmod 0600 $HOME/.gem/credentials
           printf -- "---\n:github: Bearer ${{ secrets.GITHUB_TOKEN }}\n" > $HOME/.gem/credentials
           gem push --key github --host https://rubygems.pkg.github.com/mugijiru pkg/*.gem
       #+end_src

       まずは [[https://docs.github.com/en/packages/guides/configuring-rubygems-for-use-with-github-packages#authenticating-with-a-personal-access-token][Authenticating with a personal access token]] の手順に従って
       ~~.gem/credentials~ に
       ~github: Bearer ${{ secrets.GITHUB_TOKEN }}~
       の記述が入るようにしている。

       それをすると GitHub Packages の認証が通るようになるので

       #+begin_example
       gem push --key github --host https://rubygems.pkg.github.com/mugijiru pkg/*.gem
       #+end_example

       を実行することで Gem として登録ができる。


**** ember-rails アプリケーションから Gem 化した Addon の読み込んで利用する

     https://github.com/mugijiru/ember-rails-todo-app/pull/51
     の PR でやっていることである。

     PR では途中色々ごちゃごちゃやってるけど、
     ここでは最終結果に基いて説明をする。

***** Gem を bundle install できるようにする

      まずは bundle install で組込めないと何も始まらないので
      Gemfile に以下を追加する。

      #+begin_src ruby
      source "https://rubygems.pkg.github.com/mugijiru" do
        gem "ember-components"
      end
      #+end_src

      さらに手元のマシンで以下のコマンドを実行して、
      bundle install の際に GitHub Packages への認証が通るようにする。

      #+begin_example
      $ bundle config --local https://rubygems.pkg.github.com/mugijiru mugijiru:XXXXXX
      #+end_example

      ~XXXXXX~ には Gem をインストールできるパーソナルアクセストークンを設定すること。

      こうしておけば

      #+begin_example
      $ bundle install
      #+end_example

      で無事に自作 Gem の ember-components がインストールできる

      Docker を使ってる場合は以下のようにして
      Docker 内で bundle config が設定された状態で ~bundle~ を実行する必要あり

      #+begin_example
      $ docker-compose run rails bash -c "bundle config --local https://rubygems.pkg.github.com/mugijiru mugijiru:XXXXXX && bundle"
      #+end_example

***** templates_root への登録

      ember-rails は Rails 側で templates_root を設定してあげる必要がある。

      というわけで config/application.rb で
      ~ember-components/templates~ が templates_root として認識されるように記述する。

      #+begin_src ruby
      config.handlebars.templates_root = %w[todo-app/templates ember-components/templates]
      #+end_src

***** sprockets で ember-rails を読み込む

      Gem として読み込めるようになったので
      Sprockets で以下のようにして require してあげると
      Gem の ~vendor/assets/javascrips/ember-components~ に生成したファイルが
      ember-rails アプリ側で認識されるようになる。

      #+begin_src js
      //= require ember-components
      #+end_src

***** Ember.js に component を register する

      require するだけだと Ember.js ではまだ使えないので
      Gem 内の Componentを登録する必要がある。

      が、基本的な処理は
      [[*components を ember-rails で読み込めるようにする][components を ember-rails で読み込めるようにする]] のところで書いたので、
      ember-rails 側では initializers に以下のような内容のファイルを置けば良い。

      #+begin_src js
      import EmberComponents from 'ember-components';

      export function initialize(application) {
        EmberComponents.registerAll(application);
      }

      export default {
        name: 'register-ember-components',
        initialize: initialize
      };
      #+end_src

      実質的にやってることは
      Gem 内のスクリプトに定義している registerAll メソッドを叩いているだけ。

      本当はこういう処理すらなしに使えるのがベストだけど
      そこまでうまくやる方法は見つけられず……。

***** 利用箇所の修正

      これは component の prefix を ~my-~ から ~mg-~ に変えたから発生している作業なので
      本質的には不要な作業。

      とにかく ~my-button~ のような古い prefix になっているところを
      ~mg-button~ というように新しい prefix に置き換えるだけの簡単なお仕事。

***** GitHub Actions の修正
****** setup-ruby で ember-components を bundle install できるようにする
       GitHub Actions の CI でも bundle install をしているので
       そこでもインストールが正常に行われるようにしてあげないといけない。

       #+begin_src yaml
       - uses: ruby/setup-ruby@v1
         env:
           BUNDLE_HTTPS://RUBYGEMS__PKG__GITHUB__COM/MUGIJIRU/: "mugijiru:${{ secrets.NPM_AUTH_TOKEN }}"
         with:
           bundler-cache: true
       #+end_src

       のように ~bundle config~ で設定したのと同じようなものを
       env で設定してあげるとインストールができる。

       NPM_AUTH_TOKEN なのは、NPM Package にした時に使ったやつが
       丁度いいスコープを持っていたから流用しちゃった。てへぺろっ。

****** assets:precompile

       Gem の作りが悪いのか、
       rspec を流す前に

       #+begin_example
       $ bin/rails assets:precompile
       #+end_example

       を流さないと component の template がテスト環境でで読まれない。
       というわけで GitHub Actions で rspec を実行する前にその手順を挟んでいる。

       https://github.com/mugijiru/ember-rails-todo-app/blob/4acafe0fd741fd24dc4e6bc69d98df5cbb68ef0e/.github/workflows/ci.yml#L32

       ちなみにこれは手元で rspec を流す時も同じなので
       ちゃんと手元のマシンでも precompile してあげましょう。だるい。

***** 旧共通ライブラリの削除

      ~app/assets/javascripts/ember-libs~ に配置していたファイルは不要なので
      さっくりと

      #+begin_example
      $ rm -rf app/assets/javascripts/ember-libs
      #+end_example

      して

      #+begin_src js
      //= require_tree ../ember-libs
      #+end_src

      としている行が残っていればそれも削除すること。

      ~config/application.rb~ で templates_root として
      ~ember-libs/templates~ を追加している場合はそれも削除しておくこと。
      まあこれは残っててもエラーにならないけどね。

**** 旧スタイルの ember-rails アプリケーションでも Gem 化 Addon を利用する

     https://github.com/mugijiru/ember-rails-todo-app/pull/52
     でやっていること。

     まあ正直 module 化しているやつとほとんどやってることは変わらない。

     変わってる点は、registerAll の呼び出し方ぐらいで
     TodoApp という Ember.js アプリケーションが入ってる変数が
     グローバル空間に収まっているので
     application.js.es6 の方で直接以下のように書いている。

     #+begin_src js
     import EmberComponents from 'ember-components';
     EmberComponents.registerAll(TodoApp);
     #+end_src

     他は module 化しているパターンと一緒なので割愛。

**** 最後に

     という手順で
     NPM Package にした Ember.js Addon を
     若干無理やりながらも ember-rails で使えるようにすることができました。

     まあ mixin とかは試してないのと
     Component をサブフォルダに分割していたりすると
     もうちょっと手をかけないといけなさそうだけど
     とりあえず動いたから許して。

     正直、無理やり感が結構あるので
     普通のプロダクトに適用するのは厳しい感じある。

*** DONE ember-cli-rails の Ember.js を 2.18 から 3.4 にアップデート :@Rails:@Ember_js:
    CLOSED: [2021-04-04 日 15:38]
    :PROPERTIES:
    :EXPORT_FILE_NAME: update-emberjs-2.18to3.4
    :END:

    前回までで ember-rails と ember-cli-rails の共存周りを一通り済ませて
    そのあたりは大体満足したので
    次の段階である Ember.js アプリの最新化を進めていくぞい。

    で、どう進めていくかというと
    2.18 は最新版からはかなり遠いので
    3系で LTS であったバージョンを順番に適用していく方針。

    それ以外のところだと基本的に
    https://cli.emberjs.com/release/basic-use/upgrading/
    に従って対応をしていく。

    というのを実践した PR がこちらになります。
    https://github.com/mugijiru/ember-rails-todo-app/pull/61

**** ember-cli の更新

     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/0b71b86330ab46ec8df46cdcb308daf3ed766681
     のコミットでやっていることですね。

     まずは Dockerfile で入れている ember-cli を 2.18 から 3.4 にする。
     3.4 系の最終バージョンは 3.4.4 なのでそれを指定している。

     #+begin_src Dockerfile
     # install ember-cli
     RUN yarn global add ember-cli@3.4.4
     #+end_src

**** ember-cli-update の導入

     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/ded293ff2f686081549d0019e500facb5c2aaa3d
     のコミットでやってることですね。

     Ember.js をアップデートする際には ember-cli-update を使うのが王道っぽいので
     それも Dockerfile でインストールしておく。

     #+begin_src Dockerfile
     # install ember-cli-update
     RUN yarn global add ember-cli-update
     #+end_src

     また、こいつは今後も 3 系で更新していくにあたり必要と思われるので
     ember-cli よりも先に入れておくことにする。

**** bundle && yarn

     Dockerfile を更新したので bundle install と yarn install を実行しておく。

     #+begin_example
     $ docker-compose run rails bundle
     #+end_example

     #+begin_example
     $ docker-compose run rails bash -c "export NPM_TOKEN=XXXXXXXXXX && cd ember/todo-app && yarn"
     #+end_example

     NPM_TOKEN という環境変数を使ってるのは
     ember-components という自作の NPM パッケージを使うために
     [[https://github.com/mugijiru/ember-rails-todo-app/blob/7916518d766145fc0b8d9978efbfb08d6937f813/ember/todo-app/.npmrc][.npmrc]] で GitHub Packages を使うような設定をしているため。

**** ember-cli-update bootstrap の実行

     https://github.com/ember-cli/ember-cli-update/wiki/Getting-Started に書かれているように

     #+begin_example
     $ docker-compose run rails bash -c "export NPM_TOKEN=XXXXXXXXXX && cd ember/todo-app && ember-cli-update bootstrap"
     #+end_example

     を実行することで config/ember-cli-update.json が生成される。
     ember-cli-update は実行時にこのファイルを見て色々処理をする様子。

     雰囲気的には Addon もこれを使って更新できそうだが、ちょっとまだ調べてない。

     とりあえずこの実行結果をコミットしたのが以下。
     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/35177e82eac6a9d490c49348ec8e50b31828bb10

**** ember-cli-update で 3.4.4 に更新

     いよいよアップデート作業である。
     とりあえず 3.4.4 に上げたいので以下のコマンドを叩く。

     #+begin_example
     % docker-compose run rails bash -c "export NPM_TOKEN=XXXXXXXXXX && cd ember/todo-app && ember-cli-update --to 3.4.4"
     #+end_example

     すると

     #+begin_example
     ? Blueprint updates have been found. Which one would you like to update?
     > app, current: 2.18.2, latest: 3.25.3
     #+end_example

     というように質問される。
     恐らく Addon も ember-cli-update で管理できるようにしていたら他の選択肢も出て来るんだろうが、
     とりあえず今回は app を更新したいだけなので何も考えずに Enter を叩く。

     すると、以下のように何やらファイルが生成されたようなログが出て来る。
     しかも2回も生成されてる雰囲気。

     #+begin_example
     installing app
       create .editorconfig
       create .ember-cli
       create .eslintrc.js
       create .travis.yml
       create .watchmanconfig
       create README.md
       create app/app.js
       create app/components/.gitkeep
       create app/controllers/.gitkeep
       create app/helpers/.gitkeep
       create app/index.html
       create app/models/.gitkeep
       create app/resolver.js
       create app/router.js
       create app/routes/.gitkeep
       create app/styles/app.css
       create app/templates/application.hbs
       create app/templates/components/.gitkeep
       create config/environment.js
       create config/targets.js
       create ember-cli-build.js
       create .gitignore
       create package.json
       create public/robots.txt
       create testem.js
       create tests/helpers/destroy-app.js
       create tests/helpers/module-for-acceptance.js
       create tests/helpers/start-app.js
       create tests/index.html
       create tests/integration/.gitkeep
       create tests/test-helper.js
       create tests/unit/.gitkeep
       create vendor/.gitkeep
     WARNING:
     WARNING: The 'package.json' file for the addon at /usr/local/share/.config/yarn/global/node_modules/ember-cli/lib/tasks/server/middleware/tests-server
     WARNING:   specifies a missing dependency 'exists-sync'
     WARNING: Node v14.16.0 is not tested against Ember CLI on your platform. We recommend that you use the most-recent "Active LTS" version of Node.js. See https://git.io/v7S5n for details.
     installing app
       create .editorconfig
       create .ember-cli
       create .eslintignore
       create .eslintrc.js
       create .template-lintrc.js
       create .travis.yml
       create .watchmanconfig
       create README.md
       create app/app.js
       create app/components/.gitkeep
       create app/controllers/.gitkeep
       create app/helpers/.gitkeep
       create app/index.html
       create app/models/.gitkeep
       create app/resolver.js
       create app/router.js
       create app/routes/.gitkeep
       create app/styles/app.css
       create app/templates/application.hbs
       create app/templates/components/.gitkeep
       create config/environment.js
       create config/optional-features.json
       create config/targets.js
       create ember-cli-build.js
       create .gitignore
       create package.json
       create public/robots.txt
       create testem.js
       create tests/helpers/.gitkeep
       create tests/index.html
       create tests/integration/.gitkeep
       create tests/test-helper.js
       create tests/unit/.gitkeep
       create vendor/.gitkeep
     #+end_example

     で、実行後に Ember アプリのディレクトリで ~git status~ を叩くと以下のような感じ。

     #+begin_example
     Changes to be committed:
       (use "git restore --staged <file>..." to unstage)
             new file:   .eslintignore
             modified:   .eslintrc.js
             modified:   .gitignore
             new file:   .template-lintrc.js
             modified:   README.md
             modified:   config/ember-cli-update.json
             new file:   config/optional-features.json
             modified:   config/targets.js
             modified:   package.json
             modified:   testem.js
             new file:   tests/helpers/.gitkeep
             deleted:    tests/helpers/destroy-app.js
             deleted:    tests/helpers/module-for-acceptance.js
             deleted:    tests/helpers/start-app.js

     Unmerged paths:
       (use "git restore --staged <file>..." to unstage)
       (use "git add/rm <file>..." as appropriate to mark resolution)
             deleted by us:   .travis.yml
     #+end_example

     .travis.yml は「どうせ使わねーだろ」ってことで自分で消してあるので
     改めて ~git rm .travis.yml~ すれば良い。

     それ以外の変更点も、ざっと眺めた感じは、きっといい感じに 3 系に対応してくれてそうなので
     気にせずコミットする。適当である。

     この実行結果のコミットは
     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/c78deca904a43aa5587cf1489cabd90461469c31
     ですね。

**** 古いコードを自動置き換え

     https://cli.emberjs.com/release/basic-use/upgrading/#updatingyourcodeautomatically

     に書かれてるように ~ember-cli-update~ では
     ~--run-codemods~ オプションで実行することで
     古い記述を自動的に新しい書き方に直してくれるという便利機能があるので、それを実行する。
     後で理由を記載するが、ここでもまた NPM_TOKEN が必要になる。

     #+begin_example
     $ docker-compose run rails bash -c "export NPM_TOKEN=XXXXXXXXXX && cd ember/todo-app && ember-cli-update --run-codemods"
     #+end_example

     するとまた

     #+begin_example
     ? Which blueprint would you like to run codemods for?
     > ember-cli
     #+end_example

     というように1つしかない選択肢を出される。
     これもまた Addon を ember-cli-update で更新管理できるようにしていたら選択肢が増えるんだろう、
     という推測をしてそのまま Enter を叩く。

     すると、今度は以下のようにいくつかの選択肢が出て来る。

     #+begin_example
     ? These codemods apply to your project. Select which ones to run. (Press <space> to select, <a> to toggle all, <i> to invert selection)
     ❯◯ ember-modules-codemod
      ◯ ember-qunit-codemod
      ◯ ember-test-helpers-codemod
      ◯ es5-getter-ember-codemod
      ◯ notify-property-change
      ◯ qunit-dom-codemod
     #+end_example

     それぞれ何をしてくれるかというと、多分大体以下の感じ。

     - [[https://github.com/ember-codemods/ember-modules-codemod][ember-modules-codemod]] :: ~import Ember from 'ember'~ という古い記述を ~import Component from '@ember/component'~ とかに修正するやつ
     - [[https://github.com/ember-codemods/es5-getter-ember-codemod][es5-getter-ember-codemod]] :: ~obj.get('foo')~ みたいな古い記述を ~obj.foo~ みたいな記述方式に変更するやつ
     - [[https://github.com/ember-codemods/ember-test-helpers-codemod][ember-test-helpers-codemod]] :: テスト用の記述を新しい書き方に変更するやつ
     - [[https://github.com/ember-codemods/ember-qunit-codemod][ember-qunit-codemod]] :: ember-qunit の moduleFor とかの書き方を新しい方式に変更するやつ
     - [[https://github.com/ember-codemods/ember-3x-codemods/tree/master/transforms/notify-property-change][notify-property-change]] :: notifyPropertyChange の書き方が変わる。使ったことないからよくわからん。
     - [[https://github.com/simplabs/qunit-dom-codemod][qunit-dom-codemod]] :: DOM 選択の記述を jQuery 依存じゃないようにするっぽい

     例えばここで
     ember-modules-codemod だけ選択して Enter すると
     何かよくわからないが NPM Package を Fetch しにいき、それが終わるとコードの自動補正が実行される。

     #+begin_example
     Running codemod ember-modules-codemod
     Running command 1 of 1
     Skipping path addon which does not exist.
     Skipping path addon-test-support which does not exist.
     Skipping path test-support which does not exist.
     Skipping path lib which does not exist.
     Processing 11 files...
     Spawning 7 workers...
     Sending 2 files to free worker...
     Sending 2 files to free worker...
     Sending 2 files to free worker...
     Sending 2 files to free worker...
     Sending 2 files to free worker...
     Sending 1 files to free worker...
     All done.
     Results:
     0 errors
     6 unmodified
     0 skipped
     5 ok
     Time elapsed: 1.785seconds

     Done! All uses of the Ember global have been updated.
     Finished running command 1 of 1
     Finished running codemod ember-modules-codemod
     #+end_example

     これで何が変更されているかというと
     ~git diff --cached~ の一部を表示するとこんな感じ。

     #+begin_example
     diff --git a/ember/todo-app/app/components/todo-item.js b/ember/todo-app/app/components/todo-item.js
     index bc28c83..a803fc5 100644
     --- a/ember/todo-app/app/components/todo-item.js
     +++ b/ember/todo-app/app/components/todo-item.js
     @@ -1,12 +1,14 @@
     -import Ember from 'ember';
     +import { later } from '@ember/runloop';
     +import { computed } from '@ember/object';
     +import Component from '@ember/component';

     -export default Ember.Component.extend({
     +export default Component.extend({
        tagName: 'li',
        classNames: ['p-todo-item'],
        classNameBindings: ['isCompleted:p-todo-item__completed'],

        item: null,
     -  isCompleted: Ember.computed('item.isCompleted', function () {
     +  isCompleted: computed('item.isCompleted', function () {
          return this.get('item.isCompleted');
        }),
     #+end_example

     ~import Ember from 'ember'~ という記述はもう古いので
     個別に ~import Component from '@ember/component'~ とするような記述に変更されている感じ。

     いい感じにコードを変更してくれることがわかったので、
     同じ調子で ember-qunit-codemods なども適用していく。

     すると ~ember-test-helpers-codemod~ でエラーになったりするけど
     そもそもこのプロジェクトでは Ember.js に対する qunit でのテストをまだ書いてないので
     多分それが原因で単にファイルがないだけとかなので軽く無視する。

     という感じで実際に適用して変更があったのが

     - https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/815ccd8c6d79f6e6bc6171f214f8cd375e1a6537
     - https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/d21b563c6352718c702f4ccd883cd780973d9982

     の2つだけ。
     ま、複雑なことしてないしね。



**** packages の更新

     [[*ember-cli-update で 3.4.4 に更新][ember-cli-update で 3.4.4 に更新]] の方でやっておけば良かったんだけど、
     ここまでの作業で package.json は更新されてるけど
     実際にインストールされてるライブラリの更新はされてなかったorz

     というわけで Ember.js アプリのディレクトリで ~yarn~ を叩いたら
     色々新しくインストールされて
     https://github.com/mugijiru/ember-rails-todo-app/pull/61/commits/196d9f7b389c5e2c8d690cd1e608251c69a377d2
     みたいな感じで yarn.lock も更新されると。

**** テストの実施

     まあ後はちゃんと動くよねということを確認するために
     テストを実行して問題なければ OK ですと。

     このプロジェクトだと system spec を書いているので
     それを実行した上で、念の為手でも動作確認して問題なかった、という感じ。

     もっと複雑なケースだと色々問題あるんだろうな〜。

**** 問題があった場合

     もし問題があったら、エラー内容などを確認しつつ

     - [[https://deprecations.emberjs.com/][Ember Deprecations]]
     - [[https://blog.emberjs.com/tag/releases/][Ember release blog post]]

     と睨めっこしたら良いんだと思う。
     今回問題がなかったから、そのあたりの知見は得られなかったけど……。

**** その他

     実は eslint で怒られてるのはまだ無視しています。
     そこまで修正入れると面倒なのと、差分が大きくなるなと思って。
     それは別の機会に直しておきます。

**** 最後に

     とりあえず3系にするだけならそんなに難しくなさそうな所感を得た。

     eslint で怒られてるの直す必要があるな〜というのと、
     ember-components@0.0.3 がいつから使えなくなるか気になるのと
     ember-bootstrap あたりの Addon を ember-cli-update で管理できるようにしたいなという気持ちは残ったけど。

     ま、そこもおいおい試していく

*** DONE RPA ちょっとだけ調べてみた
    CLOSED: [2021-04-25 日 23:46]
    :PROPERTIES:
    :EXPORT_FILE_NAME: research-rpa
    :END:

    RPA ちょっとだけ調べてみたのでとりあえず Blog 記事にする。
    ちなみにいくつかリンク張るけど、面倒なのでアフィリエイトとかそういうのにはなってない。
    お金は好きだけど面倒が勝った。

**** モチベーション
     身の回りで RPA 導入するって話があって
     それ聞いて色々思うところがあったから調べてしまった。
     そんで折角調べたんだから世の中に出してしまえ、というぐらいの軽い気持ち。

     そんな軽い気持ちなので、まだどれ1つ試してはいない。

     あと、記事中でやたら Excel のことを気にしているけど、
     自動化してデータ取りたいやつの半分ぐらいは Excel だろっていう偏見があるからです。

**** RPA とは
     わざわざ説明要らない気がするけど一応。

     ロボティクス・プロセス・オートメーションとかいうやつで
     ざっくり言うと「機械に任せて自動化しようぜ」ってやつ。
     あと、プログラマではない人も扱えるようにコードは書かないとか、
     昔からある画面自動操作とちょっと違って、仮想環境上で実行されるとかあるっぽい。
     ま、細かいことは知らん。
     動きゃいいんだよ動きゃ。

**** RPA の分類

     ざっくりと

     - スタンドアローン型
     - オンプレミス型
     - クラウド型

     と分かれる。

***** スタンドアローン型

      デスクトップ型とも言われるやつ。
      一台のマシンにインストールしてその中で完結するタイプ。
      感覚的には一番わかりやすいんじゃないかな。
      RDA(ロボティクス・デスクトップ・オートメーション)と呼んで他と区別されることもあるらしい。

      各個人のマシンにインストールして動かすので操作対象の制限が少なく
      個人作業の効率化に向いている。

      インストールして使うタイプなので、大体 OS の制限がある。
      っていうか Windows で使ってくださいって言われる印象がある。

      仕組みが単純だからなのか比較的安価なのが多いっぽい。
      とはいえ、大体初期導入で20万円とか30万円とか取られて
      月々10万円取られる、みたいなのがお約束。

      で、個人の作業の効率化には向いているけど、
      会社全体とか部署全体の効率化のために
      他の人が作ったシナリオを流用したい、みたいなのには向かない。
      だって各個人のマシンに入れるものですし。

      それを回避するために、
      こいつを自社管理サーバ(オンプレでも AWS でも)にインストールして、
      1アカウントを使い回してリモートデスクトップでアクセスして操作する、
      みたいなのはバカげた考えなのでやめた方がいい。

      共通アカウントって時点でセキュアじゃないし、
      誰かのロボットが動いていると自分の処理が動かせないので待ちが発生するし、
      サーバの管理コストも発生するしでコストメリットに対するデメリットがでかいはず。
      導入しようとしている人にそれが理解できるか知らんけど。

***** オンプレミス型

      サーバ型とも言われるやつ。
      オンプレサーバにインストールしてみんなで使うみたいな用途向け。

      オンプレサーバに入れるので

      - 情報が社外に流出しないようにしたい
      - イントラネットのサーバにアクセスしたい
      - 使用状態の監視をしたい

      みたいなことを要求しがちな大企業でも導入しやすそうな気がしている。

      一方で、オンプレサーバに入れるとなるとサーバ管理コストも発生するし、
      多分仕組み上お値段もお高めになるかなって気はしている。

      オンプレミス型とは書いているけど
      別に AWS EC2 上で動かしても問題はないはず。
      イントラネットに閉じる、みたいなのとはズレてくるからメリットが薄れそうだけど。

      正直3分類の中で一番興味ないのでほとんど調べてない。
      つまりできないこととかもよくわからん。

      多分、サーバにはサーバソフトウェアを入れた上で、
      各自のマシンにはクライアントソフトウェアを入れて、それ経由でサーバにアクセスして、
      実際の処理は各自のマシンで実行される仕組みにしているんじゃないかな。
      じゃないと大企業で大事な Excel などの操作もできなさそう(やりにくそう)だし。

***** クラウド型

      みんな大好きクラウド環境で動くタイプ。
      クラウド環境で動くので、使用場所を問わないし管理もしやすいやつ。
      ほっといても運営がどんどん機能追加してくれるしね。多分。

      ブラウザ上で完結している場合は Excel などの操作はできないが、
      それを解決するために別途クライアントをインストールする、というタイプもある。

      ただ、多分クライアントソフトの開発にそれほどリソースが割けないので
      対応ソフトウェアが多くはない、ということもありそう。
      まあ時代はクラウドなので今時 Excel などのローカル環境で動くソフトウェアなんて使いませんよねハハハ。

      オンプレ型と違ってサーバ管理コストは発生しないので
      エンジニアの端くれとしてはオンプレ型よりこっちの方が好み。
      だって情シスでもないのにサーバ管理させられたくないっしょ。通常業務が滞る。

      サービス終了となった時に全部動かなくなってつらいことになりそうなので
      クラウド型を選択する時は人気度にも気をつけた方がいいかもしれない。
      それ以外のタイプでもサポート終了したら色々困りそうだけど、
      即座に動かなくなるわけではないはずなので、まだマシそう。

**** どのタイプを使うべきか

     用途による。

     とだけ書いてもしょうがないので、ちょっと主観で述べると、
     とりあえず基本的にはクラウド型にしとく方が良さそうな気がする。

***** 会社単位・部署単位での導入の場合

      会社全体や部署全体の効率化観点だと、
      どうせ「このシナリオをみんなが使えるようにしたい」みたいになるので
      最初からそういう用途があることを折り込んでおいた方が良さそう。

      となるとオンプレ型かクラウド型になるけど、
      オンプレサーバの管理とかしたくないじゃん? じゃあクラウド型じゃん?

      管理コストとかより情報流出対策とかの方が大事な方は、オンプレ型になる気がする。
      あとはイントラネットへのアクセスが必要だったらクラウド型は厳しいかも。

***** 個人での導入の場合

      個人用途だと
      わざわざオンプレ型にして無駄に管理の手間や利用料金を増やしたい酔狂なやつ以外は
      スタンドアローン型かクラウド型になると思う。

      で、個人だと色々自由なはずなので
      使うソフトウェアは基本的にクラウドアプリケーションに寄せておいたら、
      スタンドアローン型のメリットである、ローカル環境の操作は不要になるかなと。

      また、クラウド型にしておいたら、
      PC を買い替えた時とかもインストールし直しとかデータ移行とかも不要で便利。
      いや、ローカルクライアントも必要なやつだとインストールし直しは発生するけども。

      もしローカル環境の自動化をしたいとか、イントラネットにアクセスしたいとか、
      クラウドサービスの利用は諸々の制限がある場合はスタンドアローン型になるかなって気はする。
      けど、そういうところソフトウェアのインストールにも制限がありそう(偏見)。

**** その他、気にした方がいいポイント
***** 機能面
      各会社がシノギを削ってるのでそれぞれの製品毎に強みがあったりする。

      例えば、AI による判定機能が入ってるとか、
      素人でも簡単にロボットが作れちゃうとか、
      複雑な操作までできることが売りのやつとかもある。

      そのあたりは、各自が自分のスキルレベルとかやりたいことに合わせて検討して欲しい。
      というか、そこまで調べる元気はなかった。
      あと AI がどうのこうのってやつはそもそも信用してなかったりするので、売り文句を見てると苦痛だった。

***** お値段

      大事だよね〜お値段。お高いの厳しいもんね。
      まあ、安くてもやりたいことができないんじゃあ導入する意味はないので
      機能重視で考えた方がいいと思うよ。

      ちなみに大体のやつは月額10万円からで初期費用は別途30万とかの世界なので
      私としては「高い……無理……」ってなるんだけども。
      ギョームソフトウェアってお高いね。

      個人的には、基本サービスは安いけど、
      つい頼みたくなるような便利な追加オプションがあるような料金設定はニクいなって思う。

***** やめやすさ

      導入してみてダメだった時のことを考えると
      やめやすさは考慮に入れておいた方がいいと思うの。

      例えば、シナリオのエクスポート機能があって、それを他の RPA に取り込むことができると嬉しいよね。
      そんなのをサポートしている RPA があるって聞いたことないけど。
      互換性の維持とか厳しそうだしな。

      あとは契約期間だよね。1年更新とかやめてほしい。
      月額プランと年契約プランで後者は割安、とかならいいけど。
      その場合でも解約申請期間がめっちゃ短かいとかわかりにくいとかもやめてほしいよね。

***** 息が長そうか

      せっかく使い続ける選択をしたのに、
      製品サポートそのものが終了してしまったら困るので長く続きそうかってのは大事。

      それをどう判断するかは、ユーザー数が十分いそうか(維持できるだけの収益がありそうか)とか、
      母体が大きいか、とかになるのかなあ。

      個人的にはサービスサイトの表示が微妙なところは、
      そこにコストがかけられない程度に儲かってないんだな、つまり危なそうだな、という気持ちになる。

**** で、具体的にどの製品を使ったらいいのか

     これ、ほんと全然操作したことはなくって、ググって見つかる情報だけで判断しているので
     その前提でよろしくな。

     あと、基本的にケチなので、ほとんど無料プランがあるやつしかリストアップしてない。

***** Coopel

      [[https://coopel.ai/][Coopel]] は DeNA が出しているクラウド型の RPA サービス。
      ローカルクライアントもあって、それを使うとローカルのファイルも扱えたりするやつ。
      少なくともみんな大好きな Excel は扱えるよっ!
      Mac と Windows の両対応なのも嬉しいポイント。

      記事執筆時点だと、1アカウントあたり月額5,400円(税抜)と
      他の RPA サービスに比べるとかなりリーズナブルな感じ。
      最低アカウント数は1アカウントからっぽい雰囲気だし(多分、明示はされてない)

      機能面では、クラウド型がベースなのもあってちょっと弱い気がしている。
      あと、まだ出たばかりのサービスでユーザー数が多くなさそうで、ちゃんと生き残ってくれるか気になる。

      とはいえ国産 RPA だと調べた中では一番好きな感じ。

      他のやつは、クソ高いか「お値段はお問い合わせください」だったり、
      Mac 対応してなかったりするので。

***** UiPath Community Edition

      [[https://www.uipath.com/ja/][UiPath]] は海外の RPA サービスで結構有名っぽいやつ。
      Community Edition だと、個人でも使えるようだし、
      企業でも条件を満たせば無料で使えるようなので小規模事業な各位には良いかもしれない。
      https://www.uipath.com/hubfs/legalspot/JP-UiPath-Specific-Terms-for-Community.pdf

      Automation Cloud とかいうクラウド型のやつとか、色々な機能が使えるっぽい。

      機能も豊富らしいが、その分複雑なので素人には難しい、みたいな意見も見かけた。
      あと海外製なので日本人には英語がつらそう、
      と思ってたけど日本語化されてるのでそこは割とつらくないかもしれない。

      どの程度きっちり日本語化されてるかはわからないけど、
      ざっくり Qiita を見た感じだと割とちゃんとされてそうな雰囲気。

      あとは、海外製なので UI が日本人には合わない可能性はありそう。
      使ったことないから知らんけど。

      機能とかとは関係ないけど、公式サイトの英語版と日本語版の違いがちょっと面白い。

***** Automation Anywhere Community Edition

      [[https://www.automationanywhere.com/jp/][Automation Anywhere]] も海外製で有名っぽいやつ。
      学生や開発者、或いは小規模事業者なら無償の Community Edition が使えるとのこと。
      クラウド型の機能とかなんだとか、結構色々な機能を使える。

      こっちも日本語化は一応されてるが、
      [[https://qiita.com/RPAbot/items/2a2d94eeab641dfa6516][Qiita の記事]] を見た感じだと、英語の部分も残ってそうな雰囲気。
      英語となると苦しい人達には厳しいかもしれない。

      UiPath に比べるとライセンスがちょっと厳しい印象。
      https://www.automationanywhere.com/jp/community-edition-license-agreement-a2019

      特に利用台数が限られてるので、
      複数台マシンを所持していて、どっちからでも実行したい時とか、
      移行したい時とか困らないかなってお気持ち。

***** Power Automate Desktop

      [[https://flow.microsoft.com/ja-jp/desktop/][Power Automate Desktop]] は Microsoft が出してるやつで
      割と最近 Windows 10 ユーザーなら無料で使えるようになったやつ。
      Power Automate シリーズの1つなので、
      多分、もっと便利に使いたくなった時に、
      そのシリーズの他の製品との連携もスムーズにできるんじゃないかなってやつ。

      MS なので、多分息も長いし、
      Windows で個人用途でデスクトップ型で構わないなら
      まずはこれを試しておけって気がするやつ。無料なので。
      MS だから Excel も当然使えるしなっ!

***** Automator

      Mac 買ったら入ってるやつですね。なので実質無料。
      とりあえず Mac で RPA 的なことをしたかったらこれ使ってけば良いのでは、と思ってる。

      Excel なんかは対応してなかったりするのが微妙なところ。

**** 最後に

     個人的にはコードを書きたいので RPA あんまり入れる気がしないでござる。
     テスタビリティなさそうだし。
     NoCode での開発ツールに対する自動テストみたいな、
     コード書かない縛りプレイの時に使うかも、ぐらいのお気持ち。

*** DONE 最近 org-pomodoro 使ってないことに気付いた            :@Emacs:@雑記:
    CLOSED: [2021-04-29 木 18:03]
    :PROPERTIES:
    :EXPORT_FILE_NAME: why-not-use-org-pomodoro
    :END:

    [[https://github.com/marcinkoziej/org-pomodoro][org-pomodoro]] って便利な org-mode の拡張があるんですよ。
    org-clock とポモドーロテクニックを組み合わせて使える便利なやつ。

    デフォルト設定で話すと、
    何か TODO にカーソルを乗せてる状態で起動したら
    そいつが clock-in した上で25分のタイマーが動いて、
    25分経過したら clock-out した上で、5分の休憩が挟まって
    その休憩終了時には「次のポモドーロ開始するかい?」みたいなのが出て来て
    そこでまた M-x org-pomodoro を叩いたらまた25分のタイマーが開始して……みたいなやつ。

    まあ使い方それで合ってたかちょっと自信ないけど。
    というのも、表題の通りで、最近使ってないんですよね。
    便利な雰囲気なのに。

    なんで馴染まないのかな〜。
    やっぱり割込み作業が多くて pomodoro を乱されるから?
    あとは会議が挟まってくるとどう運用していいかわからなくなるから?

    前者の解決は、タイマー起動中は Slack の通知を切って見れないようにするぐらいじゃないと
    多分割込みを防げないよな〜という気はする。
    ちょっとその運用考えるか。

    後者は、まあ会議の時はもう pomodoro 放置でいいっていう割り切りかな。

    という悩みがあるので
    ポモドーロテクニックを1年以上継続しているぞ! みたいな猛者の方は
    どうやってそれを維持しているか教えてほしい。

    org-clock は使ってるけどね。pomodoro 存在を忘れてた。無念。

*** DONE org-agenda を活用し始めた                              :@Emacs:@org:
    CLOSED: [2021-04-29 木 19:03]
    :PROPERTIES:
    :EXPORT_FILE_NAME: try-org-agenda
    :END:

    昨年から org-mode をもっと活用していこうということで、
    org-clock を使い始めたり org-pomodoro を導入したり org-habits を設定してみたりしている麦汁さんです。

    org-mode は機能が豊富過ぎてマジで何が出来るのか全貌を把握し切れてないのですが、
    そんな中で、やっぱり全然把握できてなくて使ってなかった機能の1つが org-agenda ってやつ。

    なんかうまく使うと、予定を組んでたり締切を設定していたりするタスクが一目瞭然になって
    お仕事などが捗るという素敵な機能らしいのだけど、
    どうもイマイチ使い方がわからなくて放置していました。

    ただまあ仕事が捗るなら試してみる価値はあるよな〜ということで、
    今年の頭ぐらいから使い始めている。

    まず、平日朝イチでやっておきたい習慣タスクに対して
    ~Weekday~ と ~Start~ の2つのタグを振ってるか、
    ~Daily~ というタグを振ってるので
    それを表示できるやつを以下のように仕込んでる。

    #+begin_src emacs-lisp
    ("hs" "Weekday Start"
     ((tags "Weekday&Start|Daily"
            ((org-super-agenda-groups '((:name "予定が過ぎてる作業" :scheduled past)
                                        (:name "今日の作業" :scheduled today)
                                        (:discard (:anything t))))))))
    #+end_src
    https://github.com/mugijiru/.emacs.d/blob/a523566f2be993655f74ebf20afc4da444019f5e/inits/60-org.el#L89-L93

    麦汁さんのやりたいことを実現するには、
    デフォルトの org-agenda だとなんか機能が足りないっぽかったので
    それを補うために [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] も使っている。

    とりあえず上の例の2行目でタグによる絞り込みをしているが
    これは org-mode の標準機能を使っていて
    https://orgmode.org/manual/Storing-searches.html#Storing-searches
    あたりに書いてる方法で絞り込んでいる。

    で、その後に org-super-agenda の機能である
    [[https://github.com/alphapapa/org-super-agenda#group-selectors][Group Selectors]] というやつで
    スケジュール通りのやつと、スケジュールが過ぎてるやつとで表示を切り分けてる。

    ~(:discard (:anything t))~ は、
    そこまでの条件にマッチしなかったやつを全部無視するような設定。
    これがないと ~Other items~ という形で全部並んでしまって邪魔になる。

    最初の絞り込みで綺麗に絞り込めると良いかもしれないが、
    そこまで高度な機能は org-mode には備わってなさそう。
    それか、そういう高度な機能を見つけて使いこなせる能力を俺が有してないか。

    まあそれはともかく、上の感じでタスクを登録していると以下のように表示される。

    #+begin_example
    Headlines with TAGS match: Weekday&Start|Daily

     予定が過ぎてる作業
      next-actions:TODO 排便                                                      :Weekday:Start:

     今日の作業
      next-actions:TODO 体重・体脂肪率計測                                                 :Daily:
    #+end_example

    実際のやつはもっと色々あるというか、そもそもわざわざ排便を org-mode で管理はしてないので
    あくまでサンプルとして2つ置いてるだけだとご認識ください。

    同じノリでその日の締め作業も取れるように設定している。

    また、日中使うための設定も用意していて、こっちは結構複雑。

    #+begin_src emacs-lisp
      ("d" "Today"
       ((agenda "会議など"
                ((org-agenda-span 'day)
                 (org-agenda-files my/org-agenda-calendar-files)))
        (tags-todo "-Weekday-Daily-Holiday-Weekly-Weekend"
                   ((org-agenda-prefix-format " ")
                    (org-agenda-overriding-header "今日の作業")
                    (org-habit-show-habits nil)
                    (org-agenda-span 'day)
                    (org-agenda-todo-keyword-format "-")
                    (org-overriding-columns-format "%25ITEM %TODO")
                    (org-agenda-files '("~/Documents/org/tasks/next-actions.org"))
                    (org-super-agenda-groups '((:name "仕掛かり中" :todo "DOING")
                                               (:name "TODO" :todo "TODO")
                                               (:name "待ち" :todo "WAIT")
                                               (:discard (:anything t))))))
        (alltodo ""
                   ((org-agenda-prefix-format " ")
                    (org-agenda-overriding-header "予定作業")
                    (org-habit-show-habits nil)
                    (org-agenda-span 'day)
                    (org-agenda-todo-keyword-format "-")
                    (org-overriding-columns-format "%25ITEM %TODO")
                    (org-agenda-files '("~/Documents/org/tasks/projects.org"))
                    (org-super-agenda-groups '((:name "〆切が過ぎてる作業" :deadline past)
                                               (:name "予定が過ぎてる作業" :scheduled past)
                                               (:name "今日〆切の作業" :deadline today)
                                               (:name "今日予定の作業" :scheduled today)
                                               (:discard (:anything t))))))
        (tags-todo "Weekday|Daily|Weekly"
                   ((org-agenda-overriding-header "習慣")
                    (org-habit-show-habits t)
                    (org-agenda-files '("~/Documents/org/tasks/next-actions.org"))
                    (org-super-agenda-groups '((:name "予定が過ぎてる作業" :scheduled past)
                                               (:name "今日予定" :scheduled today)
                                               (:discard (:anything t))))))))
    #+end_src
    https://github.com/mugijiru/.emacs.d/blob/a523566f2be993655f74ebf20afc4da444019f5e/inits/60-org.el#L109-L144

    通常なら Agenda for current week or day ってのが標準で用意されてるので
    それを使えばいいかなって思うんだけど
    1 view でいい感じにカテゴライズされていて取得できるってのが欲しかったんですよね。
    で、それをやろうと思うとやはり org-super-agenda が必要そうだったって感じ。

    とりあえず現在は next-actions.org に、直近やるつもりの作業を詰めていて
    projecs.org に、直近ではないけどやることリストを並べてるって感じ。
    スプリントバックログとプロダクトバックログみたいな扱いのつもりですね。
    あとは別途 org-gcal で同期している Google Calendar から取得した予定用のファイルもあったりする。

    そうやっていくつかあるファイルからいい感じになるようにということで設定しているのが先程のコードで
    それで org-agenda のバッファを生成すると以下のような雰囲気のやつになる。

    #+begin_example
     会議など
     11:00-12:00 すごい会議
     15:00-18:00 長い会議
    ------------------------------
    今日の作業
     仕掛かり中
     - 藁人形の作成
     待ち
     - 五寸釘発注の稟議

    予定作業
     〆切が過ぎてる作業
     - 五寸釘の発注

    習慣
     予定が過ぎてる作業
     - 排便
     今日予定
     - 体重・体脂肪率計測
    #+end_example

    もちろん、内容はサンプル用に適当にでっち上げたやつです。

    本当はタグも表示されてしまうけど、それはあまり要らないかなと思ってるので、
    それはなんとか非表示にしたいなあと願ってる。
    ~org-overriding-columns-format~ を弄っても今のところいい感じにならなくて悲しい。

    あと、今の設定と使い方だと「あと数日で着手しないといけないタスク」とか
    そういうやつはわからないので、それもなんとかしたい。

    多分着手予定の日を早めに設定して起きつつ
    〆切を設定してたら今でもある程度いけるんだろうけど、
    気付いたら着手予定が同じ日になってて
    いきなりその日に全部やらないといけない雰囲気になるとかありそうでこわい。

    数日前から、着手予定のやつがいつ着手予定なのか見れるようにしたらいいんだろうな〜。
    ま、少しずつ改善を入れていくしかないか……。
*** DONE Ember.js@3.4 から最新の 3.26 に上げた             :@Rails:@Ember_js:
    CLOSED: [2021-05-09 日 14:35]
    :PROPERTIES:
    :EXPORT_FILE_NAME: update-emberjs-3_4-to-latest
    :END:

    いつも Ember.js ネタを書く時に使ってる
    https://github.com/mugijiru/ember-rails-todo-app
    のリポジトリですが、ゴールデンウィークで Ember.js の最新版への対応を完了させました。

    そこへの対応のために https://github.com/mugijiru/ember-components の addon の方も
    2.18 から最新化することになりました。

**** 対応の方針
     どう対応させていったかというと、
     [[*ember-cli-rails の Ember.js を 2.18 から 3.4 にアップデート][ember-cli-rails の Ember.js を 2.18 から 3.4 にアップデート]]
     の記事でも書いた

     #+begin_quote
     3系で LTS であったバージョンを順番に適用していく方針
     #+end_quote

     を実際にやってみたって感じ。

**** 実際の対応
***** eslint 対応

      3.4 に上げた後に、eslint で怒られてるのに対応できそうだなとなったので
      3.8 に上げる前に修正をした

      https://github.com/mugijiru/ember-rails-todo-app/pull/66

      大きな変更点は
      jQuery を使って要素を取得していたところを
      純粋な JS に書き換えたところぐらい。

***** 3.4 → 3.8
      https://github.com/mugijiru/ember-rails-todo-app/pull/67

      1. ~ember-cli-update --to 3.8~
      2. ~yarn~
      3. ~ember-cli-update --codemods~

      を叩いたぐらい。codemods では特がないので難しいところは何もない。

***** 3.8 → 3.12
      https://github.com/mugijiru/ember-rails-todo-app/pull/68

      3.8 に上げるよりはちょっと面倒だった。

      が、基本的には

      1. ~ember-cli-update --to 3.12~
      2. ~yarn~
      3. ~ember-cli-update --codemods~

      を叩いてるだけである。

      とりあえず [[https://github.com/mugijiru/ember-rails-todo-app/pull/68/commits/cd7e96493dc9f52c67ee499801144c25b54a4d36][codemods で結構変更があった]] ので、それを軽く話すと

      - handlebars で AngleBraket を使うようになった
        - 3.4 からサポートされ始めてるけど 3.10 でちゃんと使えるようになったっぽい
      - handlebars でコンポーネントに値を渡す時に ~@hoge={{value}}~ みたいに ~@~ をつけるようになった
        - これで component の変数か、単なる HTML の属性値かの区別がつくようになったっぽい
      - model が ~ember-data~ ではなく ~@ember-data/model~ を import するようになった
        - この頃から個別機能を import させる方針になり始めてるっぽい

      という感じ。
      モダンっぽいし、こっちの方が好みの書き方ですね。

      あとは Observer を使ってるところが eslint で怒られていたけど
      直すのが大変そうだったので eslint の方を無視するようにしちゃった。
      まあ、これよりずっとあとの手順で直してるんだけども。

***** 3.12 → 3.16
      Octane が入って来てるからか、
      ember-cli-update での差分も大きく、
      動くようにするまでにいくつかやることがあった。

      まずはいつものように

      1. ~ember-cli-update --to 3.16~
      2. ~yarn~
      3. ~ember-cli-update --codemods~

      を実行。
      で、[[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/da37e4342c120a4c73a88f7b72ee7344d07eb3e6][ember-cli-update したところで]]
      app.js が書き換えられて自分の設定が消えたのを直すハメになったり
      同じく config/environment.js が書き換えられてそれも直すハメになったりしてた。
      新しい文法にするのはいいけど設定を吹っ飛ばすのはやめてほしい。

      あと config/optional-features.json で jquery-integration が false にされたのもいただけなかった。
      [[https://github.com/rondale-sc/ember-cli-rails-addon/blob/master/app/initializers/ember-cli-rails-addon-csrf.js][ember-cli-rails-addon-csrf]] 的に必要なんだよぉ。

      あとは [[https://ember-learn.github.io/ember-octane-vs-classic-cheat-sheet/][Ember.js Octane vs Classic Cheat Sheet]] を参考に書き換えた。

      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/5a2d971f18fa3da9d3f45c344666e7c134b2bf4a][hbs の書き方がさらに変わったので修正]]
        - 親から貰った受け取ったプロパティは @ を prefix とするように変更
        - 自身の持つプロパティは this. を prefix とするように変更
        - ~@click=~ で定義していた click イベントは on を使うように変更
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/ed3e7e3c1fdac5a88277fafa6c5ce42a603ff9cb][jQuery に頼ってた部分を素の JS に書き換え]]
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/0f4113e6a918dbfd5f75500370fd2e00486d1cec][Component の action の書き方などの変更]]
        - actions で囲むのではなく ~@action~ というデコレータをメソッドにつける方法になった
        - form の button を叩いた時に submit されるようになってしまったので preventDefault で送信されないようにした
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/69/commits/3362321970ed616212ce1250fec3555eba434bd4][Controller の action などの書き方などを変更]]
        - actions で囲むのではなく ~@action~ というデコレータをメソッドにつける方法になった
        - こっちでも jQuery に頼ってたのを直した

      ということをやっている。

      設定が変わってるのをちゃんと戻す作業とか
      jquery-integration の問題とか
      書き方が色々変わったりしているので、なかなか苦労した。
      hbs は結構変わってるしね……。

      まあでも大体そんな感じのことをしたらなんとかなる。

***** 3.16 → 3.20
      https://github.com/mugijiru/ember-rails-todo-app/pull/71

      これは

      1. ~ember-cli-update --to 3.16~
      2. ~yarn~
      3. ~ember-cli-update --codemods~

      だけで済んでるのでちょー楽だった

***** 2.18 → 3.4 for @mugijiru/ember-components
      ここで突然別の流れをぶち込むハメに。

      というのも ember-todo-rails-app の Ember.js を 3.24 に上げようとしたら
      その中で使ってるコンポーネントである @mugijiru/ember-components の方を更新しないと
      上げられない状態になってしまったから。

      多分 Classic な書き方がダメなんだろうなという推測で、
      こっちも Octane 対応をしないといけないな、という判断になった。

      で、こっちも段階的に上げていくわけですが、
      ひとまず 3.4 にするにあたり
      ember-rails サポートも切っておく方が楽なので

      - https://github.com/mugijiru/ember-components/pull/5
      - https://github.com/mugijiru/ember-components/pull/6

      で 2.18 のままだけど Gem のサポートをやめて module を使う仕組みに書き換えている。
      ember-rails でなければ古い書き方をする必要はないのだ。

      そしてさらに https://github.com/mugijiru/ember-components/pull/7 で 3.4 に上げている。

      コード変更で面倒だったのは

      - [[https://github.com/mugijiru/ember-components/pull/7/commits/7bf7f7c7905af7a671d84b25991b9ceb68800048][codemods 適用]]
        - テストの書き方が多少変わってるのでそっちを覚えないといけない
      - [[https://github.com/mugijiru/ember-components/pull/7/commits/b70537441d63aa6f9efafa03c407ef30973461c5][test 用に読み込むパッケージ名の修正]]
        - package.json でパッケージ名が修正されたのに伴う変更。まあこうあるべきって感じ。
      - [[https://github.com/mugijiru/ember-components/pull/7/commits/a6505609e2ccf2c8d17ee703cc1aa7cff2847aea][テストでのレンダリングの仕組みが変わったようなので対応]]
        - どうもレンダリングで Wrapper になる div が入るようになったっぽいので雑に div で取ってたのが動かなくなった

      あたりかな。
      パッケージ名の修正と div のやつはどっちも気付くのに時間がかかってしまったやつ。つらかった。

***** 3.4 → 3.8 for @mugijiru/ember-components
      https://github.com/mugijiru/ember-components/pull/8

      まあ難しいことをしなくても普通に上がったやつですね。はい。
      なので詳細はいいや。

***** 3.8 → 3.12 for @mugijiru/ember-components
      https://github.com/mugijiru/ember-components/pull/9

      これもあっさり上がったので特筆することなし

***** 3.12 → 3.16 for @mugijiru/ember-components
      - https://github.com/mugijiru/ember-components/pull/10
        - 3.16 に上げたのはこっち
      - https://github.com/mugijiru/ember-components/pull/12
        - 3.16 に上げただけだと修正が足らなかったので追加修正したやつ

      いつもの手順はもういいとして、
      特別にやったことは

      - [[https://github.com/mugijiru/ember-components/pull/10/commits/8bc5e01b97e1740601a4710496d28d6840ce6e4d][hbs の書き方を新しい形式に合わせた]]
        - this をつけただけだけど
      - Component の書き方修正([[https://github.com/mugijiru/ember-components/pull/10/commits/654619191256c8a778440007fab2c9f16185f247][mg-button]], [[https://github.com/mugijiru/ember-components/pull/10/commits/9b4beeec63023fecb43b5208a1f324030916e4b0][mg-checkbox]], [[https://github.com/mugijiru/ember-components/pull/10/commits/7c2b92a8a1634b0a1d4fa1d8dc3fd02732cf9525][mg-toggle-switch]])
        - addon/templates/components/*.hbs から addon/components/*.hbs に移動
          - どうもいつの間にか templates/components に置かなくて良くなったっぽい
            - さらに新しい [[https://cli.emberjs.com/release/advanced-use/project-layouts/#podslayout][pods layout]] というのもあるけど addon の場合は互換性維持のために classic 推奨。
        - import 元を ~@glimmer/component~ にして Native Class を用いた記述に変更
          - これまで ~export default Component.extend~ していたのが ~export default class Hoge extends Components~ という書き方になった
          - Native Class になったのでプロパティも普通に ~hoge = 'fuga'~" みたいに書くようになった
        - className, classNameBindings は使えなくなったので調整
        - 親から渡って来るパラメータの初期値調整のための記法の使用
          - ~get hoge () { return this.args.hoge ?? '' }~ のようにしてデフォルト空文字列にするなど
            - 親から渡って来るパラメータは ~this.args~ のように隔離された場所に入るようになってる。便利。
      - [[https://github.com/mugijiru/ember-components/pull/12][Click が実行されない問題の修正]]
        - onClick というパラメータで渡って来たやつをクリック時に実行するように調整している

***** 新しい @mugijiru/ember-components に更新

      https://github.com/mugijiru/ember-rails-todo-app/pull/72

      MgButton とかに ~{{on "click" this.save}}~ とかでアクションを渡せていたのが
      ここからは ~@onClick={{this.save}}~ のように渡さないといけない。
      なぜなら @mugijiru/ember-components を Octane 対応する際にそういう風に仕様が変わったからだ。

      https://guides.emberjs.com/release/in-depth-topics/patterns-for-actions/
      を見た感じ、そうするのが正しいっぽい。
      ただの button には ~{{on "click" this.save}}~ というように書くことになるので
      混乱がありそうでだるいけど。

***** 3.20 → 3.24
      @mugijiru/ember-components の Ember.js を 3.16 にして Octane 対応を済ませることで
      ember-rails-todo-app の Ember.js を 3.24 に上げられるようになった。

      https://github.com/mugijiru/ember-rails-todo-app/pull/73

      ここではあんまり対したことはしてないけど
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/73/commits/9268c5414c2c3052c2537fa1e2dacc0b4ee55886][active_model_serializer を使うことを明示的に書かないといけなくなった]]
      というのが一番だるいポイントかな。
      これも原因判明までに時間食ったやつ……。

***** 3.24 → 3.26(最新)
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/74][ember-bootstrap を 4系に上げた]]
      - [[https://github.com/mugijiru/ember-rails-todo-app/pull/76][Ember.js を最新化し、文法も最新に合わせて書き直した]]

      あたりで、最新化できた。
      ember-bootstrap は上げられるから上げておいただけだけども。

      - native class としてクラス定義するように変更
      - @tracked, @sevice, @action, @attr などのデコレータを使うように変更
      - computed property は tracked を使う書き方に置き換え
      - set, get を使った書き方も古いので ~this.get('hoge')~ などを ~this.hoge~ みたいに書き換え

      あたりのことをしている。
      結構変更は多いけど、まあ、基本的に lint のいうことに従って対応しただけである。

      ひとつ initializer で current-user を無理やり inject している処理が
      Native Class に置き換えできなかったので、
      ここはどこかでなんとかしないとまずそう。多分 Ember.js@4 に追従できなくなる
      https://github.com/mugijiru/ember-rails-todo-app/pull/76/commits/f6b6ed65863a9e94ed1b41154387e87e4f0da1bf

      User class を用意して instanceInitializer でそこに突っ込んでやるとか、
      Service class を用意したりしたら、なんとかなりそうな気はしている。

***** 3.16 → 3.20 for @mugijiru/ember-components
      アプリ本体だけでなく addon も最新化対象である。
      https://github.com/mugijiru/ember-components/pull/13

      3.20 に上げるのは何も問題なし。
      3.16 に上げる時に苦労したからねえ。

***** 3.20 → 3.24 for @mugijiru/ember-components

      https://github.com/mugijiru/ember-components/pull/15

      3.24 に上げるのも特に苦労なし。

***** 3.24 → 3.26(最新) for @mugijiru/ember-components
      https://github.com/mugijiru/ember-components/pull/16

      基本的には難しいことなし。
      ただし Interactive な要素じゃないのに click させるなって eslint に怒られてたから
      MgChecobox や MgToggleSwitch を div から button に変更した。
      https://github.com/mugijiru/ember-components/pull/16/commits/d9f14499f92584479fe7154879003bfd5f237f03

      ~input type="checkbox"~ が良い気もするけど、ま、一旦いいや。

***** 最新の @mugijiru/ember-components 取り込み
      https://github.com/mugijiru/ember-rails-todo-app/pull/77

      最新化する際に、
      div から button に書き換えた影響で style 崩れがあるので調整している。

      @mugijiru/ember-components 用の css は addon 側に置いても良いよなあと思ってるけど
      今回はそこは放置している。めんどくさくて。

**** 最後に
     ゴールデンウィークをこれで結構消費してしまったのでちょっと残念な気持ちになっている。

     けどまあ、どこで引っ掛かりやすいかは結構洗い出せたので良い。

     - 3.8 → 3.12 :: codemods で結構変更される
     - 3.20 → 3.24 :: addon が 2.18 で使えるような古い書き方だと使えなくなる
     - Octane 対応 :: 書き方が色々変わる。古い書き方も一部まだサポートされてそうだけど。

     とりあえず Octane が鬼門かねえ。
