#+TODO: TODO(t) | DONE(o)
#+HUGO_BASE_DIR: ./
#+HUGO_SECTION: ./
#+title: 麦汁三昧
#+author: mugijiru

* 麦汁三昧
** DONE About
   CLOSED: [2020-12-20 日 11:59]
   :PROPERTIES:
   :EXPORT_FILE_NAME: about
   :END:

   この Web サイトは Web プログラマである麦汁の個人サイトです。

   気が向いたらブログ記事を更新したりするはず。

** DONE Profile
   CLOSED: [2020-12-20 日 12:15]
   :PROPERTIES:
   :EXPORT_FILE_NAME: profile
   :END:

   都内で Ruby on Rails と Vue.js を使った Web アプリケーションを開発している Web プログラマ。
   一部インフラ(AWS)もかじっている。

   最近は実装よりも、仕様策定や全体の進捗管理、調査、その他雑用をしていることが多い。

   好きなエディタは Emacs。サブで Vim も使っている。

   1983年生まれ。沖縄出身。

*** 経歴
    - 2009年 :: 沖縄の IT ベンチャー企業に就職しWebプログラマとして活動
    - 2012年 :: 別の沖縄の IT ベンチャー企業に転職し引き続きWebプログラマとして活動
    - 2016年 :: 都内 IT ベンチャー企業に転職しWebプログラマとして活動
    - 現在   :: リードエンジニアとして活動中

*** SNSなど
    - Twitter :: [[https://twitter.com/mugijiru][@mugijiru]]
    - GitHub :: [[https://github.com/mugijiru][mugijiru]]
    - 旧Blog :: [[http://mugijiru.seesaa.net][麦汁三昧]]

** Blog
   :PROPERTIES:
   :EXPORT_HUGO_SECTION: posts
   :END:
*** DONE Hugo 始めました                                              :@雑記:
    CLOSED: [2020-12-20 日 15:22]
    :PROPERTIES:
    :EXPORT_FILE_NAME: starting-hugo
    :END:

    Hugo はなんか Emacs 界隈で流行ってるし、
    自分のサイトだっせーなーって思ってたので
    Hugo を使って、公開されてるテンプレートを適用して
    Web サイトを再構築してみることにした。

    <!--more-->

    他の静的サイトジェネレータもちょっと検討したけど
    機能面とかも考慮した上で Hugo がいいかなって。
    主な理由は「流行ってるから」ですが。
    ほら、流行りに乗りたいじゃん。ちょっと乗り遅れてる気もするけど。

    今、とりあえず作ってる最中なんだけど、
    つい BBS とかチャットとかリンク集とか置きたくなる。
    90年代または2000年代脳である。
    お絵描き BBS も置いたろうかって気持ちになる。
*** DONE 新年明けましておめでとうございます                           :@雑記:
    CLOSED: [2021-01-02 土 20:31]
    :PROPERTIES:
    :EXPORT_FILE_NAME: happy-new-year-2021
    :END:

    新年明けましておめでとうございます。麦汁です。
    昨年の終わり頃、世間では AdventCalendar で賑ってる頃に、
    ふと「サイトのリニューアルしたいなあ」なんてことを思って、
    リニューアルに着手しましたが、ようやくそれが実りそうです。

    <!--more-->

    なんでそんなことをしてるかというと
    前の記事 [[*Hugo 始めました][Hugo 始めました]] でも書いたように
    「自分が作ったサイトだっせー」ってのが1つあります。

    それを構築した時には
    「デザインとかも全部自分でやっちまおう」ということで全部やろうとしていたのですが
    デザインセンスが壊滅的だったとか時間がろくに取れないとかやる気が他に吸われていったとかで
    イマイチなまま放置していました。よくないですねえ。

    あと、そことは別にブログサービスを借りて使ってるのですが
    そっちはそっちで更新がだるいなってのもあって
    リニューアルと同時に今後のブログ更新はこっちにしてしまおう、というのもあったりします。

    Hugo でブログもやってしまう方が [[https://ox-hugo.scripter.co/][ox-hugo]] も使って記事を書き出せるので
    org-mode 使い的には幸せになれそうですし。

    あとは折角リニューアルしたんだからモチベーションが続くことを願っています。

    というわけで 2021 年の抱負は「月に2回はブログを更新する」とします。

    結構、緩めな抱負ですが、仕事じゃないのでこのぐらいの方が良かろう……。
*** DONE browse-at-remote を導入した                                 :@Emacs:
    CLOSED: [2021-01-23 土 23:18]
    :PROPERTIES:
    :EXPORT_FILE_NAME: add-browse-at-remote
    :END:

    仕事中、プルリクのレビューをする際に、
    「ここのコードがこんな感じになってるから〜」みたいな感じで
    既存コードへのリンクを張ることがちょくちょくある。

    そういうことをする時、まずそもそも差し示したいコードを確認するんだけど
    その時は Emacs の中で探す方が早い。
    で、探して確認するまではいいんだけど、そこから GitHub 上のコードへのリンクを取得しようとするとちょっと面倒。

    これまでは、GitHub のリポジトリのトップからディレクトリを辿って行って
    当該コードを再度探していました。めんどくさいねっ。

    というわけで解決する手段を探していて
    最近導入したのが [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] というやつ。

    こいつを入れてる状態で、GitHub のリポジトリに突っ込んであるコードの上で
    ~M-x browse-at-remote~ を実行すると
    GitHub でのリポジトリでのコードの位置でブラウザを開いてくれる。

    コードの上でと書いたけど、リージョンを選択していればその範囲が選択された状態で実行すると
    選択した行がハイライトされた状態で開いて便利。

    その状態から GitHub 上で ~Copy permalink~ をしておいて
    PR のコメントにコピーしたリンクを貼り付けるとコードも表示されて便利。

    で、結構よく使うコマンドとなったので
    Hydra から即呼び出せるようにしてある。

    Global に使うコマンドを突っ込んでる Hydra は key-chord で ~jk~ を叩くと呼べるようにしていて
    その中で ~B~ を叩けば browse-at-point が呼ばれるようにしてある。

    というわけで、導入と Hydra の設定を追加しているプルリクが以下になります。
    https://github.com/mugijiru/.emacs.d/pull/205

    という使い方をしているけど、
    実は似た機能を提供している [[https://github.com/sshaw/git-link][git-link]] で ~git-link-use-commit~ のフラグを立てておいて
    他にもいくつか設定を入れたりしたらもっといい感じのことができるのかもしれない。
    今度試すか……。

*** DONE 2021年にもなって ember-rails で新規アプリを書いてみてる :@Rails:@Ember_js:
    CLOSED: [2021-02-13 土 01:15]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-in-2021
    :END:

    少し思うところがあって、
    2021 年になったというのに [[https://github.com/emberjs/ember-rails][ember-rails]] を使って新規で Web アプリを書いている。

**** ember-rails とは?

     ember-rails は
     Ember.js という Web フロントエンド MVC なフレームワークを
     Rails といい感じに連携してくれて快適な Web アプリケーション開発体験を提供してくれるものであった。

     過去形なのは、ember-rails は Rails3 とか 4 とかの時代に主に使われていて
     既にメンテナンスされてないのと、
     今はそれよりも良い [[https://github.com/thoughtbot/ember-cli-rails][ember-cli-rails]] というのがあるから。

**** 今 ember-rails を使うと何がつらいか

     色々つらい。

***** まずメンテナンスが止まってる
      なので Rails 6 で動くかがわからない。
      多分、試している人はいないし、自分もそこまで試す気力はない。

***** Ember.js のサポートが 2.18.2 までとなっている。
      より詳細に話すと
      ember-rails が依存している Gem である ember-source で
      本当は 3.0.0.beta.2 まで出てるんだけど、β版のことは無視する。
      https://rubygems.org/gems/ember-source/versions/2.18.2

      で、その 2.18.2 は既にサポートされてないバージョンである。

      サポートされてないバージョンを使うのはセキュリティ面でもまずいし
      もはや情報もあまり落ちてないので苦行である。

      Ember.js 公式サイトのドキュメントが
      過去のバージョンのものも残されているのでそれを頼りにするしかない。
      というか公式で残しててくれてありがとう。それがないと何もできないよ。

***** ember-rails だと Ember.js の addon が導入できない
      例えば Handlebars でロジックを書く上で
      とても基本的な比較用のヘルパーを提供してくれる [[https://github.com/jmurphyau/ember-truth-helpers][ember-truth-helper]] が使えない。
      これが使えないはめっちゃ不便で、
      それをなんとかするために同じようなコードを自前で用意するハメになる。

      他にも [[https://github.com/ember-community-russia/awesome-ember][ember-community-russia/awesome-ember]] に載っている色々なものが使えないわけだ。
      つらいどころか悲しくなってくる。

***** 自動テストが書けない
      Ember.js は QUnit で自動テストができるようになっているのだが
      ember-rails だとそれも使えない。
      すなわちフロントエンドのコンポーネントの単体テストが書けないのである。

**** それでも ember-rails を使いたい方には

     どうして素直に ember-cli-rails や ember-cli そのものを使おうとしないのかはわからないけど
     どうしても ember-rails の世界に住みたいのであれば
     [[https://github.com/discourse/discourse][discourse]] のソースを参考にしたら良いと思う。

     どうやら [[https://github.com/discourse/discourse/pull/11932][ember-cli に乗り換える方針で動いているよう]] だが
     今日時点の Gemfile には未だに discourse-ember-source などの記述が残っている状態であり、
     まだ完全移行はできてない様子。

     [[https://rubygems.org/gems/discourse-ember-source/versions/3.12.2.2][discourse-ember-source]] は 3.12 系まで追従していたようなので
     そこまでは discourse の真似をすれば使えるだろう。

     また彼らは ember-rails を使いながら qunit でのテストもできるようにしているようである。
     正直マジか頑張ったなって気持ち。
     ちょっとどうやって動かしているのかはわからない。
     あんまり調べる気力もない。
     なんとなくわかったことは ES6 の module システムを活用して頑張ってる雰囲気があることである。

     他にも addon も使えるようにしている様子でもあるが、
     これもちょっとよくわかってない。
     あまり adoon が使われてる気もしないが……。

     ともかく ember-rails を独自に拡張した上で色々頑張っているようである。すごい。
     それでももう ember-cli-rails に乗り換えようとしているようなので
     今から ember-rails の世界に住もうとするのはやめた方がいいはず。

     あ、よく見ると Rails は 6.0 系だ。
     ってことは少なくとも discourse-ember-rails なら Rails 6.0 でも動くわけか。なるほど。

**** で、なぜ自分は ember-rails で新規アプリを書いているか

     マゾなので、敢えてその環境で新規アプリを用意しておいて
     そこから ember-cli-rails に移行する、みたいなことをしてみたいから。

     本当は自分で ember-rails なアプリを書くつもりはなかったんだけど
     サンプルになるようなアプリが探せなかったってのもある。
     これが Yak Shaving か〜と思いながら粛々と小さなアプリを書いていくのであった

     できたらまた記事にする。
     アプリ自体は公開しないけど、ソースは GitHub に上げるつもり。

*** DONE ember-rails で書いた Web アプリを GitHub で公開した :@Rails:@Ember_js:
    CLOSED: [2021-02-21 日 15:40]
    :PROPERTIES:
    :EXPORT_FILE_NAME: publish-ember-rails-app
    :END:

    [[*2021年にもなって ember-rails で新規アプリを書いてみてる][この間の記事]] で書いたように
    ember-rails で簡単なアプリケーションを作ってた。
    よくある TODO アプリである。

    [[file:images/screenshot-ember-rails-todo-app.png]]

    先週時点では「テストとかなくてもいいから動けばいいだろ」って気持ちだったけど
    なんとなーくテストを追加したくなったり
    あんまり慣れてない docker-compose 対応してみたりしていたのと
    平日はこのプログラムに触れてなかったので、結構日が空いてしまった。

    まあ、それはともかくとして、
    とりあえず [[https://github.com/mugijiru/ember-rails-todo-app/]] に置いておいた
    現時点の最新コミットで [[https://github.com/mugijiru/ember-rails-todo-app/tree/v1.1.1][v1.1.1]] のタグを振ってるやつは
    自分の知ってる一番古いスタイルで書かれてる状態にしてある。

**** 使ってる Gem

     - Ember.js 関係
       - ember-rails
       - ember-source
       - jquery-rails
         - Ember.js は 2 系まで jquery に依存しているので
           - よく見ると ember-rails の依存に入ってるから書かなくて良かったな……
       - active_model_serializers 0.9
         - 0.9 系じゃないとうまく動かないっぽい
     - CSS framework
       - bootstrap-sass
         - レガシー感の演出のため敢えてこれにしている
     - テスト関係
       - rspec-rails
       - factory_bot_rails
       - database_rewinder
       - capybara
       - selenium-webdriver

     あたり。

**** レガシー感の演出

     レガシー感を出すために bootstrap-sass(Bootstrap3系になる)を使ったりはしているが
     あまり特別なものは使ってない。

     また ember-rails で ember アプリのソースコードを generate すると
     es6 module を使ったようなコードが出力されるけど、
     これも敢えてレガシー感を出すために module を使わない形式に書き直している。

     よりレガシー感を出すために CoffeeScript にするという手もあったけど、
     さすがにそこまでは頑張りたくないw
     もう何年も触ってないよ CoffeeScript...

     そしてページ全体を Ember.js にはしないで
     ページの一部を Ember.js にする [[https://guides.emberjs.com/v2.18.0/configuring-ember/embedding-applications/][埋め込み]] 形式を採用している。
     既存のアプリに Ember.js を後乗せした感の演出である。
     実際、構築時には一時的に普通の Rails App として動くようにしていた。

     他にこだわったところは、今回は単一のアプリケーションしか動かしてないけど
     [[https://github.com/emberjs/ember-rails#multiple-ember-application][Multiple Ember Application]]
     の作法に則って、Ember アプリケーションを追加で乗せられるようにしている。
     これにより「この画面も Ember 化しようず」という流れで
     Ember アプリが複数動いてる状態により近くなったんじゃないかなと。
     実際今回動いてるのは1つだから、ちょっと違うけどね。。。

**** 最後に

     ここから段々と最新の Ember.js を使えるように寄せていくつもり。

*** DONE 古い ember-rails App で一部ファイルを ES6 Module 化 :@Rails:@Ember_js:
    CLOSED: [2021-02-21 日 22:41]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-partial-modulize
    :END:
**** これは何?
     ember-rails を古いスタイルで書いておいて
     それをモダン化していく企画の第一弾の記事。

**** 何をしたのか
     今回は ES6 module を使ってない ember-rails アプリケーションで
     一部のファイルだけ ES6 Module にしてみた。

**** 何が嬉しい?
     今回扱ってるアプリケーションのサイズはとても小さいので
     まとめて置き換えることも可能というか、
     ぶっちゃけ [[https://github.com/mugijiru/ember-rails-todo-app/pull/7][古いスタイルに書き換えた PR]] を revert するだけで
     ES6 Module 化できたりする。

     しかし、世の中に潜んでいる、レガシー化した ember-rails のプロジェクトでは
     全部まとめて ES6 Module にするのはファイル数が多過ぎて困難かと考え、
     敢えて一部のファイルだけ ES6 Module 化する方法を探してみた。

**** どうやったらできるの?

     簡単に言うと
     ES6 Module 形式で書いたやつを import して
     Ember.js Application の Namespace に放り込めばいいだけ。

***** Example
      まずはコンポーネントなどを
      ~app/assets/javascripts/ember-app/components/foo.module.es6~ ってファイル名で

      #+begin_src js
      import Ember from 'ember';

      export default Ember.Component.extend({});
      #+end_src

      のように書いておく。
      拡張子が ~.module.es6~ というのがポイントで、
      そうしておくと
      [[https://github.com/tricknotes/ember-es6_template][ember-es6_template]] という Gem が
      自動的に ES6 の module として判定してくれるようになっている
      https://github.com/tricknotes/ember-es6_template/blob/c1c7b8d23be7669a0aa6c5f9c71b916a3799f9a6/lib/ember/es6_template/sprockets.rb#L10

      そして ~app/assets/javascripts/ember-app/application.js.es6~ の末尾にでも

      #+begin_src js
      import FooComponent from 'ember-app/components/foo';

      EmberApp.FooComponent = FooComponent;
      #+end_src

      のように書いたら、
      一応 module 形式で書けるし、
      それを window.EmberApp で用意した Ember.js Application で使えるって感じ。

**** ファイルの数と同じ量の import 書くの?

     だるいよね。
     なので import 処理は
     ~app/assets/javascripts/ember-app/import-modules.js.es6.erb~
     という erb template でも分離して

     #+begin_src erb
     <% module_dir = Rails.root.join('app/assets/javascripts/ember-app/modules') %>
     <% Dir.each_child(module_dir) do |dir| %>
       <% next unless FileTest.directory?("#{module_dir}/#{dir}") %>
       <% Dir.glob('*.module.es6', base: "#{module_dir}/#{dir}") do |module_file| %>
         <% module_name = File.basename(module_file, '.module.es6') %>
         <% klass_name = "#{module_name.underscore.camelize}#{dir.underscore.singularize.camelize}" %>
     import <%= klass_name %> from 'ember-app/modules/<%= dir %>/<%= module_name %>';
     EmberApp.<%= klass_name %> = <%= klass_name %>;
       <% end %>
     <% end %>
     #+end_src

     とでも書いておけば全部いい感じに読んでくれる。

**** 関連 PR

     実際に動くコードは以下の PR で用意した。
     https://github.com/mugijiru/ember-rails-todo-app/pull/8
     https://github.com/mugijiru/ember-rails-todo-app/pull/9

     最初の PR で ~modules~ フォルダにさらに components フォルダを掘って
     その中にファイルを配置している。

     その方が全部移行できた後にまるっと置き換えするのに楽そうだからだ。

     また import して Namespace に放り込む処理も別ファイルに追い出している。
     これも、完全移行が済んだら不要になるファイルなので
     消しやすさを重視して分割しておいた。

     さらに後続の PR で、
     複数のタイプが来ても対応できるように書き換えている。
     Model は対応できてないけど、ま、Model は移行してないのでとりあえず放置。

     CI でテストも通しているしバッチリだと思う。
     デプロイできるようにはしてないからサーバで動くかは確認してないけど、ま、大丈夫だろ

*** DONE 古い ember-rails App で ES6 Module 化を完了した   :@Rails:@Ember_js:
    CLOSED: [2021-02-23 火 20:45]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-complete-modulize
    :END:

    - [[https://github.com/mugijiru/ember-rails-todo-app/pull/10][#10 サブフォルダのファイルを全て module に移行した]]
    - [[https://github.com/mugijiru/ember-rails-todo-app/pull/11][#11 残りのファイルも module 化した]]

    でやってることで全てだけど
    [[*古い ember-rails App で一部ファイルを ES6 Module 化][前回の記事]] でやってた内容を完了まで持って行った。

**** サブフォルダ以下の ES6 Module 化
     https://github.com/mugijiru/ember-rails-todo-app/pull/10 でやったこと。

     これは基本的に単純で、
     ほぼ前回の記事でやってることを全部のフォルダに適用しただけ。

     Model だけ命名規則が他と違うので
     import 関連の処理をそこだけ分岐している

     #+begin_src erb
     <% if dir == 'models' %>
       <% klass_name = module_name.underscore.camelize %>
     <% else %>
       <% klass_name = "#{module_name.underscore.camelize}#{dir.underscore.singularize.camelize}" %>
     <% end %>
     import <%= klass_name %> from 'todo-app/modules/<%= dir %>/<%= module_name %>';
     TodoApp.<%= klass_name %> = <%= klass_name %>;
     #+end_src

     Model は ~models/hoge.module.es6~ とあったら ~Hoge~ として使われるようにして、
     他は例えば Component だと ~components/fuga.module.es6~ とあったら ~FugaComponent~ として使われるようにしているだけ。

     あとはそれぞれのファイルを ~*.js.es6~ から ~*.module.es6~ に rename して import, export に書き換えるだけ。
     とても簡単だし、全部まとめて変更する必要もないので楽。

     ただこれをやってる時に気付いたのが
     ~import-modules.js.es6.erb~ が cache されてるおかげで
     module 化対象のファイルだけ変更・移動しても import 文が変更されなくて
     うまく読み込まれない問題があるということ。
     何故か rspec は通ったりするけど。

     まあその時は ~rails tmp:cache:clear~ して cache を消すか
     ~import-modules.js.es6.erb~ に適当に空行でも加えて cache を使われないようにしたら解決する。

**** router.js.es6, <APP_NAME>.js.es6, environment.js.es6 の ES6 Module 化
     https://github.com/mugijiru/ember-rails-todo-app/pull/11 でやったこと。

     サブフォルダのファイルを全部 module にしたら
     後は変更しないといけないファイルはこれぐらい。

     変更の流れは大体以下の感じ

     1. router.js.es6 をこれまでのファイルと同じように module 化
     2. environment.js.es6 も同様に module 化
     3. <APP_NAME>.js.es6 の module 化とそれに伴うファイル移動等

***** router.js.es6 をこれまでのファイルと同じように module 化
      https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/359520f6656920ac8ef3fe623d15f2368cc66a78

      この commit でやってることそのもの。

      拡張子を module.es6 に変更して中身を module っぽく書いて
      require される順番を最後に移動し、最後に他のファイルみたいに import してあげるだけ。

***** environment.js.es6 も同様に module 化
      実はこのファイルをまともに使ってなかったので PR では後ろに回したんだけど、
      多分ちゃんとやるならこのタイミングかなって。

      これもさっきの手順と同じ感じだと思う。
      require するタイミングは ~//= require ./todo-app~ の直前になる。
      そのタイミングになる理由はよく知らんけど
      ember-rails で generate したらそこに来るからそこでいいんだろ(適当)

      実際 import して使われるタイミングは application.js.es6 の中で明示的に import することになるので
      require_self するより前ならどこでも良さそうな気はする。

      あと、多分、古いスタイルに書き換える時に適当にやってたので
      そもそも古いスタイルでの environment の置き方が正しくなさそうな気もする。

      一応 https://guides.emberjs.com/v1.10.0/configuring-ember/ に

      #+begin_quote
      Note that the above code must be evaluated before Ember.js loads.
      #+end_quote
      と書いてるのでそれに従って対応してたつもりだけどね。

      ま、古いスタイルの正しいやりかたを必要としている人はいないだろうし
      新しい形式でちゃんと動けば良かろう。ちゃんと動くか知らんけど。

***** <APP_NAME>.js.es6 の module 化とそれに伴うファイル移動等

      https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/d3673bfa455906abd0ff6d31d1d3f4f083bd4a71
      の commit でやってることだけど、ここが結構まとめて色々やらないといけなさそう。

      <APP_NAME>.js.es6 を ES6 Module 化をするんだけど
      ここが一番色々書き変わるところ。

      事前に Namespace を用意する必要がなくなったので require_self を一番最後にしたり、
      ~import Application from 'ember-rails/application~ しておいて
      そこから extend して export して、みたいな。
      まあ [[https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/d3673bfa455906abd0ff6d31d1d3f4f083bd4a71#diff-7aa5fb21bec5b1e11d78f1b7c34b3b92f05b293d97a99ed2af713f81ea5dab82][ファイル]] を見た方が早いか。

      で、こいつを ES6 Module にすると ember-rails での自動 import が動くようになる。
      なので、事前に module 化していたファイルを全部本来の位置に戻した上で
      これまでお世話になってきた ~import-modules.js.es6.erb~ にさよならすることになる。
      ま、そいつは消しやすいように別ファイルに分離していたんだけども。

      あと当然 application.js.es6 も、
      他のファイルが全部 module 化された前提で書き換える必要がある。
      まあほとんど <APP_NAME>.js.es6 を import して create するだけなんだけど。

      以上でほぼ終わりだけど、
      不要になった modules フォルダを消して require_tree する処理を消すのを忘れずに。
      麦汁さんはそれを忘れて [[https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/0f90fda419f9c23f844ba2e53dc1c2fa2e9b5d51][commit を積むことになった]]

**** ここまでやると何ができるようになるか

     ember-rails で書いた上で最も最新の記述に変更できた状態となる。
     というわけで、これでようやく ember-cli-rails 移行する準備ができました! やったね!

     まあぶっちゃけ ember-cli-rails 移行と module 化を同時にやっちゃうという手もあるけど、
     1回1回の変更差分を小さくするには、バラバラがいいかなってことで分けてやっている。

     だって、そうじゃないと「はい変更の多い PR はリジェクト〜wwww」ってされかねない^^

*** DONE ember-rails でコンポーネントを共通ライブラリとして切り出す :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 10:45]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-extract-common-libs
    :END:

    ember-rails を使って1つの Rails アプリの上に
    複数の Ember.js アプリケーションを動かしていると
    各アプリで同じようなコンポーネントを使っていたり、
    あるいは同じようなコンポーネントが必要だというのに気付いて
    共通ライブラリとして実装したくなることがある。あるんだよ。

    というわけで、その共通化を2パターンでやってみた。
    2パターンというのは 旧来の書き方の場合と
    ES6 Module 対応版の場合とである。

    なおいずれのパターンもサーバへのデプロイはやってないので
    もしかしたらサーバ環境では動かないかもしれないがご容赦を。

**** 旧来版
     先に答えを出すと
     https://github.com/mugijiru/ember-rails-todo-app/pull/13
     に実装した通りである。

***** template からの呼び出し
      template で ~{{ember-libs/button}}~ と書いた場合に
      Resolver には ~component:ember-libs/button~ として解釈するように要求されるっぽい。
      これはソースからではなく、挙動的に確かめただけ。

***** コンポーネントの探索
      旧来の書き方の場合に探索に使われるのが GlobalsResolver というやつ。

      この GlobalsResolver というやつは [[https://github.com/emberjs/ember.js/blob/e2007b6ecb046fd06f6b43c381e8a1128914ad43/packages/%40ember/application/globals-resolver.js#L59-L76][コメント]] にも書かれてるように
      ~component:ember-libs/button~ と渡されたら、
      GlobalsResolver は ~EmberLibs.ButtonComponent~ として解釈するようになっている。
      つまり EmberLibs という名前空間の ButtonComponent を探しに行くようになっている。

***** 名前空間の定義
      というわけで、まずは [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-e1803bb0635866bc90975a1321dbfa6d20be59e76ec3d7b80c8acc4656f8af9fR6][ember-libs/ember-libs.js.es6]] に書いてるように

      #+begin_src js
      window.EmberLibs = Ember.Namespace.create()
      #+end_src
      と書くことで
      EmberLibs という名前空間を定義してやる。

      一応 ~ember-libs/ember-libs.js.es6~ では require の順番として
      ember はそこで定義している実装を使うので先に require して
      そのファイルで定義している名前空間を components で使うので components を require するより前に
      require_self をしている。

***** 共通コンポーネントの記述
      各コンポーネントはその名前空間の下に入るように書けばいい。
      例えば [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-9f9be147342dc470d8f0cba8a06a55a210550e01b22502bd6e0aff0d029ae38cR1][ember-libs/components/button.js.es6]] に書いてるように

      #+begin_src js
      EmberLibs.ButtonComponent = Ember.Component.extend()
      #+end_src

      というように書いてやれば動く。

***** config.handlerbars.templates_root の設定

      templates を ember-libs/templates に入れるので
      Rails 側の設定で ~config.handlebars.templates_root~ に ~ember-libs/templates~ を追加するのを忘れずに。
      ember-rails の設定例に従っていれば [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-c1fd91cb1911a0512578b99f657554526f3e1421decdb9e908712beab57e10f9R34][config/application.rb]] に設定があるはず。

***** 利用側の設定
      あとは [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-2cb7f9d0c761533d0e2b01e0b7e6f4a34529c7b52f9a13c7493b2629251bccd8R9][todo-app/application.js.es6]] に書いてるように
      この共通コンポーネントを使いたいアプリ側で

      #+begin_src js
      //= require ember-libs/ember-libs
      #+end_src

      としてやるだけでさくっと使えるようになる。

***** 他の type について
      試してないけど mixin や service ぐらいなら同じノリでいけるんじゃないかなと思ってる。
      model もいけそう。
      名前空間が変わるだけだし、その呼び出しも難しくないし、大体なんとかなりそう。

***** 余談: 名前空間を分けない場合

      上のようなやりかたをしているのは、名前空間を分けたいってのが先だったので、
      各アプリで名前空間を分ける必要がなければ、全部のアプリで

      #+begin_src js
      window App = Ember.Application.create()
      #+end_src

      とかしちゃって

      ~ember-libs/components/button.js.es6~ では普通に書く場合と同じように

      #+begin_src js
      App.ButtonComponent = Ember.Component.extend()
      #+end_src

      みたいにしておいて require したら ~{{button}}~ で使える。
      個人的には、名前空間が混ざるとどっちかが上書きされたりしそうで怖くて嫌だけど。

**** ES6 Module 対応版の場合
     最初に答えを出すと
     https://github.com/mugijiru/ember-rails-todo-app/pull/12
     で実装したやつ。

***** コンポーネントの探索
      ES6 Module で書かれている Ember Application では
      基本的に単一の名前空間しか持たないようである。
      また、使用される Resolver が [[https://github.com/ember-cli/ember-resolver/tree/v0.1.21][ember-resolver@0.1.21]] となっている。

      こいつは ~component:ember-libs/button~ と渡って来た時の解釈が GlobalsResolver と異なっている。
      この ember-resolver の場合は、アプリケーションの下の ~components/ember-libs/button~ を探しに行く。

      なのだけど今回はそんなところを探しに行って欲しくないので、
      regsiter を Ember.js で自動的に解決して対応してもらうのではなく
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-029812c538a995224fcf19bfa24f65558246c054aea77c95ec1f4a404b4f5256R1][ember-libs/ember-libs.module.es6]] に書いているように、
      自前で

      #+begin_src js
      application.register()
      #+end_src

      して対応することにした。

***** コンポーネントの register
      基本的には以下のように書いておけば Button コンポーネントは動くようになる。

      #+begin_src js
      import Button from './components/button';

      application.register('component:ember-libs/button', Button);
      #+end_src

      が、コンポーネントが増えていった際に全部そうやって書くのはアホらしい。
      というわけで、自動的に解決するようにした。

***** コンポーネントの auto register

      ES6 Module 対応して import している場合に ember-rails では実際はどんな形に transpile されるかというと
      どうやら requirejs の機能で読み込んだりしているらしい。

      で export されているファイルは ~requirejs.entries~ に含まれているので
      そこから必要なものを探し出して
      ~application.register~ に対し、解釈してほしい名前で渡してクラスを渡しておけば
      template で ~{{ember-libs/button}}~ とした時に require したクラスのインスタンスとして動いてもらえる。

      という感じで自動的に register する処理を [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-029812c538a995224fcf19bfa24f65558246c054aea77c95ec1f4a404b4f5256R4][メソッドにして]] おけば、
      利用側はそれを呼び出すだけでセットアップが済む

***** config.handlebars.templates_root の設定
      やはりこちらの場合も templates を ~ember-libs/templates~ に入れるので
      Rails 側の設定で ~config.handlebars.templates_root~ に ~ember-libs/templates~ を追加するのを忘れずに。
      ember-rails の設定例に従っていれば [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-c1fd91cb1911a0512578b99f657554526f3e1421decdb9e908712beab57e10f9R34][config/application.rb]] に設定があるはず。

***** 利用側の設定
      アプリ側では [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-97468a821d4c12c1b223617fba29257a5b1e00553a1b8e8f403ee99864756ebaR4][initializers/resolve-common-libs に書いている]] ように
      initializer で

      #+begin_src js
      EmberLibs.registerAll()
      #+end_src

      を叩くだけでいい感じに使えるようになる。

***** 他の type について
      試してないけど、component でやってみた所感。

      mixin はどうせ明示的に import して使うので関係なさそう。
      service は、component と同じやりかたでいけそうな気がする。
      model もいけそうなので user model を共通化するような用途がありそう。

      controller もいけそうだけどそれに付随する route からどう呼ばれるかが難しそう。

***** 余談: 他の方法について
      多分 EmberEngine とか EmberAddon の仕組みを使って
      似たようなことはできそうな気はする。

      だけど ember-rails で Engine や Addon を使うというのは
      それはそれでかなり大変かと思われるので今回はそれを動かすようなことはしてない。

      より正確にいうと、
      それしか方法がないかもと思って途中まで調べたけど、
      厳しそうだったので今回は上述の方法にしておいた。

**** 最後に

     旧来版と ES6 Module 対応版とで実装方法は異なるが
     どちらでも同じような使い勝手でコンポーネントを共通ライブラリとすることができることがわかった。

     両方のパターンが使えることがわかったので、
     ES6 Module 対応版への移行がまだでも躊躇せずライブラリを分割できそう。

*** DONE ember-rails でコンポーネントをサブフォルダに配置する :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 11:19]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-component-in-subfolder
    :END:
    Ember.js に限らずコンポーネントは増えてくると
    サブフォルダに分割して管理したくなるよね。
    ということでそのあたりの記事。

    これも、ES6 Module 対応版と旧来版の両方を書く。
    ES6 Module 対応版は何も考えることがないので、
    この記事は旧来版のためにあるようなものだけど。

**** ES6 Module 対応版の場合
     上に書いたように
     これは https://github.com/mugijiru/ember-rails-todo-app/pull/14 に実装してあるけど
     とっても簡単

***** component をサブフォルダに移動
      ~components~ の下に適当なフォルダを掘って
      その中に移動するだけ。

***** template をサブフォルダに移動
      ~templates/components~ の下に適当なフォルダを掘って
      その中に移動するだけ。

***** template からの呼び出し
      template, component をそれぞれ

      - template :: ~templates/components/hoge/fuga.hbs~
      - component :: ~components/hoge/fuga.module.es6~

      と配置した場合は
      ~{{hoge/fuga}}~ と書いて呼び出せばいい感じに動く。以上。

      こういう感じで動くように [[https://github.com/ember-cli/ember-resolver/tree/v0.1.21][ember-resolver@0.1.21]] が作られてるっぽいのでとても楽。

      Ember.js のドキュメントなどを見ている感じだと
      多分もっと新しいバージョンでも同じ感じで動くっぽい。
      というわけで Ember.js@3 にしても多分動きそうなので安心感がある。

**** 旧来版の場合
     これは GlobalsResolver の挙動のおかげでちょっと大変。

     と言っても
     https://github.com/mugijiru/ember-rails-todo-app/pull/15
     で実装してある。

     今回やりたかったことは、
     テンプレートとコンポーネントをサブフォルダに移動して扱えるようにすることなので、
     その実現方法を書いておく

***** template からの呼び出し
      ~{{hoge/fuga}}~ と呼び出した際に [[https://github.com/emberjs/ember.js/tree/v2.18.2/packages/ember-application/lib/system/resolver.js#L34][GlobalsResolver]] でどう解釈されるとかというと
      [[*ember-rails でコンポーネントを共通ライブラリとして切り出す][前の記事]] にも書いたように
      Hoge という名前空間の FugaComponent を探しに行くようになってるというのが前提。

***** component をサブフォルダに移動

      GlobalsRegister の解釈に合わせて
      FugaCompnent を Hoge 名前空間に所属させればいいので

      #+begin_src js
      Hoge.FugaComponent = Ember.Compnent.extend()
      #+end_src

      という形で定義しておけばいい。

      旧来方式だとファイル自体は components の中にあればファイル名も位置も何でもいいはずなので
      人間がわかりやすいように ~components/hoge/fuga.js.es6~ として配置したら良い。

      また、事前に Hoge という名前空間は必要なので
      ~components/hoge.js.es6~ とファイルで

      #+begin_src js
      window.Hoge = Ember.Namespace.create()
      #+end_src

      としておく。

      前回の共通ライブラリ切り出しと大体似たお話ですね。

***** template をサブフォルダに移動
      これは難しいことは何もなくて
      ~templates/components/<名前空間>/<コンポーネント名>.hbs~
      みたいに配置したら良い。

      つまり ~Hoge.FugaComponent~ の場合は
      ~templates/components/hoge/fuga.hbs~
      と置けばいい。

***** さらにネストさせたい場合
      試してないけど、
      [[https://github.com/emberjs/ember.js/blob/e2007b6ecb046fd06f6b43c381e8a1128914ad43/packages/%40ember/application/globals-resolver.js#L221][GlobalsRegister の実装]] を見ている感じだと、多分

      #+begin_src js
      window.Hoge = Ember.Namesupace.create()
      #+end_src

      #+begin_src js
      Hoge.Fuga = Ember.Namesupace.create()
      #+end_src

      #+begin_src js
      Hoge.Fuga.PiyoComponent = Ember.Component.extend()
      #+end_src

      にみたいな感じに名前空間をネストさせれば大丈夫そう。

**** 最後に
     前回の共通ライブラリ切り出しよりは簡単でしたね。

     ES6 Module 対応版では直感的にやるだけで終わるし、
     旧来版でも共通ライブラリと大体やること一緒というか、
     それよりも手順が少ないので、サブフォルダへの移動を先にやった方が良かったかも。

     あと、今回も両パターンでやってるので、
     ES6 Module 移行前にこちらを実施しても簡単な修正で対応できることがわかりました。やったね。

*** DONE ember-rails でユーザー情報を Rails から inject    :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 13:10]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-inject-from-rails
    :END:

    フロントエンドのフレームワークを使っていて、
    そのフレームワークで Server Side Rendering をしてない時に
    API 経由でデータ渡すよりも表示用の HTML 経由で直接データを渡したい時がある。

    ember-rails を使ってる時もそれはあって、
    今回は Haml 経由で Ember.js に情報を渡して表示する方法を書いてみた。
    もちろん旧来版と ES6 Module 対応版の両方で実装している。

**** 旧来版
     https://github.com/mugijiru/ember-rails-todo-app/pull/16 で実装したやつ。


***** おおまかな実装内容
      こちらは名前空間に Ember.js の外からアクセスできるので
      Haml 内に JavaScript を埋め込んで Ember に渡すというちょっと乱暴なことができる。

      今回は email を todo-items テンプレート内で表示したかったので
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/16/files#diff-69c2e4b0a6040f2873e963c79265340fd97c099e1ea1a7fbf579902259126e3fR1][Ember.js の呼び出し元の haml]] 内で

      #+begin_src js
      :javascript
        TodoApp.register('session:current-user', Ember.Object.extend({ email: '#{current_user.email}' }));
        TodoApp.inject('controller:todo-items', 'current-user', 'session:current-user');
      #+end_src

      と書いてみた。

      以下にもう少し詳細に書いてみる。

***** ユーザー情報の登録
      #+begin_src js
      TodoApp.register('session:current-user', Ember.Object.extend({ email: '#{current_user.email}' }));
      #+end_src

      という記述で JavaScript の中に Haml での Ruby のコード呼び出し機能を用いて
      email を EmberObject を継承したクラスにぶち込んでいる。

      正直 ~:javascript~ で書いて Ruby のコードを呼び出すのは結構乱暴だとは思うけど
      できちゃうのでやっちゃった。

***** コントローラへの inject

      アプリケーションに ~session:current-user~ として登録できたので、後はもう

     #+begin_src js
     TodoApp.inject('controller:todo-items', 'current-user', 'session:current-user');
     #+end_src

     として controller に inject することができる。

***** template での表示

      inject された controller の template で ~{{current-user.email}}~ と記述するだけで
      そのユーザーのメアドが表示される。以上。

**** ES6 Module 対応版
     https://github.com/mugijiru/ember-rails-todo-app/pull/17 で実装したやつ。

***** おおまかな実装内容
      こちらは旧来版とは違って名前空間は隠蔽されているため
      Haml で JavaScript を書いて埋め込むなんて荒技はできない。

      だけどまあそんなことをしなくても
      data 属性に情報を埋めておいて
      それを initializer で取得して使えばいいだけである。

***** Haml へのデータ埋め込み
      Haml の方では

      #+begin_src haml
      #todo-app{ data: { email: current_user.email } }
      #+end_src

      こんな感じにデータを埋めておく。
      それを Ember.js の initializer で取得して処理してあげれば良い。

***** initializer でのデータの取得
      まずはデータを

      #+begin_src js
      const currentUser = Ember.Object.extend({
        email: document.querySelector(application.rootElement).dataset.email
      });
      #+end_src

      という感じで取得して適当な変数に放り込んでおく。
      ま、大体普通の JavaScript なので何も難しいことはない。

***** アプリケーションへの登録
      上で取得したデータをアプリケーションから見れるように登録してあげる必要があるので
      以下のように ~application.register()~ でデータを登録する。

      #+begin_src js
      application.register('session:current-user', currentUser);
      #+end_src

***** controller への inject
      上に書いた感じで application に登録してしまえば、後は旧来版と同じように

      #+begin_src js
      application.inject('controller:todo-items', 'current-user', 'session:current-user');
      #+end_src

      という感じで設定できる。

***** template での表示
      あとは旧来版と同じく
      inject された controller の template で ~{{current-user.email}}~ と記述するだけで
      そのユーザーのメアドが表示されると。うん、簡単でしたね。

**** 最後に
     API を経由せずに Ember.js にデータを渡す方法が
     旧来版と ES6 Module 対応版の両方で書けることがわかったので、
     旧来版から移行しようとした時もすぐ書き直せそうで安心。

     ES6 Module 対応版の方は、
     ember-rails から ember-cli-rails とかに乗り換えてもそのまま使えそうだしね。

*** DONE ember-rails から ember-cli-rails へ               :@Rails:@Ember_js:
    CLOSED: [2021-03-06 土 17:05]
    :PROPERTIES:
    :EXPORT_FILE_NAME: migrate-ember-rails-to-ember-cli-rails
    :END:

    Ember.js 関係で最も書きたかった記事にやっと辿り着いた。
    表題の通りで、
    ember-rails から ember-cli-rails に置き換える、という記事です。
    多分長くなる。

    やったことはいつも通り [[https://github.com/mugijiru/ember-rails-todo-app/pull/18][GitHub の PR]] にしています。

    PR の Description で「Rails 側ではこうした」「Ember 側ではこうした」みたいに書いているので
    ここではある程度時系列に沿ったような書き方にしようかな。

    完全に時系列通りには書かないので、
    正確な時系列でどうしたか知りたかったら PR のコミットログを追ってください

**** アプリの前提

     これまで作って来た https://github.com/mugijiru/ember-rails-todo-app が前提になります。
     ざっくり内容を書くと

     - ember-rails で Ember.js 2.18 の環境を動かしている
     - Sprockets での ES6 Module 対応済
     - 現実世界の複雑さを持ち込むために敢えて以下の手法を導入
       - Embedded Ember App
       - Multiple で動かせる構成
       - 一部コンポーネントの共通ライブラリ化
         - ember-libs という名前で別フォルダに切り出している
       - Bootstrap の利用
     - 複雑さでは以下もありうるが面倒などの理由でやってない
       - i18n.js での多言語対応
       - コンポーネント以外の共通ライブラリ化

     という感じ。

**** ember-rails 用の JS のコードが読まれないようにコメントアウト
     https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/8dd44540bd7d352e497f87a9a12df5ad3cf6efbb
     のあたりのコミット。

     本当は後からやった手順だけど、
     ここで読まれてるコードが邪魔になるので
     先にコメントアウトしておく方が後の手順でハマらなくて済むので
     ここに置いといた。

     まあ実は ember-cli-rails のアプリが読まれるところで
     ember-rails が require されてなければいいだけなので
     application.js で require_tree とかをしなければ良かったりはする。

**** Docker 環境への ember-cli の導入
     Docker でアプリが動くようにしているので、
     ember-cli も Docker で動くようにしている。

***** Docker で最新 LTS の Node.js が使われるように設定

      ember-cli と直接は関係ないけど、Node.js は入れる必要があるのでやってる手順。

      とりあえず最新の LTS を入れておく。
      Ubuntu で普通に apt から入れると 10 系が入っちゃうので
      yarn の apt リポジトリを登録してそこからインストールする。

      #+begin_src Dockerfile
      RUN curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | apt-key add - \
      && echo "deb https://dl.yarnpkg.com/debian/ stable main" | tee /etc/apt/sources.list.d/yarn.list

      RUN apt-get update -qq && apt-get install -y nodejs yarn
      #+end_src

***** ember-cli を Global に導入

      ember-rails で動いているアプリは Ember.js 2.18.2 で動いているので
      ember-cli も 2.18.2 を導入する。

      #+begin_src Dockerfile
      RUN yarn global add ember-cli@2.18.2
      #+end_src

**** アプリの初期構築

     上記手順で導入した ember-cli を使って改めて Ember.js アプリを構築する。
     ゼロから作っておく方が、より ember-cli-rails に向いた形になるとの判断。

***** ember-cli で移植先のアプリの雛形を構築

      ~RAILS_ROOT/ember/todo-app~ に構築する。

      ember-cli-rails の README だと ~RAILS_ROOT/frontend~ に構築するように書かれているが、
      複数の Ember.js アプリを平等に扱える形にしたいのと
      Ember.js アプリのコード置場を ~RAILS_ROOT/frontend~ にしていると
      Ember.js から別のフレームワークに差し替えが決まって、その移行作業をしている間に

      - frontend に新しいフレームワークで構築しようと思ったら既に Ember.js がいた
      - 新しいフレームワークでの実装を修正しようと思って frontend 以下を探していて時間を潰した

      ということが起こりそうなので、フレームワーク名は明示しておきたいお気持ち。
      というわけで ~ember~ というフォルダの下に更にフォルダを掘っているが、
      この考え方、あまり合意を得られた試しはない。みんな移行は発生しないつもりなのかな。

      ま、とりあえず以下のコマンドを実行したら ~RAILS_ROOT/ember/todo-app~ に雛形が作成される。

      #+begin_example
      $ ember new todo-app --no-welcome --skip-git --yarn --dir ember/todo-app
      #+end_example

      なお、面倒なので ~docker-compose run~ とかは省略している。
      ここより下の部分でも同様に省略しているので、
      そのあたりは読みながら脳内で補完とかしてください。

****** オプションについて
       - ~--no-welcome~ :: どうせ後で消すファイルが作られるだけなので出す必要なし
       - ~--skip-git~ :: Rails アプリと同じリポジトリに作るので git init は不要
       - ~--yarn~ :: yarn を使い慣れてるからそれを指定。ただ ~yarn link~ に問題があるから ~npm~ を使う方がいいかも?
       - ~--dir ember/todo-app~ :: ember というフォルダの中に構築するので指定する必要あり

***** ember-cli-rails-addon の導入

      ember-cli-rails と連携して ember-cli app を動かす時には
      ember-cli app 側に [[https://github.com/rondale-sc/ember-cli-rails-addon][ember-cli-rails-addon]] を入れておく必要があるので、
      早い段階で追加しておく

      #+begin_example
      $ cd ember/todo-app && ember install ember-cli-rails-addon
      #+end_example

      これを入れておくと CSRF Token のことを意識しないで済むし、
      ファイルを更新するだけで Rails から読めるように Ember.js app を build してくれたりする。
      というか、入れてないとそれらがうまく動かなくてハマる。

***** active-model-adapter の導入

      [[https://github.com/ember-data/active-model-adapter][active-model-adapter]] は
      ActiveModelSerializer の出力をいい感じに Ember.js で扱えるようにする Addon で
      ember-rails でも使われている。

      というわけでこいつも Rails でいい感じに Ember.js を使うためには必要なので先に入れておく

      #+begin_example
      $ cd ember/todo-app && ember install active-model-adapter
      #+end_example

**** ember-cli-rails の導入と設定

     ここは Rails 側の作業。
     ひとまず ember-cli-rails の導入に留め、
     ember-rails は一旦そのままにしておく。

***** ember-cli-rails の導入
      これは単に Gemfile に記載して ~bundle install~ を叩くだけである

      #+begin_src ruby
      gem 'ember-cli-rails'
      #+end_src

      #+begin_example
      $ bundle
      #+end_example

***** config/initializers/ember.rb で ember-rails の設定

      ember-cli-rails で generate コマンドが用意されているので
      まずはそれでファイルを生成する

      #+begin_example
      $ rails generate ember:init
      #+end_example

      これで ~config/initializers/ember.rb~ が作られるの。
      初期状態は以下の通り。

      #+begin_src ruby
      EmberCli.configure do |c|
        c.app :frontend
      end
      #+end_src

      それに変更を加えて、以下のようにする

      #+begin_src ruby
      EmberCli.configure do |c|
        c.app :todo_app, name: 'todo-app', path: Rails.root.join('ember', 'todo-app'), yarn: true
      end
      #+end_src

****** 引数について
       - 第一引数 :: あとで mount する時に使う値
       - name :: ハイフン繋ぎにしたかったので指定しているが、多分なんでもいい
       - path :: ~ember/todo-app~ に構築しているのでそれを見てもらえるように指定
       - yarn :: yarn を使い慣れてるので指定。ただ yarn link がうまく動かないのでやめた方がいいかも

***** config/routes.rb で Ember.js App を Mount

      Embedded Ember.js App というわけで
      Controller を自前で用意するので、contoller としてそれを指定する。

      #+begin_src ruby
      mount_ember_app :todo_app, to: '/ember_cli_todo_items', controller: 'ember_cli_todo_items', action: 'index'
      #+end_src

***** Controller 等の用意
      移植途中で元のアプリに戻せなくなるのは移行失敗時のリカバリを考えると嫌なのと
      元の挙動を確認したくなった時のために
      元の PATH で動く状態にすぐ戻せるようにしておきたい。
      というわけで別の PATH を用意して、ember-cli で構築したアプリはそこで動くようにする。

      #+begin_example
      $ rails g controller ember_cli_todo_items index
      #+end_example

      あとは ember-rails 実装での Controller, View を参考にしたりして以下の感じに。

****** Controller
       特にサーバから何かを View に渡す必要はないので基本的に空っぽ。

       #+begin_src ruby
       class EmberCliTodoItemsController < ApplicationController
         def index
         end
       end
       #+end_src

****** View
       rootElement を用意して、そこに initializer に渡す data 属性を置いておく。

       さらに ember-cli で生成する JS/CSS が読まれるように設定する。
       (今回 CSS は書かないけど……)

       #+begin_src haml
       #ember-cli-todo-app{ data: { email: current_user.email } }

       %base{ href: '/ember_cli_todo_items/' }
       = include_ember_script_tags :todo_app
       = include_ember_stylesheet_tags :todo_app
       #+end_src

       ~%base~ は Ember.js のアプリケーションを動かす PATH に合わせる必要があるのと
       最後の ~/~ が抜けていると script や stylesheet で正しく PATH 解決できないので注意。

       [[https://github.com/seanpdoyle/ember-cli-rails-assets][ember-cli-rails-assets]] の README を見ていると
       include_ember_script_tags とかに追加の引数で
       ~prepend: '/ember_cli_todo_items/'~ とか書いていれば ~%base~ は使わなくて良さそうだけど
       まだ試してはいない

**** ember-cli で作ったアプリが Rails 上で動くようにする
     Rails 側の設定はここまでで完了しているはずなので
     次は ember-cli 側の設定を進めて Rails 上で動くようにしていく。

***** config/environement.js の設定
      まず config/environment.js で以下を指定している

      #+begin_src js
      modulePrefix: 'todo-app',
      rootURL: '/',
      locationType: 'hash',
      #+end_src

      rootURL は ember-cli-rails の README 通りに設定していると
      ~/ember_cli_todo_app~ になりそうだが
      それを指定すると Ember.js App が読まれた時に URL が
      ~http://localhost:3000/ember_cli_todo_app/ember_cli_todo_app~ というように
      ~ember_cli_todo_app~ が二重に表示されてしまう。

      ちゃんと調べられていないが、恐らく README の記載では SPA として Ember が動く想定であって、
      ~include_ember_script_tags~ で読み込まれる Embedded App という想定ではないからと思われる。

      locationType は多分 hash にしておく方が
      ember-rails からの移行だと URL が変わらなくて良さそう、
      と思いつつ、深い PATH とかにしてないからか検証はできてない

***** app.js の設定
      あとは app.js の方でも config/environemt から読むようにしたり
      rootElement を指定したりしている。

      rootElement は config/environment で指定して、
      app.js ではそれを利用するのが正しい気はするが、一旦放置。

      #+begin_src js
      const TodoApp = Application.extend({
        rootElement: '#todo-app',
        modulePrefix: config.modulePrefix,
        podModulePrefix: config.podModulePrefix,
        locationType: config.locationType,
        rootUrl: config.rootUrl,
        Resolver
      });
      #+end_src

**** アプリの移植

     これまでの手順ではとりあえず ember-cli で構築した空っぽの Ember.js アプリが
     Rails の指定した PATH 上でとりあえず動くことを主眼に当ててやってきている。

     ここからはようやく、既存アプリの実装の移植。
     いくつかの段階に分かれるから、ここからも長いんだけどね。

***** 共通化してない機能のみで起動するようにする
      ember-libs というフォルダに切り出している部分までまとめて対応しようとすると
      えらく面倒なので、
      そのあたりを呼び出している部分はコメントアウトなどで呼び出されないようにして、
      とりあえず最低限の表示がされる程度を目指して移植するフェーズ。

      やってることは
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/3c31b5bcf86d68ac5db0eca9bb4af410df31c2f1
      のコミットが全てである。

      ざっくり説明すると

      - ember-rails で作っていた adapter, component, controller, initializer, model, route, template 等を ember-cli で作ったアプリの適切なディレクトリに配置
        - router.js は ember-cli 自動生成の雛形に必要な部分だけ移植している
        - adapter は ActiveModelAdapter を active-model-adapter addon から import するように変更している
      - 共通ライブラリに持って行った component の呼び出し部分をコメントアウト

      という感じ。
      これをすることで、不完全ながらも元のアプリと同じものが動くようになる

      ちなみにもっと複雑なアプリだと mixin を使っていたりなどするが
      それもテキトーに読み込まれないようにするなどで対処したらなんとなーく動く感じになるはず。なんとなーく。

      そうそう。ember-cli 対応することで各ファイルの単体テストなんかを書けるようになってるはずだけど
      元々そんなものを書いてないので、今回もそこまで頑張る必要はないと判断して
      フロントエンドのテストは一切書いていません。自動生成されたファイルはそのまま追加しているけど。

      一応、動作保証は system spec である程度担保しているつもり。
      ember-rails の時はそこでしか保証してないしね。

***** 共通ライブラリの Addon 化

      上までの段階だと共通ライブラリにした部分が全然動かないので、
      当然それを動く状態に持って行く必要がある。

      で、その際には、共通ライブラリを addon として構築し直すことをオススメする。
      なぜなら、なんか無理やり自前の仕組みで動くようにするより
      公式に提供されてる仕組みに乗っかる方が後々楽そうだからだ。

      ember-rails で動かしていた時に自前で解決していたのは
      ember-rails だと addon がサポートされてないからというだけの理由だしね。

      Addon 化の手順は大体以下の感じ

      1. ember-cli で Addon を generate
      2. 共通ライブラリのコンポーネントを Addon に移植
         - もし共通ライブラリに mixin とかも作っていたら同様に移植すること
      3. Addon をアプリ側で使えるように変更

      なお今回の手順では App と同様に Addon のテストを書く、みたいな丁寧な暮らしはしていない。
      元々書いてないんだし、そこまで頑張る必要もないという判断。

      あとやってることは [[https://cli.emberjs.com/release/writing-addons/intro-tutorial/][Addon 作成のチュートリアル]] に書いていることをベースにしている

****** ember-cli で Addon を generate
       https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/4d6713abfbed3217d65f7382e1f46d341c11d6aa
       でやっていることである

       #+begin_example
       $ cd ember && ember addon my-components --skip-git --yarn
       #+end_example

       というように適当な名前の Addon を作ってるだけ。

****** 共通ライブラリのコンポーネントを Addon に移植
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/cde30b30727d6eb9507b835d009d85759ddff5ee
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/4ad2f8a59ccc846a63e6ff31c8f8b53df81d8e42
       - https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/30439f21f0659044bb4d2ea80ce68a2f8e0011b7

       あたりでやってる作業。

       実際の作業では1つ目を移植してみた段階で、
       動作確認のためにアプリ側で Addon が使えるように設定していたりする。

       ちなみに ember の addon は
       app/components のファイルから addon/components のファイルを import してやるみたいなお作法がある。

****** Addon をアプリ側で使えるように変更
       まずは上の手順で作った my-components という addon を
       App 側で読み込めるように package.json の dependencies に以下を書き加える

       #+begin_src json
       "my-components": "link:../my-components"
       #+end_src

       ember-cli の公式ドキュメントだと
       「yarn link を使う」というように書いているが
       それだとうまくいかないみたいな Issue が何個か立っているので
       ドキュメント通りのやりかたは諦めて、それらの Issue の中に書かれている方法を選択した。

       npm link だとうまくいきそうな雰囲気もあるので
       yarn を使わず npm link にしておけばいい可能性はある。未検証。

       まあそれらは置いといて、とにかく Addon が使える状態になったら
       各コンポーネントでコメントアウトとかで読めなくしていた
       共通ライブラリの呼び出しを元に戻したり記述を直したりして、
       元のように動くようにしましょう。

***** ember-bootstrap の導入と bootstrap を使った機能を移植
      ここまでやって、麦汁さんは「わーい動いた〜」と思っていたけど
      ボタンとかをクリックしてみると、Bootstrap 関係のやつが動かない。

      そう。元の記述のままだと Bootstrap 関係のやつはメソッド呼び出しでエラーになって動かないのです。
      というわけでそれらも動くようにしないといけない。

      というところで、どうやるのが手っ取り早いかというと
      [[https://github.com/kaliber5/ember-bootstrap][ember-bootstrap]] という Addon が転がっているので
      それをインストールして使うように変更するのが多分手っ取り早い。

****** ember-boostrap のインストール・初期設定
       最新版は ember-cli-rails@2.18.2 をサポートしていないので3系を使う必要がある。

       #+begin_example
       $ cd ember/todo-app && ember install ember-bootstrap@3.1.4
       #+end_example

       その上で、元々使っている Bootstrap のバージョンに合わせて
       ember-bootstrap でも3系が使われるように設定する。

       #+begin_example
       $ cd ember/todo-app && ember generate ember-bootstrap --bootstrap-version=3
       #+end_example

****** Bootstrap を使ってる機能の移植
       https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/22a3bff502ce993c2f2288623b061a4f38652a29
       でやっていることである。

       基本的には、自前で bootstrap 用に DOM を組み立てていたところを
       ember-bootstrap の Modal コンポーネント用に書き換えて、
       開いたりするための挙動を修正するだけである。

       ember-boostrap の公式ドキュメントでは Handlebars の書き方が
       ~<BsModal>~ みたいになっていて
       3.4 以降でサポートされた Angle Bracket 方式の表記になっているが、
       ~<>~ は ~{{}}~ に置き換えて
       PascalCase を snake-cake にしたりするぐらいで動くので、
       落ち着いて移植しよう。

***** 既存の system spec が新しい PATH で動くことを確認
      ここまでやると、全機能を手動で確認できる状態になってるので
      既存の system spec がアクセスするポイントを
      新しく作ったアプリの方に変更しテストが通ることを確認すると、
      ちゃんと移植できたんだなって安心できる

      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/0c59057ec458edb7cda0febd15585dfc0a916bc1

**** 元の PATH で動くようにする
***** 元の PATH への再移植
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/334ce5052564a1499de03fb5a6630af3a339af21
      でやっていること。

      1. EmberCliTodoItemsController と TodoItemsController に移植
      2. app/views/ember_cli_todo_items/index.html.haml を app/views/todo_items/index.html.haml に移植
         - rootElement に使う ID も ~todo-app~ に変更
         - ~%base~ の href 属性も ~/todo_items/~ に変更
      3. resources :ember_cli_todo_items を削除
         - 同時に controller, view も消す
      4. mount_ember_app で ~to~ と ~controller~ の指定を変更
         - ~to~ を ~/todo_items~ に変更
         - ~controller~ を ~todo_items~ に変更
      5. Ember.js 側で rootElement を ~#todo-app~ にする

***** テストの PATH を戻す
      これは
      [[*既存の system spec が新しい PATH で動くことを確認][既存の system spec が新しい PATH で動くことを確認]] でやったことを revert して
      テストが通ることを確認したら OK
**** ember-rails 関連の削除
***** ember-rails 用のコードの削除
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/138ac7b8a76ec0f299edb2d626c9252927647229
      でやってるように
      app/assets/javascripts の下にある
      ember-rails 関連のコードを全部消すだけ。

***** ember-rails 用の設定を削除
      https://github.com/mugijiru/ember-rails-todo-app/pull/18/commits/9e036017b7ebee1a84b6f6847d5079a61ca5177c
      でやってるように

      - ~config/application.rb~
      - ~config/initializers/assets.rb~

      の中に ember-rails のために書いた設定を丸っと消しましょう。もう不要なので。

***** ember-rails 及びその関連 Gem と決別
      設定も消せたら ember-rails, ember-source も要らないので
      さっくり Gemfile から消して bundle install し直しましょう。イエイ。

**** GitHub Actions の修正
     あとはやり残しとしては
     CI でもちゃんとテストが通るようにすること。

     このプロジェクトでは GitHub Actions を使ってるので
     そのワークフローを修正する

***** 最新 LTS の Node.js を使うようにする
      Dockerfile のところでもやりましたね。同じようなことをしましょう。
      とは言っても setup-node という action が公式に提供されているし
      [[https://docs.github.com/ja/actions/guides/building-and-testing-nodejs][公式ドキュメント]] もあるので、それに従って設定するだけで使えるようになる。

      #+begin_src yaml
      - name: Use Node.js
        uses: actions/setup-node@v1
        with:
          node-version: 14.x
      #+end_src

***** ember-cli をインストール

      これも似たようなことを Dockerfile でやってるので同じ感じに。

      #+begin_src yaml
      - name: install ember-cli
        run: yarn global add ember-cli
      #+end_src

***** Ember Addon 及び Ember App で yarn install

      こちらも依存を解決してやる必要があるので。

      #+begin_src yaml
      - name: Setup Ember.js Addon
        run: |
          cd ember/my-components
          yarn
      - name: Setup Ember.js App
        run: |
          cd ember/todo-app
          yarn
      #+end_src

      ここまでやると
      GitHub Actions でもテストが通るし
      普通に使えるようになる。やったね。

**** 最後に

     以上の手順で ember-rails から ember-cli-rails への置き換えができます。

     現実世界のアプリケーションはこのケースよりもっと複雑でしょうけども、
     やってやれないことはないはず。

     それに ember-cli が使えるようにしておかないと
     3系に移行ができないし、つまり、サポート切れのフレームワークを使い続けることになるので
     もしまだ ember-rails のアプリが残っていたら頑張ってやっていきましょ。
     別フレームワークに置き換えるよりは労力はかからないはずですし。

*** DONE Ember.js の共通コンポーネントの NPM への分離      :@Rails:@Ember_js:
    CLOSED: [2021-03-24 水 13:04]
    :PROPERTIES:
    :EXPORT_FILE_NAME: my-ember-libs-to-npm
    :END:

    相変わらず Rails における Ember.js 関連で遊んでいます。

    今回の記事で書くのは
    「Ember.js Addon を別リポジトリに分離して NPM パッケージにして利用する」
    なんだけど、
    後追いで出す「分離したリポジトリを Gem としても使えるようにし ember-rails 環境で動かす」
    という感じに記事の前振りです。

    本当は1つの記事にしたかったけど記述量が増えたから分割……。

**** 目的

     なんでこんなことをしているかというと
     「単一ソースで ember-cli にも ember-rails にも対応したい」
     「じゃあ NPM と Gem で公開してインスコしたらいいんじゃね」
     という考えから。

     というのも、
     この一連の記事は ember-rails から ember-cli-rails に
     徐々に移行していく手段を確立することが目的なので、
     1つの Rails の中に複数の Ember.js アプリがあって
     ember-rails と ember-cli-rails が混在している状況も有り得るかなあと。

     そういう時に、
     共通コンポーネントは単一ソースで使いたいよね〜と思って
     両対応ができるようにしてみている。

     まあ今回は ember-cli-rails だけの対応なんだけども。

**** 実践

     ember-cli-rails に移行した時に
     元々 ~RAILS_ROOT/app/assets/javascripts/ember-libs~ というところに
     共通コンポーネントとして置いていたファイル群を
     ~RAILS_ROOT/ember/my-components~ というところに
     Ember.js のアドオンという形で設置していました。

     正直そのままの方が、同一リポジトリなので改修とかしやすいんだけど
     「他のプロジェクトでも使いたい」
     といった時には分離も必要になるかなと。
     まあ今回の目的は別のところにあるけども。

***** 従来の実装を ember-components に移植

      https://github.com/mugijiru/ember-components/commit/847981e9732385d08db4f5f703813196622b80d2

      でやっていること。

      基本的には、元々のソースを addons 以下に置いているだけ。
      なんとなく、コンポーネントの prefix を my- から mg- に変えてるけど。

      あとは ember-cli-htmlbars を dependencies にも移動する必要あり。

      https://github.com/mugijiru/ember-components/commit/922d1f7ed5f6b3372b1d1551792f4e9739f5b1e3

      他にも [[https://github.com/mugijiru/ember-components/commit/30b3257227dab623c86dedfab032b85f32414e42][Docker で動かせるようにしたり]]
      [[https://github.com/mugijiru/ember-components/commit/34e81e2905e32dd2878b95fb9d5c7eb3b3a0b463][GitHub Actions でテストできるようにしたり]]
      ちょっと細かい修正をしたりしている。

      ここまでの差分は
      https://github.com/mugijiru/ember-components/compare/bbaf38aa0f6c99ebbc7e0cb7ee5ac2c201706bc6...34e81e2905e32dd2878b95fb9d5c7eb3b3a0b463
      で確認可能。

***** GitHub Packages の NPM Package の公開

      まず [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#publishing-a-package][パッケージを公開する]] に従って以下の変更をしている。

      パッケージ名を ~@mugijiru/ember-components~ にしたり、

      #+begin_src json
        "name": "@mugijiru/ember-components",
      #+end_src

      publishConfig の registry に GitHub Packages の URL を入れることでそこで公開できるようにしている。

      #+begin_src json
        "publishConfig": {
          "access": "restricted",
          "registry": "https://npm.pkg.github.com"
        },
      #+end_src

      access は GitHub 側の記載は何もないが
      https://tech.plaid.co.jp/npm-private-registry-to-github-packages-registry/
      を参考にして restricted にすることで、許可された人だけが使えるようにしている。

      今は公開リポジトリにしているから public でもいい気もするけど、
      実装当時はより業務でやりそうな雰囲気にしたかったので、
      非公開リポジトリかつ限定的な公開で進めていたので、このようになっている。

      さらに、今後 GitHub Packages に複数パッケージ公開するかもしれないので
      [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#publishing-multiple-packages-to-the-same-repository][同じリポジトリへの複数パッケージの公開]] に従って registory を指定したりしている

      #+begin_src json
        "repository": "git://github.com/mugijiru/ember-components.git",
      #+end_src

      その上で
      https://github.com/mugijiru/ember-components/blob/main/.github/workflows/release.yml
      のようなワークフローを用意すると
      Tag を打って push して
      GitHub 上でそのタグを使って Release を作成すると
      NPM Package として公開されるようになっている。

      上にも出した https://tech.plaid.co.jp/npm-private-registry-to-github-packages-registry/ を真似すると
      もっとスマートな感じになりそうだけど、一旦これでいいやってなってる。

***** 公開したパッケージを利用する

      https://github.com/mugijiru/ember-rails-todo-app/pull/48 の PR でやったこと。

      元々は ~RAILS_ROOT/ember/my-components~ に置いていたやつを NPM Package にしているので
      my-components 関連のやつをさっくり消してあげている。

      具体的には ~ember/my-components~ は全部消して
      package.json の devDependencies に入れていた
      ~"my-components": "link:../my-components"~ を削除している。

      今思ったけどこれ devDependencies だと多分 production 環境だと動かなかったな。
      まあ 2.18 なので公開する気がゼロだったからすっかり気付かなかったんだけど。

      まあそれは置いといて
      公開したパッケージを入れるため dependencies に以下のように記述する。

      #+begin_src json
        "dependencies": {
          "@mugijiru/ember-components": "^0.0.1"
        },
      #+end_src

      あとはプライベートなパッケージを入れられるように
      ~RAILS_ROOT/ember/todo-app/.npmrc~ に以下のような設定を入れている。

      #+begin_example
      @mugijiru:registry=https://npm.pkg.github.com
      #+end_example

      この設定は [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#installing-a-package][パッケージをインストールする]] の通りだとなんかうまく動かなかったので
      [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages#installing-packages-from-other-organizations][他のOrganizationからのパッケージのインストール]] のやり方を採用している。
      あとでまた検証した方がいいかもなあ。。。

      それと [[https://docs.github.com/ja/packages/guides/configuring-npm-for-use-with-github-packages][GitHub Packages への認証を行う]] に従って

      #+begin_example
      //npm.pkg.github.com/:_authToken=${NPM_TOKEN}
      #+end_example

      としている。
      NPM_TOKEN には GitHub のパーソナルアクセストークンが入るので環境変数にしている。

      なので GitHub Actions で CI を回す際のパッケージのインストール時に

      #+begin_src yaml
      env:
        NPM_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }}
      #+end_src

      みたいに環境変数に PAT を入れてあげる必要あり。

      他には、これまた公開したパッケージを使う上で本質的ではないんだけど、
      移植した際に ~my-button~ から ~mg-button~ みたいに全部
      ~my-~ prefix だったのを ~mg-~ prefix にしているので
      利用箇所でそれらの修正の必要あり。
      命名を適当にやってたのでここでそれが仇になってる。つらい。

      以上で GitHub Packages に NPM として公開した Ember.js の Addon を
      ember-cli-rails で使えるようになりますよっと。
      正直 NPM とかに慣れてる人ならさっくりできそうな内容。。。

      まあ Ember.js の Addon も実際は NPM Package なので
      普通に NPM Package として公開するだけで使えたりするってだけですね。
      .ember-cli-build.js を活用したらまたちょっと話は違うはずだけど
      今回のはそこまでのやつじゃないし……。

*** TODO org-agenda を活用し始めた                              :@Emacs:@org:
    :PROPERTIES:
    :EXPORT_FILE_NAME: try-org-agenda
    :END:

    昨年から org-mode をもっと活用していこうということで、
    org-clock を使い始めたり org-pomodoro を導入したり org-habits を設定してみたりしている麦汁さんです。

    org-mode は機能が豊富過ぎてマジで何が出来るのか全貌を把握し切れてないのですが、
    そんな中で、やっぱり全然把握できてなくて使ってなかった機能の1つが org-agenda ってやつ。

    なんかうまく使うと、予定を組んでたり締切を設定していたりするタスクが一目瞭然になって
    お仕事などが捗るという素敵な機能らしいのだけど、
    どうもイマイチ使い方がわからなくて放置していました。
