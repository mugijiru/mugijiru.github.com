#+TODO: TODO(t) | DONE(o)
#+HUGO_BASE_DIR: ./
#+HUGO_SECTION: ./
#+title: 麦汁三昧
#+author: mugijiru

* 麦汁三昧
** DONE About
   CLOSED: [2020-12-20 日 11:59]
   :PROPERTIES:
   :EXPORT_FILE_NAME: about
   :END:

   この Web サイトは Web プログラマである麦汁の個人サイトです。

   気が向いたらブログ記事を更新したりするはず。

** DONE Profile
   CLOSED: [2020-12-20 日 12:15]
   :PROPERTIES:
   :EXPORT_FILE_NAME: profile
   :END:

   都内で Ruby on Rails と Vue.js を使った Web アプリケーションを開発している Web プログラマ。
   一部インフラ(AWS)もかじっている。

   最近は実装よりも、仕様策定や全体の進捗管理、調査、その他雑用をしていることが多い。

   好きなエディタは Emacs。サブで Vim も使っている。

   1983年生まれ。沖縄出身。

*** 経歴
    - 2009年 :: 沖縄の IT ベンチャー企業に就職しWebプログラマとして活動
    - 2012年 :: 別の沖縄の IT ベンチャー企業に転職し引き続きWebプログラマとして活動
    - 2016年 :: 都内 IT ベンチャー企業に転職しWebプログラマとして活動
    - 現在   :: リードエンジニアとして活動中

*** SNSなど
    - Twitter :: [[https://twitter.com/mugijiru][@mugijiru]]
    - GitHub :: [[https://github.com/mugijiru][mugijiru]]
    - 旧Blog :: [[http://mugijiru.seesaa.net][麦汁三昧]]

** Blog
   :PROPERTIES:
   :EXPORT_HUGO_SECTION: posts
   :END:
*** DONE Hugo 始めました                                              :@雑記:
    CLOSED: [2020-12-20 日 15:22]
    :PROPERTIES:
    :EXPORT_FILE_NAME: starting-hugo
    :END:

    Hugo はなんか Emacs 界隈で流行ってるし、
    自分のサイトだっせーなーって思ってたので
    Hugo を使って、公開されてるテンプレートを適用して
    Web サイトを再構築してみることにした。

    <!--more-->

    他の静的サイトジェネレータもちょっと検討したけど
    機能面とかも考慮した上で Hugo がいいかなって。
    主な理由は「流行ってるから」ですが。
    ほら、流行りに乗りたいじゃん。ちょっと乗り遅れてる気もするけど。

    今、とりあえず作ってる最中なんだけど、
    つい BBS とかチャットとかリンク集とか置きたくなる。
    90年代または2000年代脳である。
    お絵描き BBS も置いたろうかって気持ちになる。
*** DONE 新年明けましておめでとうございます                           :@雑記:
    CLOSED: [2021-01-02 土 20:31]
    :PROPERTIES:
    :EXPORT_FILE_NAME: happy-new-year-2021
    :END:

    新年明けましておめでとうございます。麦汁です。
    昨年の終わり頃、世間では AdventCalendar で賑ってる頃に、
    ふと「サイトのリニューアルしたいなあ」なんてことを思って、
    リニューアルに着手しましたが、ようやくそれが実りそうです。

    <!--more-->

    なんでそんなことをしてるかというと
    前の記事 [[*Hugo 始めました][Hugo 始めました]] でも書いたように
    「自分が作ったサイトだっせー」ってのが1つあります。

    それを構築した時には
    「デザインとかも全部自分でやっちまおう」ということで全部やろうとしていたのですが
    デザインセンスが壊滅的だったとか時間がろくに取れないとかやる気が他に吸われていったとかで
    イマイチなまま放置していました。よくないですねえ。

    あと、そことは別にブログサービスを借りて使ってるのですが
    そっちはそっちで更新がだるいなってのもあって
    リニューアルと同時に今後のブログ更新はこっちにしてしまおう、というのもあったりします。

    Hugo でブログもやってしまう方が [[https://ox-hugo.scripter.co/][ox-hugo]] も使って記事を書き出せるので
    org-mode 使い的には幸せになれそうですし。

    あとは折角リニューアルしたんだからモチベーションが続くことを願っています。

    というわけで 2021 年の抱負は「月に2回はブログを更新する」とします。

    結構、緩めな抱負ですが、仕事じゃないのでこのぐらいの方が良かろう……。
*** DONE browse-at-remote を導入した                                 :@Emacs:
    CLOSED: [2021-01-23 土 23:18]
    :PROPERTIES:
    :EXPORT_FILE_NAME: add-browse-at-remote
    :END:

    仕事中、プルリクのレビューをする際に、
    「ここのコードがこんな感じになってるから〜」みたいな感じで
    既存コードへのリンクを張ることがちょくちょくある。

    そういうことをする時、まずそもそも差し示したいコードを確認するんだけど
    その時は Emacs の中で探す方が早い。
    で、探して確認するまではいいんだけど、そこから GitHub 上のコードへのリンクを取得しようとするとちょっと面倒。

    これまでは、GitHub のリポジトリのトップからディレクトリを辿って行って
    当該コードを再度探していました。めんどくさいねっ。

    というわけで解決する手段を探していて
    最近導入したのが [[https://github.com/rmuslimov/browse-at-remote][browse-at-remote]] というやつ。

    こいつを入れてる状態で、GitHub のリポジトリに突っ込んであるコードの上で
    ~M-x browse-at-remote~ を実行すると
    GitHub でのリポジトリでのコードの位置でブラウザを開いてくれる。

    コードの上でと書いたけど、リージョンを選択していればその範囲が選択された状態で実行すると
    選択した行がハイライトされた状態で開いて便利。

    その状態から GitHub 上で ~Copy permalink~ をしておいて
    PR のコメントにコピーしたリンクを貼り付けるとコードも表示されて便利。

    で、結構よく使うコマンドとなったので
    Hydra から即呼び出せるようにしてある。

    Global に使うコマンドを突っ込んでる Hydra は key-chord で ~jk~ を叩くと呼べるようにしていて
    その中で ~B~ を叩けば browse-at-point が呼ばれるようにしてある。

    というわけで、導入と Hydra の設定を追加しているプルリクが以下になります。
    https://github.com/mugijiru/.emacs.d/pull/205

    という使い方をしているけど、
    実は似た機能を提供している [[https://github.com/sshaw/git-link][git-link]] で ~git-link-use-commit~ のフラグを立てておいて
    他にもいくつか設定を入れたりしたらもっといい感じのことができるのかもしれない。
    今度試すか……。

*** DONE 2021年にもなって ember-rails で新規アプリを書いてみてる :@Rails:@Ember_js:
    CLOSED: [2021-02-13 土 01:15]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-in-2021
    :END:

    少し思うところがあって、
    2021 年になったというのに [[https://github.com/emberjs/ember-rails][ember-rails]] を使って新規で Web アプリを書いている。

**** ember-rails とは?

     ember-rails は
     Ember.js という Web フロントエンド MVC なフレームワークを
     Rails といい感じに連携してくれて快適な Web アプリケーション開発体験を提供してくれるものであった。

     過去形なのは、ember-rails は Rails3 とか 4 とかの時代に主に使われていて
     既にメンテナンスされてないのと、
     今はそれよりも良い [[https://github.com/thoughtbot/ember-cli-rails][ember-cli-rails]] というのがあるから。

**** 今 ember-rails を使うと何がつらいか

     色々つらい。

***** まずメンテナンスが止まってる
      なので Rails 6 で動くかがわからない。
      多分、試している人はいないし、自分もそこまで試す気力はない。

***** Ember.js のサポートが 2.18.2 までとなっている。
      より詳細に話すと
      ember-rails が依存している Gem である ember-source で
      本当は 3.0.0.beta.2 まで出てるんだけど、β版のことは無視する。
      https://rubygems.org/gems/ember-source/versions/2.18.2

      で、その 2.18.2 は既にサポートされてないバージョンである。

      サポートされてないバージョンを使うのはセキュリティ面でもまずいし
      もはや情報もあまり落ちてないので苦行である。

      Ember.js 公式サイトのドキュメントが
      過去のバージョンのものも残されているのでそれを頼りにするしかない。
      というか公式で残しててくれてありがとう。それがないと何もできないよ。

***** ember-rails だと Ember.js の addon が導入できない
      例えば Handlebars でロジックを書く上で
      とても基本的な比較用のヘルパーを提供してくれる [[https://github.com/jmurphyau/ember-truth-helpers][ember-truth-helper]] が使えない。
      これが使えないはめっちゃ不便で、
      それをなんとかするために同じようなコードを自前で用意するハメになる。

      他にも [[https://github.com/ember-community-russia/awesome-ember][ember-community-russia/awesome-ember]] に載っている色々なものが使えないわけだ。
      つらいどころか悲しくなってくる。

***** 自動テストが書けない
      Ember.js は QUnit で自動テストができるようになっているのだが
      ember-rails だとそれも使えない。
      すなわちフロントエンドのコンポーネントの単体テストが書けないのである。

**** それでも ember-rails を使いたい方には

     どうして素直に ember-cli-rails や ember-cli そのものを使おうとしないのかはわからないけど
     どうしても ember-rails の世界に住みたいのであれば
     [[https://github.com/discourse/discourse][discourse]] のソースを参考にしたら良いと思う。

     どうやら [[https://github.com/discourse/discourse/pull/11932][ember-cli に乗り換える方針で動いているよう]] だが
     今日時点の Gemfile には未だに discourse-ember-source などの記述が残っている状態であり、
     まだ完全移行はできてない様子。

     [[https://rubygems.org/gems/discourse-ember-source/versions/3.12.2.2][discourse-ember-source]] は 3.12 系まで追従していたようなので
     そこまでは discourse の真似をすれば使えるだろう。

     また彼らは ember-rails を使いながら qunit でのテストもできるようにしているようである。
     正直マジか頑張ったなって気持ち。
     ちょっとどうやって動かしているのかはわからない。
     あんまり調べる気力もない。
     なんとなくわかったことは ES6 の module システムを活用して頑張ってる雰囲気があることである。

     他にも addon も使えるようにしている様子でもあるが、
     これもちょっとよくわかってない。
     あまり adoon が使われてる気もしないが……。

     ともかく ember-rails を独自に拡張した上で色々頑張っているようである。すごい。
     それでももう ember-cli-rails に乗り換えようとしているようなので
     今から ember-rails の世界に住もうとするのはやめた方がいいはず。

     あ、よく見ると Rails は 6.0 系だ。
     ってことは少なくとも discourse-ember-rails なら Rails 6.0 でも動くわけか。なるほど。

**** で、なぜ自分は ember-rails で新規アプリを書いているか

     マゾなので、敢えてその環境で新規アプリを用意しておいて
     そこから ember-cli-rails に移行する、みたいなことをしてみたいから。

     本当は自分で ember-rails なアプリを書くつもりはなかったんだけど
     サンプルになるようなアプリが探せなかったってのもある。
     これが Yak Shaving か〜と思いながら粛々と小さなアプリを書いていくのであった

     できたらまた記事にする。
     アプリ自体は公開しないけど、ソースは GitHub に上げるつもり。

*** DONE ember-rails で書いた Web アプリを GitHub で公開した :@Rails:@Ember_js:
    CLOSED: [2021-02-21 日 15:40]
    :PROPERTIES:
    :EXPORT_FILE_NAME: publish-ember-rails-app
    :END:

    [[*2021年にもなって ember-rails で新規アプリを書いてみてる][この間の記事]] で書いたように
    ember-rails で簡単なアプリケーションを作ってた。
    よくある TODO アプリである。

    [[file:images/screenshot-ember-rails-todo-app.png]]

    先週時点では「テストとかなくてもいいから動けばいいだろ」って気持ちだったけど
    なんとなーくテストを追加したくなったり
    あんまり慣れてない docker-compose 対応してみたりしていたのと
    平日はこのプログラムに触れてなかったので、結構日が空いてしまった。

    まあ、それはともかくとして、
    とりあえず [[https://github.com/mugijiru/ember-rails-todo-app/]] に置いておいた
    現時点の最新コミットで [[https://github.com/mugijiru/ember-rails-todo-app/tree/v1.1.1][v1.1.1]] のタグを振ってるやつは
    自分の知ってる一番古いスタイルで書かれてる状態にしてある。

**** 使ってる Gem

     - Ember.js 関係
       - ember-rails
       - ember-source
       - jquery-rails
         - Ember.js は 2 系まで jquery に依存しているので
           - よく見ると ember-rails の依存に入ってるから書かなくて良かったな……
       - active_model_serializers 0.9
         - 0.9 系じゃないとうまく動かないっぽい
     - CSS framework
       - bootstrap-sass
         - レガシー感の演出のため敢えてこれにしている
     - テスト関係
       - rspec-rails
       - factory_bot_rails
       - database_rewinder
       - capybara
       - selenium-webdriver

     あたり。

**** レガシー感の演出

     レガシー感を出すために bootstrap-sass(Bootstrap3系になる)を使ったりはしているが
     あまり特別なものは使ってない。

     また ember-rails で ember アプリのソースコードを generate すると
     es6 module を使ったようなコードが出力されるけど、
     これも敢えてレガシー感を出すために module を使わない形式に書き直している。

     よりレガシー感を出すために CoffeeScript にするという手もあったけど、
     さすがにそこまでは頑張りたくないw
     もう何年も触ってないよ CoffeeScript...

     そしてページ全体を Ember.js にはしないで
     ページの一部を Ember.js にする [[https://guides.emberjs.com/v2.18.0/configuring-ember/embedding-applications/][埋め込み]] 形式を採用している。
     既存のアプリに Ember.js を後乗せした感の演出である。
     実際、構築時には一時的に普通の Rails App として動くようにしていた。

     他にこだわったところは、今回は単一のアプリケーションしか動かしてないけど
     [[https://github.com/emberjs/ember-rails#multiple-ember-application][Multiple Ember Application]]
     の作法に則って、Ember アプリケーションを追加で乗せられるようにしている。
     これにより「この画面も Ember 化しようず」という流れで
     Ember アプリが複数動いてる状態により近くなったんじゃないかなと。
     実際今回動いてるのは1つだから、ちょっと違うけどね。。。

**** 最後に

     ここから段々と最新の Ember.js を使えるように寄せていくつもり。

*** DONE 古い ember-rails App で一部ファイルを ES6 Module 化 :@Rails:@Ember_js:
    CLOSED: [2021-02-21 日 22:41]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-partial-modulize
    :END:
**** これは何?
     ember-rails を古いスタイルで書いておいて
     それをモダン化していく企画の第一弾の記事。

**** 何をしたのか
     今回は ES6 module を使ってない ember-rails アプリケーションで
     一部のファイルだけ ES6 Module にしてみた。

**** 何が嬉しい?
     今回扱ってるアプリケーションのサイズはとても小さいので
     まとめて置き換えることも可能というか、
     ぶっちゃけ [[https://github.com/mugijiru/ember-rails-todo-app/pull/7][古いスタイルに書き換えた PR]] を revert するだけで
     ES6 Module 化できたりする。

     しかし、世の中に潜んでいる、レガシー化した ember-rails のプロジェクトでは
     全部まとめて ES6 Module にするのはファイル数が多過ぎて困難かと考え、
     敢えて一部のファイルだけ ES6 Module 化する方法を探してみた。

**** どうやったらできるの?

     簡単に言うと
     ES6 Module 形式で書いたやつを import して
     Ember.js Application の Namespace に放り込めばいいだけ。

***** Example
      まずはコンポーネントなどを
      ~app/assets/javascripts/ember-app/components/foo.module.es6~ ってファイル名で

      #+begin_src js
      import Ember from 'ember';

      export default Ember.Component.extend({});
      #+end_src

      のように書いておく。
      拡張子が ~.module.es6~ というのがポイントで、
      そうしておくと
      [[https://github.com/tricknotes/ember-es6_template][ember-es6_template]] という Gem が
      自動的に ES6 の module として判定してくれるようになっている
      https://github.com/tricknotes/ember-es6_template/blob/c1c7b8d23be7669a0aa6c5f9c71b916a3799f9a6/lib/ember/es6_template/sprockets.rb#L10

      そして ~app/assets/javascripts/ember-app/application.js.es6~ の末尾にでも

      #+begin_src js
      import FooComponent from 'ember-app/components/foo';

      EmberApp.FooComponent = FooComponent;
      #+end_src

      のように書いたら、
      一応 module 形式で書けるし、
      それを window.EmberApp で用意した Ember.js Application で使えるって感じ。

**** ファイルの数と同じ量の import 書くの?

     だるいよね。
     なので import 処理は
     ~app/assets/javascripts/ember-app/import-modules.js.es6.erb~
     という erb template でも分離して

     #+begin_src erb
     <% module_dir = Rails.root.join('app/assets/javascripts/ember-app/modules') %>
     <% Dir.each_child(module_dir) do |dir| %>
       <% next unless FileTest.directory?("#{module_dir}/#{dir}") %>
       <% Dir.glob('*.module.es6', base: "#{module_dir}/#{dir}") do |module_file| %>
         <% module_name = File.basename(module_file, '.module.es6') %>
         <% klass_name = "#{module_name.underscore.camelize}#{dir.underscore.singularize.camelize}" %>
     import <%= klass_name %> from 'ember-app/modules/<%= dir %>/<%= module_name %>';
     EmberApp.<%= klass_name %> = <%= klass_name %>;
       <% end %>
     <% end %>
     #+end_src

     とでも書いておけば全部いい感じに読んでくれる。

**** 関連 PR

     実際に動くコードは以下の PR で用意した。
     https://github.com/mugijiru/ember-rails-todo-app/pull/8
     https://github.com/mugijiru/ember-rails-todo-app/pull/9

     最初の PR で ~modules~ フォルダにさらに components フォルダを掘って
     その中にファイルを配置している。

     その方が全部移行できた後にまるっと置き換えするのに楽そうだからだ。

     また import して Namespace に放り込む処理も別ファイルに追い出している。
     これも、完全移行が済んだら不要になるファイルなので
     消しやすさを重視して分割しておいた。

     さらに後続の PR で、
     複数のタイプが来ても対応できるように書き換えている。
     Model は対応できてないけど、ま、Model は移行してないのでとりあえず放置。

     CI でテストも通しているしバッチリだと思う。
     デプロイできるようにはしてないからサーバで動くかは確認してないけど、ま、大丈夫だろ

*** DONE 古い ember-rails App で ES6 Module 化を完了した   :@Rails:@Ember_js:
    CLOSED: [2021-02-23 火 20:45]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-complete-modulize
    :END:

    - [[https://github.com/mugijiru/ember-rails-todo-app/pull/10][#10 サブフォルダのファイルを全て module に移行した]]
    - [[https://github.com/mugijiru/ember-rails-todo-app/pull/11][#11 残りのファイルも module 化した]]

    でやってることで全てだけど
    [[*古い ember-rails App で一部ファイルを ES6 Module 化][前回の記事]] でやってた内容を完了まで持って行った。

**** サブフォルダ以下の ES6 Module 化
     https://github.com/mugijiru/ember-rails-todo-app/pull/10 でやったこと。

     これは基本的に単純で、
     ほぼ前回の記事でやってることを全部のフォルダに適用しただけ。

     Model だけ命名規則が他と違うので
     import 関連の処理をそこだけ分岐している

     #+begin_src erb
     <% if dir == 'models' %>
       <% klass_name = module_name.underscore.camelize %>
     <% else %>
       <% klass_name = "#{module_name.underscore.camelize}#{dir.underscore.singularize.camelize}" %>
     <% end %>
     import <%= klass_name %> from 'todo-app/modules/<%= dir %>/<%= module_name %>';
     TodoApp.<%= klass_name %> = <%= klass_name %>;
     #+end_src

     Model は ~models/hoge.module.es6~ とあったら ~Hoge~ として使われるようにして、
     他は例えば Component だと ~components/fuga.module.es6~ とあったら ~FugaComponent~ として使われるようにしているだけ。

     あとはそれぞれのファイルを ~*.js.es6~ から ~*.module.es6~ に rename して import, export に書き換えるだけ。
     とても簡単だし、全部まとめて変更する必要もないので楽。

     ただこれをやってる時に気付いたのが
     ~import-modules.js.es6.erb~ が cache されてるおかげで
     module 化対象のファイルだけ変更・移動しても import 文が変更されなくて
     うまく読み込まれない問題があるということ。
     何故か rspec は通ったりするけど。

     まあその時は ~rails tmp:cache:clear~ して cache を消すか
     ~import-modules.js.es6.erb~ に適当に空行でも加えて cache を使われないようにしたら解決する。

**** router.js.es6, <APP_NAME>.js.es6, environment.js.es6 の ES6 Module 化
     https://github.com/mugijiru/ember-rails-todo-app/pull/11 でやったこと。

     サブフォルダのファイルを全部 module にしたら
     後は変更しないといけないファイルはこれぐらい。

     変更の流れは大体以下の感じ

     1. router.js.es6 をこれまでのファイルと同じように module 化
     2. environment.js.es6 も同様に module 化
     3. <APP_NAME>.js.es6 の module 化とそれに伴うファイル移動等

***** router.js.es6 をこれまでのファイルと同じように module 化
      https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/359520f6656920ac8ef3fe623d15f2368cc66a78

      この commit でやってることそのもの。

      拡張子を module.es6 に変更して中身を module っぽく書いて
      require される順番を最後に移動し、最後に他のファイルみたいに import してあげるだけ。

***** environment.js.es6 も同様に module 化
      実はこのファイルをまともに使ってなかったので PR では後ろに回したんだけど、
      多分ちゃんとやるならこのタイミングかなって。

      これもさっきの手順と同じ感じだと思う。
      require するタイミングは ~//= require ./todo-app~ の直前になる。
      そのタイミングになる理由はよく知らんけど
      ember-rails で generate したらそこに来るからそこでいいんだろ(適当)

      実際 import して使われるタイミングは application.js.es6 の中で明示的に import することになるので
      require_self するより前ならどこでも良さそうな気はする。

      あと、多分、古いスタイルに書き換える時に適当にやってたので
      そもそも古いスタイルでの environment の置き方が正しくなさそうな気もする。

      一応 https://guides.emberjs.com/v1.10.0/configuring-ember/ に

      #+begin_quote
      Note that the above code must be evaluated before Ember.js loads.
      #+end_quote
      と書いてるのでそれに従って対応してたつもりだけどね。

      ま、古いスタイルの正しいやりかたを必要としている人はいないだろうし
      新しい形式でちゃんと動けば良かろう。ちゃんと動くか知らんけど。

***** <APP_NAME>.js.es6 の module 化とそれに伴うファイル移動等

      https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/d3673bfa455906abd0ff6d31d1d3f4f083bd4a71
      の commit でやってることだけど、ここが結構まとめて色々やらないといけなさそう。

      <APP_NAME>.js.es6 を ES6 Module 化をするんだけど
      ここが一番色々書き変わるところ。

      事前に Namespace を用意する必要がなくなったので require_self を一番最後にしたり、
      ~import Application from 'ember-rails/application~ しておいて
      そこから extend して export して、みたいな。
      まあ [[https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/d3673bfa455906abd0ff6d31d1d3f4f083bd4a71#diff-7aa5fb21bec5b1e11d78f1b7c34b3b92f05b293d97a99ed2af713f81ea5dab82][ファイル]] を見た方が早いか。

      で、こいつを ES6 Module にすると ember-rails での自動 import が動くようになる。
      なので、事前に module 化していたファイルを全部本来の位置に戻した上で
      これまでお世話になってきた ~import-modules.js.es6.erb~ にさよならすることになる。
      ま、そいつは消しやすいように別ファイルに分離していたんだけども。

      あと当然 application.js.es6 も、
      他のファイルが全部 module 化された前提で書き換える必要がある。
      まあほとんど <APP_NAME>.js.es6 を import して create するだけなんだけど。

      以上でほぼ終わりだけど、
      不要になった modules フォルダを消して require_tree する処理を消すのを忘れずに。
      麦汁さんはそれを忘れて [[https://github.com/mugijiru/ember-rails-todo-app/pull/11/commits/0f90fda419f9c23f844ba2e53dc1c2fa2e9b5d51][commit を積むことになった]]

**** ここまでやると何ができるようになるか

     ember-rails で書いた上で最も最新の記述に変更できた状態となる。
     というわけで、これでようやく ember-cli-rails 移行する準備ができました! やったね!

     まあぶっちゃけ ember-cli-rails 移行と module 化を同時にやっちゃうという手もあるけど、
     1回1回の変更差分を小さくするには、バラバラがいいかなってことで分けてやっている。

     だって、そうじゃないと「はい変更の多い PR はリジェクト〜wwww」ってされかねない^^

*** DONE ember-rails でコンポーネントを共通ライブラリとして切り出す :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 10:45]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-extract-common-libs
    :END:

    ember-rails を使って1つの Rails アプリの上に
    複数の Ember.js アプリケーションを動かしていると
    各アプリで同じようなコンポーネントを使っていたり、
    あるいは同じようなコンポーネントが必要だというのに気付いて
    共通ライブラリとして実装したくなることがある。あるんだよ。

    というわけで、その共通化を2パターンでやってみた。
    2パターンというのは 旧来の書き方の場合と
    ES6 Module 対応版の場合とである。

    なおいずれのパターンもサーバへのデプロイはやってないので
    もしかしたらサーバ環境では動かないかもしれないがご容赦を。

**** 旧来版
     先に答えを出すと
     https://github.com/mugijiru/ember-rails-todo-app/pull/13
     に実装した通りである。

***** template からの呼び出し
      template で ~{{ember-libs/button}}~ と書いた場合に
      Resolver には ~component:ember-libs/button~ として解釈するように要求されるっぽい。
      これはソースからではなく、挙動的に確かめただけ。

***** コンポーネントの探索
      旧来の書き方の場合に探索に使われるのが GlobalsResolver というやつ。

      この GlobalsResolver というやつは [[https://github.com/emberjs/ember.js/blob/e2007b6ecb046fd06f6b43c381e8a1128914ad43/packages/%40ember/application/globals-resolver.js#L59-L76][コメント]] にも書かれてるように
      ~component:ember-libs/button~ と渡されたら、
      GlobalsResolver は ~EmberLibs.ButtonComponent~ として解釈するようになっている。
      つまり EmberLibs という名前空間の ButtonComponent を探しに行くようになっている。

***** 名前空間の定義
      というわけで、まずは [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-e1803bb0635866bc90975a1321dbfa6d20be59e76ec3d7b80c8acc4656f8af9fR6][ember-libs/ember-libs.js.es6]] に書いてるように

      #+begin_src js
      window.EmberLibs = Ember.Namespace.create()
      #+end_src
      と書くことで
      EmberLibs という名前空間を定義してやる。

      一応 ~ember-libs/ember-libs.js.es6~ では require の順番として
      ember はそこで定義している実装を使うので先に require して
      そのファイルで定義している名前空間を components で使うので components を require するより前に
      require_self をしている。

***** 共通コンポーネントの記述
      各コンポーネントはその名前空間の下に入るように書けばいい。
      例えば [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-9f9be147342dc470d8f0cba8a06a55a210550e01b22502bd6e0aff0d029ae38cR1][ember-libs/components/button.js.es6]] に書いてるように

      #+begin_src js
      EmberLibs.ButtonComponent = Ember.Component.extend()
      #+end_src

      というように書いてやれば動く。

***** config.handlerbars.templates_root の設定

      templates を ember-libs/templates に入れるので
      Rails 側の設定で ~config.handlebars.templates_root~ に ~ember-libs/templates~ を追加するのを忘れずに。
      ember-rails の設定例に従っていれば [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-c1fd91cb1911a0512578b99f657554526f3e1421decdb9e908712beab57e10f9R34][config/application.rb]] に設定があるはず。

***** 利用側の設定
      あとは [[https://github.com/mugijiru/ember-rails-todo-app/pull/13/files#diff-2cb7f9d0c761533d0e2b01e0b7e6f4a34529c7b52f9a13c7493b2629251bccd8R9][todo-app/application.js.es6]] に書いてるように
      この共通コンポーネントを使いたいアプリ側で

      #+begin_src js
      //= require ember-libs/ember-libs
      #+end_src

      としてやるだけでさくっと使えるようになる。

***** 他の type について
      試してないけど mixin や service ぐらいなら同じノリでいけるんじゃないかなと思ってる。
      model もいけそう。
      名前空間が変わるだけだし、その呼び出しも難しくないし、大体なんとかなりそう。

***** 余談: 名前空間を分けない場合

      上のようなやりかたをしているのは、名前空間を分けたいってのが先だったので、
      各アプリで名前空間を分ける必要がなければ、全部のアプリで

      #+begin_src js
      window App = Ember.Application.create()
      #+end_src

      とかしちゃって

      ~ember-libs/components/button.js.es6~ では普通に書く場合と同じように

      #+begin_src js
      App.ButtonComponent = Ember.Component.extend()
      #+end_src

      みたいにしておいて require したら ~{{button}}~ で使える。
      個人的には、名前空間が混ざるとどっちかが上書きされたりしそうで怖くて嫌だけど。

**** ES6 Module 対応版の場合
     最初に答えを出すと
     https://github.com/mugijiru/ember-rails-todo-app/pull/12
     で実装したやつ。

***** コンポーネントの探索
      ES6 Module で書かれている Ember Application では
      基本的に単一の名前空間しか持たないようである。
      また、使用される Resolver が [[https://github.com/ember-cli/ember-resolver/tree/v0.1.21][ember-resolver@0.1.21]] となっている。

      こいつは ~component:ember-libs/button~ と渡って来た時の解釈が GlobalsResolver と異なっている。
      この ember-resolver の場合は、アプリケーションの下の ~components/ember-libs/button~ を探しに行く。

      なのだけど今回はそんなところを探しに行って欲しくないので、
      regsiter を Ember.js で自動的に解決して対応してもらうのではなく
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-029812c538a995224fcf19bfa24f65558246c054aea77c95ec1f4a404b4f5256R1][ember-libs/ember-libs.module.es6]] に書いているように、
      自前で

      #+begin_src js
      application.register()
      #+end_src

      して対応することにした。

***** コンポーネントの register
      基本的には以下のように書いておけば Button コンポーネントは動くようになる。

      #+begin_src js
      import Button from './components/button';

      application.register('component:ember-libs/button', Button);
      #+end_src

      が、コンポーネントが増えていった際に全部そうやって書くのはアホらしい。
      というわけで、自動的に解決するようにした。

***** コンポーネントの auto register

      ES6 Module 対応して import している場合に ember-rails では実際はどんな形に transpile されるかというと
      どうやら requirejs の機能で読み込んだりしているらしい。

      で export されているファイルは ~requirejs.entries~ に含まれているので
      そこから必要なものを探し出して
      ~application.register~ に対し、解釈してほしい名前で渡してクラスを渡しておけば
      template で ~{{ember-libs/button}}~ とした時に require したクラスのインスタンスとして動いてもらえる。

      という感じで自動的に register する処理を [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-029812c538a995224fcf19bfa24f65558246c054aea77c95ec1f4a404b4f5256R4][メソッドにして]] おけば、
      利用側はそれを呼び出すだけでセットアップが済む

***** config.handlebars.templates_root の設定
      やはりこちらの場合も templates を ~ember-libs/templates~ に入れるので
      Rails 側の設定で ~config.handlebars.templates_root~ に ~ember-libs/templates~ を追加するのを忘れずに。
      ember-rails の設定例に従っていれば [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-c1fd91cb1911a0512578b99f657554526f3e1421decdb9e908712beab57e10f9R34][config/application.rb]] に設定があるはず。

***** 利用側の設定
      アプリ側では [[https://github.com/mugijiru/ember-rails-todo-app/pull/12/files#diff-97468a821d4c12c1b223617fba29257a5b1e00553a1b8e8f403ee99864756ebaR4][initializers/resolve-common-libs に書いている]] ように
      initializer で

      #+begin_src js
      EmberLibs.registerAll()
      #+end_src

      を叩くだけでいい感じに使えるようになる。

***** 他の type について
      試してないけど、component でやってみた所感。

      mixin はどうせ明示的に import して使うので関係なさそう。
      service は、component と同じやりかたでいけそうな気がする。
      model もいけそうなので user model を共通化するような用途がありそう。

      controller もいけそうだけどそれに付随する route からどう呼ばれるかが難しそう。

***** 余談: 他の方法について
      多分 EmberEngine とか EmberAddon の仕組みを使って
      似たようなことはできそうな気はする。

      だけど ember-rails で Engine や Addon を使うというのは
      それはそれでかなり大変かと思われるので今回はそれを動かすようなことはしてない。

      より正確にいうと、
      それしか方法がないかもと思って途中まで調べたけど、
      厳しそうだったので今回は上述の方法にしておいた。

**** 最後に

     旧来版と ES6 Module 対応版とで実装方法は異なるが
     どちらでも同じような使い勝手でコンポーネントを共通ライブラリとすることができることがわかった。

     両方のパターンが使えることがわかったので、
     ES6 Module 対応版への移行がまだでも躊躇せずライブラリを分割できそう。

*** DONE ember-rails でコンポーネントをサブフォルダに配置する :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 11:19]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-component-in-subfolder
    :END:
    Ember.js に限らずコンポーネントは増えてくると
    サブフォルダに分割して管理したくなるよね。
    ということでそのあたりの記事。

    これも、ES6 Module 対応版と旧来版の両方を書く。
    ES6 Module 対応版は何も考えることがないので、
    この記事は旧来版のためにあるようなものだけど。

**** ES6 Module 対応版の場合
     上に書いたように
     これは https://github.com/mugijiru/ember-rails-todo-app/pull/14 に実装してあるけど
     とっても簡単

***** component をサブフォルダに移動
      ~components~ の下に適当なフォルダを掘って
      その中に移動するだけ。

***** template をサブフォルダに移動
      ~templates/components~ の下に適当なフォルダを掘って
      その中に移動するだけ。

***** template からの呼び出し
      template, component をそれぞれ

      - template :: ~templates/components/hoge/fuga.hbs~
      - component :: ~components/hoge/fuga.module.es6~

      と配置した場合は
      ~{{hoge/fuga}}~ と書いて呼び出せばいい感じに動く。以上。

      こういう感じで動くように [[https://github.com/ember-cli/ember-resolver/tree/v0.1.21][ember-resolver@0.1.21]] が作られてるっぽいのでとても楽。

      Ember.js のドキュメントなどを見ている感じだと
      多分もっと新しいバージョンでも同じ感じで動くっぽい。
      というわけで Ember.js@3 にしても多分動きそうなので安心感がある。

**** 旧来版の場合
     これは GlobalsResolver の挙動のおかげでちょっと大変。

     と言っても
     https://github.com/mugijiru/ember-rails-todo-app/pull/15
     で実装してある。

     今回やりたかったことは、
     テンプレートとコンポーネントをサブフォルダに移動して扱えるようにすることなので、
     その実現方法を書いておく

***** template からの呼び出し
      ~{{hoge/fuga}}~ と呼び出した際に [[https://github.com/emberjs/ember.js/tree/v2.18.2/packages/ember-application/lib/system/resolver.js#L34][GlobalsResolver]] でどう解釈されるとかというと
      [[*ember-rails でコンポーネントを共通ライブラリとして切り出す][前の記事]] にも書いたように
      Hoge という名前空間の FugaComponent を探しに行くようになってるというのが前提。

***** component をサブフォルダに移動

      GlobalsRegister の解釈に合わせて
      FugaCompnent を Hoge 名前空間に所属させればいいので

      #+begin_src js
      Hoge.FugaComponent = Ember.Compnent.extend()
      #+end_src

      という形で定義しておけばいい。

      旧来方式だとファイル自体は components の中にあればファイル名も位置も何でもいいはずなので
      人間がわかりやすいように ~components/hoge/fuga.js.es6~ として配置したら良い。

      また、事前に Hoge という名前空間は必要なので
      ~components/hoge.js.es6~ とファイルで

      #+begin_src js
      window.Hoge = Ember.Namespace.create()
      #+end_src

      としておく。

      前回の共通ライブラリ切り出しと大体似たお話ですね。

***** template をサブフォルダに移動
      これは難しいことは何もなくて
      ~templates/components/<名前空間>/<コンポーネント名>.hbs~
      みたいに配置したら良い。

      つまり ~Hoge.FugaComponent~ の場合は
      ~templates/components/hoge/fuga.hbs~
      と置けばいい。

***** さらにネストさせたい場合
      試してないけど、
      [[https://github.com/emberjs/ember.js/blob/e2007b6ecb046fd06f6b43c381e8a1128914ad43/packages/%40ember/application/globals-resolver.js#L221][GlobalsRegister の実装]] を見ている感じだと、多分

      #+begin_src js
      window.Hoge = Ember.Namesupace.create()
      #+end_src

      #+begin_src js
      Hoge.Fuga = Ember.Namesupace.create()
      #+end_src

      #+begin_src js
      Hoge.Fuga.PiyoComponent = Ember.Component.extend()
      #+end_src

      にみたいな感じに名前空間をネストさせれば大丈夫そう。

**** 最後に
     前回の共通ライブラリ切り出しよりは簡単でしたね。

     ES6 Module 対応版では直感的にやるだけで終わるし、
     旧来版でも共通ライブラリと大体やること一緒というか、
     それよりも手順が少ないので、サブフォルダへの移動を先にやった方が良かったかも。

     あと、今回も両パターンでやってるので、
     ES6 Module 移行前にこちらを実施しても簡単な修正で対応できることがわかりました。やったね。

*** DONE ember-rails でユーザー情報を Rails から inject    :@Rails:@Ember_js:
    CLOSED: [2021-02-28 日 13:10]
    :PROPERTIES:
    :EXPORT_FILE_NAME: ember-rails-inject-from-rails
    :END:

    フロントエンドのフレームワークを使っていて、
    そのフレームワークで Server Side Rendering をしてない時に
    API 経由でデータ渡すよりも表示用の HTML 経由で直接データを渡したい時がある。

    ember-rails を使ってる時もそれはあって、
    今回は Haml 経由で Ember.js に情報を渡して表示する方法を書いてみた。
    もちろん旧来版と ES6 Module 対応版の両方で実装している。

**** 旧来版
     https://github.com/mugijiru/ember-rails-todo-app/pull/16 で実装したやつ。


***** おおまかな実装内容
      こちらは名前空間に Ember.js の外からアクセスできるので
      Haml 内に JavaScript を埋め込んで Ember に渡すというちょっと乱暴なことができる。

      今回は email を todo-items テンプレート内で表示したかったので
      [[https://github.com/mugijiru/ember-rails-todo-app/pull/16/files#diff-69c2e4b0a6040f2873e963c79265340fd97c099e1ea1a7fbf579902259126e3fR1][Ember.js の呼び出し元の haml]] 内で

      #+begin_src js
      :javascript
        TodoApp.register('session:current-user', Ember.Object.extend({ email: '#{current_user.email}' }));
        TodoApp.inject('controller:todo-items', 'current-user', 'session:current-user');
      #+end_src

      と書いてみた。

      以下にもう少し詳細に書いてみる。

***** ユーザー情報の登録
      #+begin_src js
      TodoApp.register('session:current-user', Ember.Object.extend({ email: '#{current_user.email}' }));
      #+end_src

      という記述で JavaScript の中に Haml での Ruby のコード呼び出し機能を用いて
      email を EmberObject を継承したクラスにぶち込んでいる。

      正直 ~:javascript~ で書いて Ruby のコードを呼び出すのは結構乱暴だとは思うけど
      できちゃうのでやっちゃった。

***** コントローラへの inject

      アプリケーションに ~session:current-user~ として登録できたので、後はもう

     #+begin_src js
     TodoApp.inject('controller:todo-items', 'current-user', 'session:current-user');
     #+end_src

     として controller に inject することができる。

***** template での表示

      inject された controller の template で ~{{current-user.email}}~ と記述するだけで
      そのユーザーのメアドが表示される。以上。

**** ES6 Module 対応版
     https://github.com/mugijiru/ember-rails-todo-app/pull/17 で実装したやつ。

***** おおまかな実装内容
      こちらは旧来版とは違って名前空間は隠蔽されているため
      Haml で JavaScript を書いて埋め込むなんて荒技はできない。

      だけどまあそんなことをしなくても
      data 属性に情報を埋めておいて
      それを initializer で取得して使えばいいだけである。

***** Haml へのデータ埋め込み
      Haml の方では

      #+begin_src haml
      #todo-app{ data: { email: current_user.email } }
      #+end_src

      こんな感じにデータを埋めておく。
      それを Ember.js の initializer で取得して処理してあげれば良い。

***** initializer でのデータの取得
      まずはデータを

      #+begin_src js
      const currentUser = Ember.Object.extend({
        email: document.querySelector(application.rootElement).dataset.email
      });
      #+end_src

      という感じで取得して適当な変数に放り込んでおく。
      ま、大体普通の JavaScript なので何も難しいことはない。

***** アプリケーションへの登録
      上で取得したデータをアプリケーションから見れるように登録してあげる必要があるので
      以下のように ~application.register()~ でデータを登録する。

      #+begin_src js
      application.register('session:current-user', currentUser);
      #+end_src

***** controller への inject
      上に書いた感じで application に登録してしまえば、後は旧来版と同じように

      #+begin_src js
      application.inject('controller:todo-items', 'current-user', 'session:current-user');
      #+end_src

      という感じで設定できる。

***** template での表示
      あとは旧来版と同じく
      inject された controller の template で ~{{current-user.email}}~ と記述するだけで
      そのユーザーのメアドが表示されると。うん、簡単でしたね。

**** 最後に
     API を経由せずに Ember.js にデータを渡す方法が
     旧来版と ES6 Module 対応版の両方で書けることがわかったので、
     旧来版から移行しようとした時もすぐ書き直せそうで安心。

     ES6 Module 対応版の方は、
     ember-rails から ember-cli-rails とかに乗り換えてもそのまま使えそうだしね。

*** TODO org-agenda を活用し始めた                              :@Emacs:@org:
    :PROPERTIES:
    :EXPORT_FILE_NAME: try-org-agenda
    :END:

    昨年から org-mode をもっと活用していこうということで、
    org-clock を使い始めたり org-pomodoro を導入したり org-habits を設定してみたりしている麦汁さんです。

    org-mode は機能が豊富過ぎてマジで何が出来るのか全貌を把握し切れてないのですが、
    そんな中で、やっぱり全然把握できてなくて使ってなかった機能の1つが org-agenda ってやつ。

    なんかうまく使うと、予定を組んでたり締切を設定していたりするタスクが一目瞭然になって
    お仕事などが捗るという素敵な機能らしいのだけど、
    どうもイマイチ使い方がわからなくて放置していました。
